<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>StereoEffect</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">

	<link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">

</head>
<body>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a> - StereoEffect - Uses dual PerspectiveCameras for <a https: //en.wikipedia.org/wiki/Parallax_barrier" target="_blank" rel="noopener">Parallax Barrier</a> effects.
		By <a href="https://github.com/anhr" target="_blank" rel="noopener">anhr</a>
	</div>
	<canvas id="canvas" height="128" width="128"></canvas>

	<script type="module">

		//import * as THREE from 'https://threejs.org/build/three.module.js';
		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import { THREE } from '../../three.js';//https://github.com/anhr/commonNodeJS
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		//import { AxesHelper } from '../AxesHelper.js';//https://github.com/anhr/AxesHelper
		//import { AxesHelper } from 'https://raw.githack.com/anhr/AxesHelper/master/AxesHelper.js';

		//import { OrbitControls } from '../../../three.js/dev/examples/jsm/controls/OrbitControls.js';//https://github.com/anhr/three.js
		//import { OrbitControls } from 'https://raw.githack.com/anhr/three.js/dev/examples/jsm/controls/OrbitControls.js';

		//import { SpriteText } from '../../../SpriteText/master/SpriteText.js';//https://github.com/anhr/SpriteText
		//import { SpriteText } from 'https://raw.githack.com/anhr/SpriteText/master/SpriteText.js';

		import { dat } from '../../dat/dat.module.js';//https://github.com/anhr/commonNodeJS
		//import { dat } from 'https://raw.githack.com/anhr/commonNodeJS/master/dat/dat.module.js';

		import cookie from '../../../../cookieNodeJS/master/cookie.js';//https://github.com/anhr/cookieNodeJS
		//import cookie from 'https://raw.githack.com/anhr/cookieNodeJS/master/cookie.js';

		import { getLanguageCode } from '../../lang.js';//https://github.com/anhr/commonNodeJS
		//import { getLanguageCode } from 'https://raw.githack.com/anhr/commonNodeJS/master/lang.js';
/*
		import { SpriteTextGui } from '../../../SpriteText/master/SpriteTextGui.js';//https://github.com/anhr/SpriteText
		//import { SpriteTextGui } from 'https://raw.githack.com/anhr/SpriteText/master/SpriteTextGui.js';

		import { GuiSelectPoint } from '../../../commonNodeJS/master/guiSelectPoint.js';//https://github.com/anhr/commonNodeJS
		//import { GuiSelectPoint } from 'https://raw.githack.com/anhr/commonNodeJS/master/guiSelectPoint.js';
*/
		import { StereoEffect, spatialMultiplexsIndexs } from '../StereoEffect.js';//https://github.com/anhr/commonNodeJS
		//import { StereoEffect, spatialMultiplexsIndexs } from 'https://raw.githack.com/anhr/commonNodeJS/master/StereoEffect/StereoEffect.js';

		var camera, scene, renderer, stereoEffect, raycaster;//, axesHelper, controls, intersects, guiSelectPoint;
/*
		const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2(), arrayintersectObjects = [], threshold = 0.02;
		raycaster.params.Points.threshold = threshold;
*/

		init();
		animate();

		function init() {

			camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
			const defaultCameraPosition = new THREE.Vector3( 0.4, 0.4, 2 );
			camera.position.copy( defaultCameraPosition );

			scene = new THREE.Scene();
/*
			scene.userData.optionsSpriteText = {

				textHeight: 0.04,
				fov: camera.fov,

			}
*/
/*
			//AxesHelper

			if ( typeof AxesHelper !== "undefined" ) {

				axesHelper = new AxesHelper ( THREE, scene, {

						//colors: colorsHelper / 0xff, //gray axes
						color: 'rgba(255, 255, 255, 0.5)',
						//color: 'rgba(255, 255, 255)',
						//color: 'red',//'darkgray'

						//cookie: cookie,
						//cookieName: 'mySettings',

						camera: camera,

						scales: {

							display: true,
							text: {

								//textHeight: 0.03,
								//fov: camera.fov,
								precision: 4,
								rect: { displayRect: true },

							},
							x: {

								//zoomMultiplier: 2,
								//offset: 1,
								name: 'Wave',
								min: 0,
								max: 1,
								marks: 7,

							},
							y: {

								name: 'Y',
								min: -1,
								max: 1,
								marks: 3,

							},
							z: {

								//name: 'Z',
								min: -3,
								max: -1,
								marks: 11,

							},

						},

					} );
	
			}
*/

			const points = new THREE.Points( new THREE.BufferGeometry().setFromPoints( [
					new THREE.Vector3( 0.5, 0.5 ,0.5 ),
					new THREE.Vector3( -0.5, -0.5 ,-0.5 )
				] ),
				new THREE.PointsMaterial( {

					color: 0xffffff,
					size: 5,//0.05,
					sizeAttenuation: false,
					alphaTest: 0.5,

				} ) );
/*
			arrayintersectObjects.push( points );
			function getIntersectionPosition( intersection )
				{ return new THREE.Vector3().fromArray( points.geometry.attributes.position.array, intersection.index * points.geometry.attributes.position.itemSize ); }
*/
			//[Raycaster](https://threejs.org/docs/index.html#api/en/core/Raycaster). Raycasting is used for mouse picking (working out what objects in the 3d space the mouse is over) amongst other things.
			//Define of the actions for objects in the 3d space the mouse is over.
			points.userData.raycaster = {

				onIntersection: function ( intersection ) {

					renderer.domElement.style.cursor = 'pointer';

				},
				onIntersectionOut: function ( ) {

					renderer.domElement.style.cursor = cursor;

				},
				onMouseDown: function ( intersect ) {

					alert( 'You have clicked over point' );

				}

			}
			scene.add( points );
/*
			scene.add( new THREE.AmbientLight( 0x222222 ) );

			// light

			const light = new THREE.PointLight( 0xffffff, 1 );
			camera.add( light );
*/
			renderer = new THREE.WebGLRenderer( {

				antialias: true,
				canvas: document.getElementById( 'canvas' ),

			} );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			const cursor = renderer.domElement.style.cursor;
			document.body.appendChild( renderer.domElement );

			stereoEffect = new StereoEffect( THREE, renderer, {

				spatialMultiplex: spatialMultiplexsIndexs.SbS,//Side by side stereo effect
				far: camera.far,
				camera: camera,
				cookie: cookie,//Saves a custom Stereo Effects settings in the cookie
				//stereoAspect: 1,

			} );
			stereoEffect.setSize( window.innerWidth, window.innerHeight );

			//Using [dat.gui](https://github.com/anhr/dat.gui) for change of the StereoEffect settings.

			const gui =  new dat.GUI();
			stereoEffect.gui( gui, {

				getLanguageCode: getLanguageCode,

			} );

			//[Raycaster](https://threejs.org/docs/index.html#api/en/core/Raycaster). Raycasting is used for mouse picking (working out what objects in the 3d space the mouse is over) amongst other things.

			raycaster = new THREE.Raycaster();
			raycaster.params.Points.threshold = 0.02;//threshold is the precision of the raycaster when intersecting objects, in world units. See [params](https://threejs.org/docs/#api/en/core/Raycaster.params)
			raycaster.setStereoEffect( {

				renderer: renderer,
				camera: camera,
				stereoEffect: stereoEffect,
				onIntersection: function ( intersects, mouse ) {

					points.userData.raycaster.onIntersection( intersects[0] );

				},
				onIntersectionOut: function ( intersects ) { points.userData.raycaster.onIntersectionOut() },
				onMouseDown: function ( intersects ) {

					var intersection = intersects[0];
					if (
						( intersection.object.userData.raycaster !== undefined )
						&& ( intersection.object.userData.raycaster.onMouseDown !== undefined ) ) {

						intersection.object.userData.raycaster.onMouseDown( intersection );

					}

				}

			} );
			raycaster.stereo.addParticle( points );

			window.addEventListener( 'resize', onWindowResize, false );

			//
/*
			controls = new OrbitControls( camera, renderer.domElement );
			controls.target.set( scene.position.x * 2, scene.position.y * 2, scene.position.z * 2 );
			controls.update();
*/

		}
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		//Raycaster https://threejs.org/docs/index.html#api/en/core/Raycaster
		const mouse = new THREE.Vector2();
		window.addEventListener( 'mousemove', function( event ) {

			// calculate mouse position in normalized device coordinates
			// (-1 to +1) for both components

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			// update the picking ray with the camera and mouse position
			raycaster.setFromCamera( mouse, camera );

			raycaster.stereo.onDocumentMouseMove( event );

		}, false );
		window.addEventListener( 'mousedown', function( event ) {

			raycaster.stereo.onDocumentMouseDown( event );

		}, false );

		function animate() {

			requestAnimationFrame( animate );

			if ( stereoEffect === undefined )
				renderer.render( scene, camera );
			else stereoEffect.render( scene, camera );

		}

	</script>
</body>
</html>
