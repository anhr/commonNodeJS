function getLanguageCode(){return(navigator?void 0!==navigator.languages&&"unknown"!=typeof navigator.languages&&navigator.languages.length>0?navigator.languages[0]:navigator.language?navigator.language:navigator.browserLanguage?navigator.browserLanguage:navigator.systemLanguage?navigator.systemLanguage:navigator.userLanguage?navigator.userLanguage:(console.error("getLocale() failed!"),""):(console.error("getLocale() failed! !navigator"),"")).toLowerCase().match(/([a-z]+)(?:-([a-z]+))?/)[1]}var _THREE,_dat,_Three,three;class Three{constructor(){}set THREE(t){if(_THREE)return void(Object.is(t,_THREE)||console.error("three: duplicate THREE. Please use one instance of the THREE library."));_THREE=t,_Three=this;const e=t.Float32BufferAttribute,n=t.Line3,o=t.Plane,i=t.Triangle,r=t.Vector3;function s(){const t=0,e=1,s=new r,a=new n,l=new o,u=new r,h=new i;this.ConvexHull=class{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new m,this.unassigned=new m,this.vertices=[]}setFromPoints(t){!0!==Array.isArray(t)&&console.error("THREE.ConvexHull: Points parameter is not an array."),t.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new p(t[e]));return this.compute(),this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(t){const n=t.geometry;if(void 0!==n){if(n.isGeometry)return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");if(n.isBufferGeometry){const o=n.attributes.position;if(void 0!==o)for(let n=0,i=o.count;n<i;n++){const i=new r;i.fromBufferAttribute(o,n).applyMatrix4(t.matrixWorld),e.push(i)}}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let n=0,o=e.length;n<o;n++)if(e[n].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const n=this.faces;let o=-1/0,i=1/0;for(let e=0,r=n.length;e<r;e++){const r=n[e],s=r.distanceToPoint(t.origin),a=r.normal.dot(t.direction);if(s>0&&a>=0)return null;const l=0!==a?-s/a:0;if(!(l<=0)&&(a>0?i=Math.min(l,i):o=Math.max(l,o),o>i))return null}return o!==-1/0?t.at(o,e):t.at(i,e),e}intersectsRay(t){return null!==this.intersectRay(t,s)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let n=t.outside;for(;null!==n.next&&n.next.face===t;)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(void 0!==n)if(void 0===e)this.unassigned.appendChain(n);else{let t=n;do{const n=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=n}while(null!==t)}return this}resolveUnassignedPoints(e){if(!1===this.unassigned.isEmpty()){let n=this.unassigned.first();do{const o=n.next;let i=this.tolerance,r=null;for(let o=0;o<e.length;o++){const s=e[o];if(s.mark===t){const t=s.distanceToPoint(n.point);if(t>i&&(i=t,r=s),i>1e3*this.tolerance)break}}null!==r&&this.addVertexToFace(n,r),n=o}while(null!==n)}return this}computeExtremes(){const t=new r,e=new r,n=[],o=[];for(let t=0;t<3;t++)n[t]=o[t]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let i=0,r=this.vertices.length;i<r;i++){const r=this.vertices[i],s=r.point;for(let e=0;e<3;e++)s.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,s.getComponent(e)),n[e]=r);for(let t=0;t<3;t++)s.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,s.getComponent(t)),o[t]=r)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:n,max:o}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),n=e.min,o=e.max;let i=0,r=0;for(let t=0;t<3;t++){const e=o[t].point.getComponent(t)-n[t].point.getComponent(t);e>i&&(i=e,r=t)}const s=n[r],h=o[r];let d,p;i=0,a.set(s.point,h.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==s&&n!==h){a.closestPointToPoint(n.point,!0,u);const t=u.distanceToSquared(n.point);t>i&&(i=t,d=n)}}i=-1,l.setFromCoplanarPoints(s.point,h.point,d.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==s&&n!==h&&n!==d){const t=Math.abs(l.distanceToPoint(n.point));t>i&&(i=t,p=n)}}const m=[];if(l.distanceToPoint(p.point)<0){m.push(c.create(s,h,d),c.create(p,h,s),c.create(p,d,h),c.create(p,s,d));for(let t=0;t<3;t++){const e=(t+1)%3;m[t+1].getEdge(2).setTwin(m[0].getEdge(e)),m[t+1].getEdge(1).setTwin(m[e+1].getEdge(0))}}else{m.push(c.create(s,d,h),c.create(p,s,h),c.create(p,h,d),c.create(p,d,s));for(let t=0;t<3;t++){const e=(t+1)%3;m[t+1].getEdge(2).setTwin(m[0].getEdge((3-t)%3)),m[t+1].getEdge(0).setTwin(m[e+1].getEdge(1))}}for(let t=0;t<4;t++)this.faces.push(m[t]);for(let e=0,n=t.length;e<n;e++){const n=t[e];if(n!==s&&n!==h&&n!==d&&n!==p){i=this.tolerance;let t=null;for(let e=0;e<4;e++){const o=this.faces[e].distanceToPoint(n.point);o>i&&(i=o,t=this.faces[e])}null!==t&&this.addVertexToFace(n,t)}}return this}reindexFaces(){const e=[];for(let n=0;n<this.faces.length;n++){const o=this.faces[n];o.mark===t&&e.push(o)}return this.faces=e,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const n=this.assigned.first().face;let o=n.outside;do{const i=n.distanceToPoint(o.point);i>e&&(e=i,t=o),o=o.next}while(null!==o&&o.face===n);return t}}computeHorizon(n,o,i,r){let s;this.deleteFaceVertices(i),i.mark=e,s=null===o?o=i.getEdge(0):o.next;do{const e=s.twin,o=e.face;o.mark===t&&(o.distanceToPoint(n)>this.tolerance?this.computeHorizon(n,e,o,r):r.push(s)),s=s.next}while(s!==o);return this}addAdjoiningFace(t,e){const n=c.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,o=null;for(let i=0;i<e.length;i++){const r=e[i],s=this.addAdjoiningFace(t,r);null===n?n=s:s.next.setTwin(o),this.newFaces.push(s.face),o=s}return n.next.setTwin(o),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}};class c{constructor(){this.normal=new r,this.midpoint=new r,this.area=0,this.constant=0,this.outside=null,this.mark=t,this.edge=null}static create(t,e,n){const o=new c,i=new d(t,o),r=new d(e,o),s=new d(n,o);return i.next=s.prev=r,r.next=i.prev=s,s.next=r.prev=i,o.edge=i,o.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return h.set(t.point,e.point,n.point),h.getNormal(this.normal),h.getMidpoint(this.midpoint),this.area=h.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class d{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class p{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class m{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}}this.ConvexHull=(new s).ConvexHull;const a=three.THREE.Vector2,l=three.THREE.Box3,u=three.THREE.BufferAttribute,h=three.THREE.Uint16BufferAttribute,c=three.THREE.Uint32BufferAttribute,d=three.THREE.Sphere,p=three.THREE.Object3D,m=three.THREE.Matrix4,f=three.THREE.Matrix3,g=three.THREE.arrayMax,b=three.THREE.MathUtils;class x{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,o=n.length;e<o;e++)n[e].call(this,t);t.target=null}}}let y=0;const E=new m,v=new p,T=new r,w=new l,A=new l,R=new r;class B extends x{constructor(){super(),Object.defineProperty(this,"id",{value:y++}),this.uuid=b.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(g(t)>65535?c:h)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new f).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(t),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return E.makeRotationFromQuaternion(t),this.applyMatrix4(E),this}rotateX(t){return E.makeRotationX(t),this.applyMatrix4(E),this}rotateY(t){return E.makeRotationY(t),this.applyMatrix4(E),this}rotateZ(t){return E.makeRotationZ(t),this.applyMatrix4(E),this}translate(t,e,n){return E.makeTranslation(t,e,n),this.applyMatrix4(E),this}scale(t,e,n){return E.makeScale(t,e,n),this.applyMatrix4(E),this}lookAt(t){return v.lookAt(t),v.updateMatrix(),this.applyMatrix4(v.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(T).negate(),this.translate(T.x,T.y,T.z),this}setFromPoints(t){const n=[];for(let e=0,o=t.length;e<o;e++){const o=t[e];n.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new e(n,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new l);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new r(-1/0,-1/0,-1/0),new r(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];w.setFromBufferAttribute(n),this.morphTargetsRelative?(R.addVectors(this.boundingBox.min,w.min),this.boundingBox.expandByPoint(R),R.addVectors(this.boundingBox.max,w.max),this.boundingBox.expandByPoint(R)):(this.boundingBox.expandByPoint(w.min),this.boundingBox.expandByPoint(w.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new d);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new r,1/0);if(t){const n=this.boundingSphere.center;if(w.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];A.setFromBufferAttribute(n),this.morphTargetsRelative?(R.addVectors(w.min,A.min),w.expandByPoint(R),R.addVectors(w.max,A.max),w.expandByPoint(R)):(w.expandByPoint(A.min),w.expandByPoint(A.max))}w.getCenter(n);let o=0;for(let e=0,i=t.count;e<i;e++)R.fromBufferAttribute(t,e),o=Math.max(o,n.distanceToSquared(R));if(e)for(let i=0,r=e.length;i<r;i++){const r=e[i],s=this.morphTargetsRelative;for(let e=0,i=r.count;e<i;e++)R.fromBufferAttribute(r,e),s&&(T.fromBufferAttribute(t,e),R.add(T)),o=Math.max(o,n.distanceToSquared(R))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,o=e.position.array,i=e.normal.array,s=e.uv.array,l=o.length/3;void 0===e.tangent&&this.setAttribute("tangent",new u(new Float32Array(4*l),4));const h=e.tangent.array,c=[],d=[];for(let t=0;t<l;t++)c[t]=new r,d[t]=new r;const p=new r,m=new r,f=new r,g=new a,b=new a,x=new a,y=new r,E=new r;function v(t,e,n){p.fromArray(o,3*t),m.fromArray(o,3*e),f.fromArray(o,3*n),g.fromArray(s,2*t),b.fromArray(s,2*e),x.fromArray(s,2*n),m.sub(p),f.sub(p),b.sub(g),x.sub(g);const i=1/(b.x*x.y-x.x*b.y);isFinite(i)&&(y.copy(m).multiplyScalar(x.y).addScaledVector(f,-b.y).multiplyScalar(i),E.copy(f).multiplyScalar(b.x).addScaledVector(m,-x.x).multiplyScalar(i),c[t].add(y),c[e].add(y),c[n].add(y),d[t].add(E),d[e].add(E),d[n].add(E))}let T=this.groups;0===T.length&&(T=[{start:0,count:n.length}]);for(let t=0,e=T.length;t<e;++t){const e=T[t],o=e.start;for(let t=o,i=o+e.count;t<i;t+=3)v(n[t+0],n[t+1],n[t+2])}const w=new r,A=new r,R=new r,B=new r;function P(t){R.fromArray(i,3*t),B.copy(R);const e=c[t];w.copy(e),w.sub(R.multiplyScalar(R.dot(e))).normalize(),A.crossVectors(B,e);const n=A.dot(d[t])<0?-1:1;h[4*t]=w.x,h[4*t+1]=w.y,h[4*t+2]=w.z,h[4*t+3]=n}for(let t=0,e=T.length;t<e;++t){const e=T[t],o=e.start;for(let t=o,i=o+e.count;t<i;t+=3)P(n[t+0]),P(n[t+1]),P(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new u(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const o=new r,i=new r,s=new r,a=new r,l=new r,h=new r,c=new r,d=new r;if(t)for(let r=0,u=t.count;r<u;r+=3){const u=t.getX(r+0),p=t.getX(r+1),m=t.getX(r+2);o.fromBufferAttribute(e,u),i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,m),c.subVectors(s,i),d.subVectors(o,i),c.cross(d),a.fromBufferAttribute(n,u),l.fromBufferAttribute(n,p),h.fromBufferAttribute(n,m),a.add(c),l.add(c),h.add(c),n.setXYZ(u,a.x,a.y,a.z),n.setXYZ(p,l.x,l.y,l.z),n.setXYZ(m,h.x,h.y,h.z)}else for(let t=0,r=e.count;t<r;t+=3)o.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,i),d.subVectors(o,i),c.cross(d),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const o in n){if(void 0===t.attributes[o])continue;const i=n[o].array,r=t.attributes[o],s=r.array,a=r.itemSize*e,l=Math.min(s.length,i.length-a);for(let t=0,e=a;t<l;t++,e++)i[e]=s[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)R.fromBufferAttribute(t,e),R.normalize(),t.setXYZ(e,R.x,R.y,R.z)}toNonIndexed(){function t(t,e){const n=t.array,o=t.itemSize,i=t.normalized,r=new n.constructor(e.length*o);let s=0,a=0;for(let i=0,l=e.length;i<l;i++){s=t.isInterleavedBufferAttribute?e[i]*t.data.stride+t.offset:e[i]*o;for(let t=0;t<o;t++)r[a++]=n[s++]}return new u(r,o,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new B,n=this.index.array,o=this.attributes;for(const i in o){const r=t(o[i],n);e.setAttribute(i,r)}const i=this.morphAttributes;for(const o in i){const r=[],s=i[o];for(let e=0,o=s.length;e<o;e++){const o=t(s[e],n);r.push(o)}e.morphAttributes[o]=r}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let t=0,n=r.length;t<n;t++){const n=r[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const o=n[e];t.data.attributes[e]=o.toJSON(t.data)}const o={};let i=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],r=[];for(let e=0,o=n.length;e<o;e++){const o=n[e];r.push(o.toJSON(t.data))}r.length>0&&(o[e]=r,i=!0)}i&&(t.data.morphAttributes=o,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const s=this.boundingSphere;return null!==s&&(t.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const o=t.attributes;for(const t in o){const n=o[t];this.setAttribute(t,n.clone(e))}const i=t.morphAttributes;for(const t in i){const n=[],o=i[t];for(let t=0,i=o.length;t<i;t++)n.push(o[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let t=0,e=r.length;t<e;t++){const e=r[t];this.addGroup(e.start,e.count,e.materialIndex)}const s=t.boundingBox;null!==s&&(this.boundingBox=s.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}B.prototype.isBufferGeometry=!0;this.ConvexGeometry=class extends B{constructor(t){super();const n=[],o=[];void 0===s&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");const i=(new _Three.ConvexHull).setFromPoints(t).faces;for(let t=0;t<i.length;t++){const e=i[t];let r=e.edge;do{const t=r.head().point;n.push(t.x,t.y,t.z),o.push(e.normal.x,e.normal.y,e.normal.z),r=r.next}while(r!==e.edge)}this.setAttribute("position",new e(n,3)),this.setAttribute("normal",new e(o,3))}};const P=three.THREE.MOUSE,O=three.THREE.Quaternion,H=three.THREE.Spherical,N=three.THREE.TOUCH,M={type:"change"},L={type:"start"},S={type:"end"};this.OrbitControls=class extends x{constructor(t,e){super(),void 0===e&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new r,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:P.ROTATE,MIDDLE:P.DOLLY,RIGHT:P.PAN},this.touches={ONE:N.ROTATE,TWO:N.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return l.phi},this.getAzimuthalAngle=function(){return l.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",Q),this._domElementKeyEvents=t},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(M),n.update(),i=o.NONE},this.update=function(){const e=new r,a=(new O).setFromUnitVectors(t.up,new r(0,1,0)),p=a.clone().invert(),m=new r,f=new O,g=2*Math.PI;return function(){const t=n.object.position;e.copy(t).sub(n.target),e.applyQuaternion(a),l.setFromVector3(e),n.autoRotate&&i===o.NONE&&R(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(l.theta+=u.theta*n.dampingFactor,l.phi+=u.phi*n.dampingFactor):(l.theta+=u.theta,l.phi+=u.phi);let r=n.minAzimuthAngle,b=n.maxAzimuthAngle;return isFinite(r)&&isFinite(b)&&(r<-Math.PI?r+=g:r>Math.PI&&(r-=g),b<-Math.PI?b+=g:b>Math.PI&&(b-=g),l.theta=r<=b?Math.max(r,Math.min(b,l.theta)):l.theta>(r+b)/2?Math.max(r,l.theta):Math.min(b,l.theta)),l.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,l.phi)),l.makeSafe(),l.radius*=h,l.radius=Math.max(n.minDistance,Math.min(n.maxDistance,l.radius)),!0===n.enableDamping?n.target.addScaledVector(c,n.dampingFactor):n.target.add(c),e.setFromSpherical(l),e.applyQuaternion(p),t.copy(n.target).add(e),n.object.lookAt(n.target),!0===n.enableDamping?(u.theta*=1-n.dampingFactor,u.phi*=1-n.dampingFactor,c.multiplyScalar(1-n.dampingFactor)):(u.set(0,0,0),c.set(0,0,0)),h=1,!!(d||m.distanceToSquared(n.object.position)>s||8*(1-f.dot(n.object.quaternion))>s)&&(n.dispatchEvent(M),m.copy(n.object.position),f.copy(n.object.quaternion),d=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",$),n.domElement.removeEventListener("pointerdown",Z),n.domElement.removeEventListener("pointercancel",W),n.domElement.removeEventListener("wheel",J),n.domElement.removeEventListener("pointermove",q),n.domElement.removeEventListener("pointerup",K),null!==n._domElementKeyEvents&&n._domElementKeyEvents.removeEventListener("keydown",Q)};const n=this,o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=o.NONE;const s=1e-6,l=new H,u=new H;let h=1;const c=new r;let d=!1;const p=new a,m=new a,f=new a,g=new a,b=new a,x=new a,y=new a,E=new a,v=new a,T=[],w={};function A(){return Math.pow(.95,n.zoomSpeed)}function R(t){u.theta-=t}function B(t){u.phi-=t}const _=function(){const t=new r;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),c.add(t)}}(),C=function(){const t=new r;return function(e,o){!0===n.screenSpacePanning?t.setFromMatrixColumn(o,1):(t.setFromMatrixColumn(o,0),t.crossVectors(n.object.up,t)),t.multiplyScalar(e),c.add(t)}}(),k=function(){const t=new r;return function(e,o){const i=n.domElement;if(n.object.isPerspectiveCamera){const r=n.object.position;t.copy(r).sub(n.target);let s=t.length();s*=Math.tan(n.object.fov/2*Math.PI/180),_(2*e*s/i.clientHeight,n.object.matrix),C(2*o*s/i.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(_(e*(n.object.right-n.object.left)/n.object.zoom/i.clientWidth,n.object.matrix),C(o*(n.object.top-n.object.bottom)/n.object.zoom/i.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function F(t){n.object.isPerspectiveCamera?h/=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*t)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function j(t){n.object.isPerspectiveCamera?h*=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/t)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function z(t){p.set(t.clientX,t.clientY)}function Y(t){g.set(t.clientX,t.clientY)}function I(){if(1===T.length)p.set(T[0].pageX,T[0].pageY);else{const t=.5*(T[0].pageX+T[1].pageX),e=.5*(T[0].pageY+T[1].pageY);p.set(t,e)}}function D(){if(1===T.length)g.set(T[0].pageX,T[0].pageY);else{const t=.5*(T[0].pageX+T[1].pageX),e=.5*(T[0].pageY+T[1].pageY);g.set(t,e)}}function G(){const t=T[0].pageX-T[1].pageX,e=T[0].pageY-T[1].pageY,n=Math.sqrt(t*t+e*e);y.set(0,n)}function V(t){if(1==T.length)m.set(t.pageX,t.pageY);else{const e=nt(t),n=.5*(t.pageX+e.x),o=.5*(t.pageY+e.y);m.set(n,o)}f.subVectors(m,p).multiplyScalar(n.rotateSpeed);const e=n.domElement;R(2*Math.PI*f.x/e.clientHeight),B(2*Math.PI*f.y/e.clientHeight),p.copy(m)}function X(t){if(1===T.length)b.set(t.pageX,t.pageY);else{const e=nt(t),n=.5*(t.pageX+e.x),o=.5*(t.pageY+e.y);b.set(n,o)}x.subVectors(b,g).multiplyScalar(n.panSpeed),k(x.x,x.y),g.copy(b)}function U(t){const e=nt(t),o=t.pageX-e.x,i=t.pageY-e.y,r=Math.sqrt(o*o+i*i);E.set(0,r),v.set(0,Math.pow(E.y/y.y,n.zoomSpeed)),F(v.y),y.copy(E)}function Z(t){!1!==n.enabled&&(0===T.length&&(n.domElement.setPointerCapture(t.pointerId),n.domElement.addEventListener("pointermove",q),n.domElement.addEventListener("pointerup",K)),function(t){T.push(t)}(t),"touch"===t.pointerType?function(t){switch(et(t),T.length){case 1:switch(n.touches.ONE){case N.ROTATE:if(!1===n.enableRotate)return;I(),i=o.TOUCH_ROTATE;break;case N.PAN:if(!1===n.enablePan)return;D(),i=o.TOUCH_PAN;break;default:i=o.NONE}break;case 2:switch(n.touches.TWO){case N.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&G(),n.enablePan&&D(),i=o.TOUCH_DOLLY_PAN;break;case N.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&G(),n.enableRotate&&I(),i=o.TOUCH_DOLLY_ROTATE;break;default:i=o.NONE}break;default:i=o.NONE}i!==o.NONE&&n.dispatchEvent(L)}(t):function(t){let e;switch(t.button){case 0:e=n.mouseButtons.LEFT;break;case 1:e=n.mouseButtons.MIDDLE;break;case 2:e=n.mouseButtons.RIGHT;break;default:e=-1}switch(e){case P.DOLLY:if(!1===n.enableZoom)return;!function(t){y.set(t.clientX,t.clientY)}(t),i=o.DOLLY;break;case P.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enablePan)return;Y(t),i=o.PAN}else{if(!1===n.enableRotate)return;z(t),i=o.ROTATE}break;case P.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enableRotate)return;z(t),i=o.ROTATE}else{if(!1===n.enablePan)return;Y(t),i=o.PAN}break;default:i=o.NONE}i!==o.NONE&&n.dispatchEvent(L)}(t))}function q(t){!1!==n.enabled&&("touch"===t.pointerType?function(t){switch(et(t),i){case o.TOUCH_ROTATE:if(!1===n.enableRotate)return;V(t),n.update();break;case o.TOUCH_PAN:if(!1===n.enablePan)return;X(t),n.update();break;case o.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&U(t),n.enablePan&&X(t)}(t),n.update();break;case o.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&U(t),n.enableRotate&&V(t)}(t),n.update();break;default:i=o.NONE}}(t):function(t){if(!1!==n.enabled)switch(i){case o.ROTATE:if(!1===n.enableRotate)return;!function(t){m.set(t.clientX,t.clientY),f.subVectors(m,p).multiplyScalar(n.rotateSpeed);const e=n.domElement;R(2*Math.PI*f.x/e.clientHeight),B(2*Math.PI*f.y/e.clientHeight),p.copy(m),n.update()}(t);break;case o.DOLLY:if(!1===n.enableZoom)return;!function(t){E.set(t.clientX,t.clientY),v.subVectors(E,y),v.y>0?F(A()):v.y<0&&j(A()),y.copy(E),n.update()}(t);break;case o.PAN:if(!1===n.enablePan)return;!function(t){b.set(t.clientX,t.clientY),x.subVectors(b,g).multiplyScalar(n.panSpeed),k(x.x,x.y),g.copy(b),n.update()}(t)}}(t))}function K(t){!1!==n.enabled&&(t.pointerType,n.dispatchEvent(S),i=o.NONE,tt(t),0===T.length&&(n.domElement.releasePointerCapture(t.pointerId),n.domElement.removeEventListener("pointermove",q),n.domElement.removeEventListener("pointerup",K)))}function W(t){tt(t)}function J(t){!1===n.enabled||!1===n.enableZoom||i!==o.NONE&&i!==o.ROTATE||(t.preventDefault(),n.dispatchEvent(L),function(t){t.deltaY<0?j(A()):t.deltaY>0&&F(A()),n.update()}(t),n.dispatchEvent(S))}function Q(t){!1!==n.enabled&&!1!==n.enablePan&&function(t){let e=!1;switch(t.code){case n.keys.UP:k(0,n.keyPanSpeed),e=!0;break;case n.keys.BOTTOM:k(0,-n.keyPanSpeed),e=!0;break;case n.keys.LEFT:k(n.keyPanSpeed,0),e=!0;break;case n.keys.RIGHT:k(-n.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),n.update())}(t)}function $(t){!1!==n.enabled&&t.preventDefault()}function tt(t){delete w[t.pointerId];for(let e=0;e<T.length;e++)if(T[e].pointerId==t.pointerId)return void T.splice(e,1)}function et(t){let e=w[t.pointerId];void 0===e&&(e=new a,w[t.pointerId]=e),e.set(t.pageX,t.pageY)}function nt(t){const e=t.pointerId===T[0].pointerId?T[1]:T[0];return w[e.pointerId]}n.domElement.addEventListener("contextmenu",$),n.domElement.addEventListener("pointerdown",Z),n.domElement.addEventListener("pointercancel",W),n.domElement.addEventListener("wheel",J,{passive:!1}),this.update()}}}get THREE(){return void 0===_THREE&&console.error("three: invalid _THREE = "+_THREE+". Call three.THREE = THREE first."),_THREE}set dat(t){_dat?Object.is(t,_dat)||console.error("three: duplicate dat. Please use one instance of the dat library."):_dat=t}get dat(){return _dat}}window.__myThree__=window.__myThree__||{},window.__myThree__.three?three=window.__myThree__.three:((three=new Three).isThree=function(){return _THREE},window.__myThree__.three=three);var three$1=three;const common={getLanguageCode:getLanguageCode,three:three$1};export{common as default};