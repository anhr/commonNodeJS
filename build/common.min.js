!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Common={})}(this,function(t){"use strict";var e,n,o,i;window.__myThree__=window.__myThree__||{},window.__myThree__.three?i=window.__myThree__.three:((i=new class{constructor(){}set THREE(t){if(e)return void(Object.is(t,e)||console.error("three: duplicate THREE. Please use one instance of the THREE library."));e=t,o=this;const n=t.Float32BufferAttribute,r=t.Line3,s=t.Plane,a=t.Triangle,l=t.Vector3;function u(){const t=0,e=1,n=new l,o=new r,i=new s,u=new l,c=new a;this.ConvexHull=class{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new m,this.unassigned=new m,this.vertices=[]}setFromPoints(t){!0!==Array.isArray(t)&&console.error("THREE.ConvexHull: Points parameter is not an array."),t.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new p(t[e]));return this.compute(),this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(t){const n=t.geometry;if(void 0!==n){if(n.isGeometry)return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");if(n.isBufferGeometry){const o=n.attributes.position;if(void 0!==o)for(let n=0,i=o.count;n<i;n++){const i=new l;i.fromBufferAttribute(o,n).applyMatrix4(t.matrixWorld),e.push(i)}}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let n=0,o=e.length;n<o;n++)if(e[n].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const n=this.faces;let o=-1/0,i=1/0;for(let e=0,r=n.length;e<r;e++){const r=n[e],s=r.distanceToPoint(t.origin),a=r.normal.dot(t.direction);if(s>0&&a>=0)return null;const l=0!==a?-s/a:0;if(!(l<=0)&&(a>0?i=Math.min(l,i):o=Math.max(l,o),o>i))return null}return o!==-1/0?t.at(o,e):t.at(i,e),e}intersectsRay(t){return null!==this.intersectRay(t,n)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let n=t.outside;for(;null!==n.next&&n.next.face===t;)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(void 0!==n)if(void 0===e)this.unassigned.appendChain(n);else{let t=n;do{const n=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=n}while(null!==t)}return this}resolveUnassignedPoints(e){if(!1===this.unassigned.isEmpty()){let n=this.unassigned.first();do{const o=n.next;let i=this.tolerance,r=null;for(let o=0;o<e.length;o++){const s=e[o];if(s.mark===t){const t=s.distanceToPoint(n.point);if(t>i&&(i=t,r=s),i>1e3*this.tolerance)break}}null!==r&&this.addVertexToFace(n,r),n=o}while(null!==n)}return this}computeExtremes(){const t=new l,e=new l,n=[],o=[];for(let t=0;t<3;t++)n[t]=o[t]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let i=0,r=this.vertices.length;i<r;i++){const r=this.vertices[i],s=r.point;for(let e=0;e<3;e++)s.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,s.getComponent(e)),n[e]=r);for(let t=0;t<3;t++)s.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,s.getComponent(t)),o[t]=r)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:n,max:o}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),n=e.min,r=e.max;let s=0,a=0;for(let t=0;t<3;t++){const e=r[t].point.getComponent(t)-n[t].point.getComponent(t);e>s&&(s=e,a=t)}const l=n[a],c=r[a];let d,p;s=0,o.set(l.point,c.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==l&&n!==c){o.closestPointToPoint(n.point,!0,u);const t=u.distanceToSquared(n.point);t>s&&(s=t,d=n)}}s=-1,i.setFromCoplanarPoints(l.point,c.point,d.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==l&&n!==c&&n!==d){const t=Math.abs(i.distanceToPoint(n.point));t>s&&(s=t,p=n)}}const m=[];if(i.distanceToPoint(p.point)<0){m.push(h.create(l,c,d),h.create(p,c,l),h.create(p,d,c),h.create(p,l,d));for(let t=0;t<3;t++){const e=(t+1)%3;m[t+1].getEdge(2).setTwin(m[0].getEdge(e)),m[t+1].getEdge(1).setTwin(m[e+1].getEdge(0))}}else{m.push(h.create(l,d,c),h.create(p,l,c),h.create(p,c,d),h.create(p,d,l));for(let t=0;t<3;t++){const e=(t+1)%3;m[t+1].getEdge(2).setTwin(m[0].getEdge((3-t)%3)),m[t+1].getEdge(0).setTwin(m[e+1].getEdge(1))}}for(let t=0;t<4;t++)this.faces.push(m[t]);for(let e=0,n=t.length;e<n;e++){const n=t[e];if(n!==l&&n!==c&&n!==d&&n!==p){s=this.tolerance;let t=null;for(let e=0;e<4;e++){const o=this.faces[e].distanceToPoint(n.point);o>s&&(s=o,t=this.faces[e])}null!==t&&this.addVertexToFace(n,t)}}return this}reindexFaces(){const e=[];for(let n=0;n<this.faces.length;n++){const o=this.faces[n];o.mark===t&&e.push(o)}return this.faces=e,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const n=this.assigned.first().face;let o=n.outside;do{const i=n.distanceToPoint(o.point);i>e&&(e=i,t=o),o=o.next}while(null!==o&&o.face===n);return t}}computeHorizon(n,o,i,r){let s;this.deleteFaceVertices(i),i.mark=e,s=null===o?o=i.getEdge(0):o.next;do{const e=s.twin,o=e.face;o.mark===t&&(o.distanceToPoint(n)>this.tolerance?this.computeHorizon(n,e,o,r):r.push(s)),s=s.next}while(s!==o);return this}addAdjoiningFace(t,e){const n=h.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,o=null;for(let i=0;i<e.length;i++){const r=e[i],s=this.addAdjoiningFace(t,r);null===n?n=s:s.next.setTwin(o),this.newFaces.push(s.face),o=s}return n.next.setTwin(o),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}};class h{constructor(){this.normal=new l,this.midpoint=new l,this.area=0,this.constant=0,this.outside=null,this.mark=t,this.edge=null}static create(t,e,n){const o=new h,i=new d(t,o),r=new d(e,o),s=new d(n,o);return i.next=s.prev=r,r.next=i.prev=s,s.next=r.prev=i,o.edge=i,o.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return c.set(t.point,e.point,n.point),c.getNormal(this.normal),c.getMidpoint(this.midpoint),this.area=c.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class d{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class p{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class m{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}}this.ConvexHull=(new u).ConvexHull;const c=i.THREE.Vector2,h=i.THREE.Box3,d=i.THREE.BufferAttribute,p=i.THREE.Uint16BufferAttribute,m=i.THREE.Uint32BufferAttribute,f=i.THREE.Sphere,g=i.THREE.Object3D,b=i.THREE.Matrix4,x=i.THREE.Matrix3,y=i.THREE.arrayMax,v=i.THREE.MathUtils;class E{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,o=n.length;e<o;e++)n[e].call(this,t);t.target=null}}}let w=0;const T=new b,A=new g,R=new l,B=new h,P=new h,O=new l;class N extends E{constructor(){super(),Object.defineProperty(this,"id",{value:w++}),this.uuid=v.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(y(t)>65535?m:p)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new x).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(t),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return T.makeRotationFromQuaternion(t),this.applyMatrix4(T),this}rotateX(t){return T.makeRotationX(t),this.applyMatrix4(T),this}rotateY(t){return T.makeRotationY(t),this.applyMatrix4(T),this}rotateZ(t){return T.makeRotationZ(t),this.applyMatrix4(T),this}translate(t,e,n){return T.makeTranslation(t,e,n),this.applyMatrix4(T),this}scale(t,e,n){return T.makeScale(t,e,n),this.applyMatrix4(T),this}lookAt(t){return A.lookAt(t),A.updateMatrix(),this.applyMatrix4(A.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(R).negate(),this.translate(R.x,R.y,R.z),this}setFromPoints(t){const e=[];for(let n=0,o=t.length;n<o;n++){const o=t[n];e.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new n(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new h);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new l(-1/0,-1/0,-1/0),new l(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];B.setFromBufferAttribute(n),this.morphTargetsRelative?(O.addVectors(this.boundingBox.min,B.min),this.boundingBox.expandByPoint(O),O.addVectors(this.boundingBox.max,B.max),this.boundingBox.expandByPoint(O)):(this.boundingBox.expandByPoint(B.min),this.boundingBox.expandByPoint(B.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new f);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new l,1/0);if(t){const n=this.boundingSphere.center;if(B.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];P.setFromBufferAttribute(n),this.morphTargetsRelative?(O.addVectors(B.min,P.min),B.expandByPoint(O),O.addVectors(B.max,P.max),B.expandByPoint(O)):(B.expandByPoint(P.min),B.expandByPoint(P.max))}B.getCenter(n);let o=0;for(let e=0,i=t.count;e<i;e++)O.fromBufferAttribute(t,e),o=Math.max(o,n.distanceToSquared(O));if(e)for(let i=0,r=e.length;i<r;i++){const r=e[i],s=this.morphTargetsRelative;for(let e=0,i=r.count;e<i;e++)O.fromBufferAttribute(r,e),s&&(R.fromBufferAttribute(t,e),O.add(R)),o=Math.max(o,n.distanceToSquared(O))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,o=e.position.array,i=e.normal.array,r=e.uv.array,s=o.length/3;void 0===e.tangent&&this.setAttribute("tangent",new d(new Float32Array(4*s),4));const a=e.tangent.array,u=[],h=[];for(let t=0;t<s;t++)u[t]=new l,h[t]=new l;const p=new l,m=new l,f=new l,g=new c,b=new c,x=new c,y=new l,v=new l;function E(t,e,n){p.fromArray(o,3*t),m.fromArray(o,3*e),f.fromArray(o,3*n),g.fromArray(r,2*t),b.fromArray(r,2*e),x.fromArray(r,2*n),m.sub(p),f.sub(p),b.sub(g),x.sub(g);const i=1/(b.x*x.y-x.x*b.y);isFinite(i)&&(y.copy(m).multiplyScalar(x.y).addScaledVector(f,-b.y).multiplyScalar(i),v.copy(f).multiplyScalar(b.x).addScaledVector(m,-x.x).multiplyScalar(i),u[t].add(y),u[e].add(y),u[n].add(y),h[t].add(v),h[e].add(v),h[n].add(v))}let w=this.groups;0===w.length&&(w=[{start:0,count:n.length}]);for(let t=0,e=w.length;t<e;++t){const e=w[t],o=e.start;for(let t=o,i=o+e.count;t<i;t+=3)E(n[t+0],n[t+1],n[t+2])}const T=new l,A=new l,R=new l,B=new l;function P(t){R.fromArray(i,3*t),B.copy(R);const e=u[t];T.copy(e),T.sub(R.multiplyScalar(R.dot(e))).normalize(),A.crossVectors(B,e);const n=A.dot(h[t])<0?-1:1;a[4*t]=T.x,a[4*t+1]=T.y,a[4*t+2]=T.z,a[4*t+3]=n}for(let t=0,e=w.length;t<e;++t){const e=w[t],o=e.start;for(let t=o,i=o+e.count;t<i;t+=3)P(n[t+0]),P(n[t+1]),P(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new d(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const o=new l,i=new l,r=new l,s=new l,a=new l,u=new l,c=new l,h=new l;if(t)for(let l=0,d=t.count;l<d;l+=3){const d=t.getX(l+0),p=t.getX(l+1),m=t.getX(l+2);o.fromBufferAttribute(e,d),i.fromBufferAttribute(e,p),r.fromBufferAttribute(e,m),c.subVectors(r,i),h.subVectors(o,i),c.cross(h),s.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),u.fromBufferAttribute(n,m),s.add(c),a.add(c),u.add(c),n.setXYZ(d,s.x,s.y,s.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(m,u.x,u.y,u.z)}else for(let t=0,s=e.count;t<s;t+=3)o.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),r.fromBufferAttribute(e,t+2),c.subVectors(r,i),h.subVectors(o,i),c.cross(h),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const o in n){if(void 0===t.attributes[o])continue;const i=n[o].array,r=t.attributes[o],s=r.array,a=r.itemSize*e,l=Math.min(s.length,i.length-a);for(let t=0,e=a;t<l;t++,e++)i[e]=s[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)O.fromBufferAttribute(t,e),O.normalize(),t.setXYZ(e,O.x,O.y,O.z)}toNonIndexed(){function t(t,e){const n=t.array,o=t.itemSize,i=t.normalized,r=new n.constructor(e.length*o);let s=0,a=0;for(let i=0,l=e.length;i<l;i++){s=t.isInterleavedBufferAttribute?e[i]*t.data.stride+t.offset:e[i]*o;for(let t=0;t<o;t++)r[a++]=n[s++]}return new d(r,o,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new N,n=this.index.array,o=this.attributes;for(const i in o){const r=t(o[i],n);e.setAttribute(i,r)}const i=this.morphAttributes;for(const o in i){const r=[],s=i[o];for(let e=0,o=s.length;e<o;e++){const o=t(s[e],n);r.push(o)}e.morphAttributes[o]=r}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let t=0,n=r.length;t<n;t++){const n=r[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const o=n[e];t.data.attributes[e]=o.toJSON(t.data)}const o={};let i=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],r=[];for(let e=0,o=n.length;e<o;e++){const o=n[e];r.push(o.toJSON(t.data))}r.length>0&&(o[e]=r,i=!0)}i&&(t.data.morphAttributes=o,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const s=this.boundingSphere;return null!==s&&(t.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const o=t.attributes;for(const t in o){const n=o[t];this.setAttribute(t,n.clone(e))}const i=t.morphAttributes;for(const t in i){const n=[],o=i[t];for(let t=0,i=o.length;t<i;t++)n.push(o[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let t=0,e=r.length;t<e;t++){const e=r[t];this.addGroup(e.start,e.count,e.materialIndex)}const s=t.boundingBox;null!==s&&(this.boundingBox=s.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}N.prototype.isBufferGeometry=!0,this.ConvexGeometry=class extends N{constructor(t){super();const e=[],i=[];void 0===u&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");const r=(new o.ConvexHull).setFromPoints(t).faces;for(let t=0;t<r.length;t++){const n=r[t];let o=n.edge;do{const t=o.head().point;e.push(t.x,t.y,t.z),i.push(n.normal.x,n.normal.y,n.normal.z),o=o.next}while(o!==n.edge)}this.setAttribute("position",new n(e,3)),this.setAttribute("normal",new n(i,3))}};const H=i.THREE.MOUSE,M=i.THREE.Quaternion,S=i.THREE.Spherical,L=i.THREE.TOUCH,C={type:"change"},k={type:"start"},F={type:"end"};this.OrbitControls=class extends E{constructor(t,e){super(),void 0===e&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new l,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:H.ROTATE,MIDDLE:H.DOLLY,RIGHT:H.PAN},this.touches={ONE:L.ROTATE,TWO:L.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return s.phi},this.getAzimuthalAngle=function(){return s.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",Q),this._domElementKeyEvents=t},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(C),n.update(),i=o.NONE},this.update=function(){const e=new l,c=(new M).setFromUnitVectors(t.up,new l(0,1,0)),p=c.clone().invert(),m=new l,f=new M,g=2*Math.PI;return function(){const t=n.object.position;e.copy(t).sub(n.target),e.applyQuaternion(c),s.setFromVector3(e),n.autoRotate&&i===o.NONE&&R(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(s.theta+=a.theta*n.dampingFactor,s.phi+=a.phi*n.dampingFactor):(s.theta+=a.theta,s.phi+=a.phi);let l=n.minAzimuthAngle,b=n.maxAzimuthAngle;return isFinite(l)&&isFinite(b)&&(l<-Math.PI?l+=g:l>Math.PI&&(l-=g),b<-Math.PI?b+=g:b>Math.PI&&(b-=g),s.theta=l<=b?Math.max(l,Math.min(b,s.theta)):s.theta>(l+b)/2?Math.max(l,s.theta):Math.min(b,s.theta)),s.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,s.phi)),s.makeSafe(),s.radius*=u,s.radius=Math.max(n.minDistance,Math.min(n.maxDistance,s.radius)),!0===n.enableDamping?n.target.addScaledVector(h,n.dampingFactor):n.target.add(h),e.setFromSpherical(s),e.applyQuaternion(p),t.copy(n.target).add(e),n.object.lookAt(n.target),!0===n.enableDamping?(a.theta*=1-n.dampingFactor,a.phi*=1-n.dampingFactor,h.multiplyScalar(1-n.dampingFactor)):(a.set(0,0,0),h.set(0,0,0)),u=1,!!(d||m.distanceToSquared(n.object.position)>r||8*(1-f.dot(n.object.quaternion))>r)&&(n.dispatchEvent(C),m.copy(n.object.position),f.copy(n.object.quaternion),d=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",$),n.domElement.removeEventListener("pointerdown",Z),n.domElement.removeEventListener("pointercancel",W),n.domElement.removeEventListener("wheel",J),n.domElement.removeEventListener("pointermove",q),n.domElement.removeEventListener("pointerup",K),null!==n._domElementKeyEvents&&n._domElementKeyEvents.removeEventListener("keydown",Q)};const n=this,o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=o.NONE;const r=1e-6,s=new S,a=new S;let u=1;const h=new l;let d=!1;const p=new c,m=new c,f=new c,g=new c,b=new c,x=new c,y=new c,v=new c,E=new c,w=[],T={};function A(){return Math.pow(.95,n.zoomSpeed)}function R(t){a.theta-=t}function B(t){a.phi-=t}const P=function(){const t=new l;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),h.add(t)}}(),O=function(){const t=new l;return function(e,o){!0===n.screenSpacePanning?t.setFromMatrixColumn(o,1):(t.setFromMatrixColumn(o,0),t.crossVectors(n.object.up,t)),t.multiplyScalar(e),h.add(t)}}(),N=function(){const t=new l;return function(e,o){const i=n.domElement;if(n.object.isPerspectiveCamera){const r=n.object.position;t.copy(r).sub(n.target);let s=t.length();s*=Math.tan(n.object.fov/2*Math.PI/180),P(2*e*s/i.clientHeight,n.object.matrix),O(2*o*s/i.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(P(e*(n.object.right-n.object.left)/n.object.zoom/i.clientWidth,n.object.matrix),O(o*(n.object.top-n.object.bottom)/n.object.zoom/i.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function _(t){n.object.isPerspectiveCamera?u/=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*t)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function j(t){n.object.isPerspectiveCamera?u*=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/t)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function z(t){p.set(t.clientX,t.clientY)}function Y(t){g.set(t.clientX,t.clientY)}function I(){if(1===w.length)p.set(w[0].pageX,w[0].pageY);else{const t=.5*(w[0].pageX+w[1].pageX),e=.5*(w[0].pageY+w[1].pageY);p.set(t,e)}}function D(){if(1===w.length)g.set(w[0].pageX,w[0].pageY);else{const t=.5*(w[0].pageX+w[1].pageX),e=.5*(w[0].pageY+w[1].pageY);g.set(t,e)}}function G(){const t=w[0].pageX-w[1].pageX,e=w[0].pageY-w[1].pageY,n=Math.sqrt(t*t+e*e);y.set(0,n)}function V(t){if(1==w.length)m.set(t.pageX,t.pageY);else{const e=nt(t),n=.5*(t.pageX+e.x),o=.5*(t.pageY+e.y);m.set(n,o)}f.subVectors(m,p).multiplyScalar(n.rotateSpeed);const e=n.domElement;R(2*Math.PI*f.x/e.clientHeight),B(2*Math.PI*f.y/e.clientHeight),p.copy(m)}function X(t){if(1===w.length)b.set(t.pageX,t.pageY);else{const e=nt(t),n=.5*(t.pageX+e.x),o=.5*(t.pageY+e.y);b.set(n,o)}x.subVectors(b,g).multiplyScalar(n.panSpeed),N(x.x,x.y),g.copy(b)}function U(t){const e=nt(t),o=t.pageX-e.x,i=t.pageY-e.y,r=Math.sqrt(o*o+i*i);v.set(0,r),E.set(0,Math.pow(v.y/y.y,n.zoomSpeed)),_(E.y),y.copy(v)}function Z(t){!1!==n.enabled&&(0===w.length&&(n.domElement.setPointerCapture(t.pointerId),n.domElement.addEventListener("pointermove",q),n.domElement.addEventListener("pointerup",K)),function(t){w.push(t)}(t),"touch"===t.pointerType?function(t){switch(et(t),w.length){case 1:switch(n.touches.ONE){case L.ROTATE:if(!1===n.enableRotate)return;I(),i=o.TOUCH_ROTATE;break;case L.PAN:if(!1===n.enablePan)return;D(),i=o.TOUCH_PAN;break;default:i=o.NONE}break;case 2:switch(n.touches.TWO){case L.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&G(),n.enablePan&&D(),i=o.TOUCH_DOLLY_PAN;break;case L.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&G(),n.enableRotate&&I(),i=o.TOUCH_DOLLY_ROTATE;break;default:i=o.NONE}break;default:i=o.NONE}i!==o.NONE&&n.dispatchEvent(k)}(t):function(t){let e;switch(t.button){case 0:e=n.mouseButtons.LEFT;break;case 1:e=n.mouseButtons.MIDDLE;break;case 2:e=n.mouseButtons.RIGHT;break;default:e=-1}switch(e){case H.DOLLY:if(!1===n.enableZoom)return;!function(t){y.set(t.clientX,t.clientY)}(t),i=o.DOLLY;break;case H.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enablePan)return;Y(t),i=o.PAN}else{if(!1===n.enableRotate)return;z(t),i=o.ROTATE}break;case H.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enableRotate)return;z(t),i=o.ROTATE}else{if(!1===n.enablePan)return;Y(t),i=o.PAN}break;default:i=o.NONE}i!==o.NONE&&n.dispatchEvent(k)}(t))}function q(t){!1!==n.enabled&&("touch"===t.pointerType?function(t){switch(et(t),i){case o.TOUCH_ROTATE:if(!1===n.enableRotate)return;V(t),n.update();break;case o.TOUCH_PAN:if(!1===n.enablePan)return;X(t),n.update();break;case o.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&U(t),n.enablePan&&X(t)}(t),n.update();break;case o.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&U(t),n.enableRotate&&V(t)}(t),n.update();break;default:i=o.NONE}}(t):function(t){if(!1!==n.enabled)switch(i){case o.ROTATE:if(!1===n.enableRotate)return;!function(t){m.set(t.clientX,t.clientY),f.subVectors(m,p).multiplyScalar(n.rotateSpeed);const e=n.domElement;R(2*Math.PI*f.x/e.clientHeight),B(2*Math.PI*f.y/e.clientHeight),p.copy(m),n.update()}(t);break;case o.DOLLY:if(!1===n.enableZoom)return;!function(t){v.set(t.clientX,t.clientY),E.subVectors(v,y),E.y>0?_(A()):E.y<0&&j(A()),y.copy(v),n.update()}(t);break;case o.PAN:if(!1===n.enablePan)return;!function(t){b.set(t.clientX,t.clientY),x.subVectors(b,g).multiplyScalar(n.panSpeed),N(x.x,x.y),g.copy(b),n.update()}(t)}}(t))}function K(t){!1!==n.enabled&&(t.pointerType,n.dispatchEvent(F),i=o.NONE,tt(t),0===w.length&&(n.domElement.releasePointerCapture(t.pointerId),n.domElement.removeEventListener("pointermove",q),n.domElement.removeEventListener("pointerup",K)))}function W(t){tt(t)}function J(t){!1===n.enabled||!1===n.enableZoom||i!==o.NONE&&i!==o.ROTATE||(t.preventDefault(),n.dispatchEvent(k),function(t){t.deltaY<0?j(A()):t.deltaY>0&&_(A()),n.update()}(t),n.dispatchEvent(F))}function Q(t){!1!==n.enabled&&!1!==n.enablePan&&function(t){let e=!1;switch(t.code){case n.keys.UP:N(0,n.keyPanSpeed),e=!0;break;case n.keys.BOTTOM:N(0,-n.keyPanSpeed),e=!0;break;case n.keys.LEFT:N(n.keyPanSpeed,0),e=!0;break;case n.keys.RIGHT:N(-n.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),n.update())}(t)}function $(t){!1!==n.enabled&&t.preventDefault()}function tt(t){delete T[t.pointerId];for(let e=0;e<w.length;e++)if(w[e].pointerId==t.pointerId)return void w.splice(e,1)}function et(t){let e=T[t.pointerId];void 0===e&&(e=new c,T[t.pointerId]=e),e.set(t.pageX,t.pageY)}function nt(t){const e=t.pointerId===w[0].pointerId?w[1]:w[0];return T[e.pointerId]}n.domElement.addEventListener("contextmenu",$),n.domElement.addEventListener("pointerdown",Z),n.domElement.addEventListener("pointercancel",W),n.domElement.addEventListener("wheel",J,{passive:!1}),this.update()}}}get THREE(){return void 0===e&&console.error("three: invalid _THREE = "+e+". Call three.THREE = THREE first."),e}set dat(t){n?Object.is(t,n)||console.error("three: duplicate dat. Please use one instance of the dat library."):n=t}get dat(){return n}}).isThree=function(){return e},window.__myThree__.three=i);const r={getLanguageCode:function(){return(navigator?void 0!==navigator.languages&&"unknown"!=typeof navigator.languages&&navigator.languages.length>0?navigator.languages[0]:navigator.language?navigator.language:navigator.browserLanguage?navigator.browserLanguage:navigator.systemLanguage?navigator.systemLanguage:navigator.userLanguage?navigator.userLanguage:(console.error("getLocale() failed!"),""):(console.error("getLocale() failed! !navigator"),"")).toLowerCase().match(/([a-z]+)(?:-([a-z]+))?/)[1]},three:i};t.default=r,Object.defineProperty(t,"__esModule",{value:!0})});