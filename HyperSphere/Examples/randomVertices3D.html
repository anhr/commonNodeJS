<!DOCTYPE html>

<html>
<head>
    <title>3D Random Vertices</title>

    <!--for mobile devices-->
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <!--<script src="./three.js/dev/build/three.js"></script>-->
    <!--<script src="./three.js/dev/build/three.min.js"></script>-->
    <!--<script src="https://raw.githack.com/anhr/three.js/dev/build/three.js"></script>-->
    <!--<script src="https://raw.githack.com/anhr/three.js/dev/build/three.min.js"></script>-->
    <!--<script src="https://threejs.org/build/three.js"></script>-->
    <!--<script src="https://threejs.org/build/three.min.js"></script>-->
</head>
<body>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
		- <a href="https://github.com/anhr/commonNodeJS/tree/master/HyperSphere" target="_blank" rel="noopener">3D Random Vertices</a>.
		By <a href="https://github.com/anhr" target="_blank" rel="noopener">anhr</a>
	</div>

	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';

		import MyThree from '../../myThree/myThree.js';
		MyThree.three.THREE = THREE;

		import HyperSphere3D from '../hyperSphere3D.js';
		import anglesRange from '../anglesRange.js'
		
		new MyThree((scene, options) => {

			const pi = Math.PI;

			//params
			
			const params = {

/*Use oppositeVertice instead
				//центр окружности, пересекающей сферу или вершина гиперсферы, вокруг которой будет облако вероятностей
				center: [
					//0,//Altitude
					pi/4 + pi/10,//Altitude
			
					//lat
					//0,
					-pi/4,
					//pi/2,//если arc = pi, то противоложные точки дуги будут находиться на разных полюсах. Тогда придется делать небольшую поравку в широте точки, вызывая функцию inaccurateLatitude
						//Иначе случайное распределение вершин получается не случайным непонятно по какой причине

					//lng
					//0,
					-pi/4,
				],
*/				
				oppositeVertice: [
					//0,//Altitude
					pi/4 + pi/10,//Altitude
			
					//lat
					//0,
					-pi/4,
					//pi/2,//если arc = pi, то противоложные точки дуги будут находиться на разных полюсах. Тогда придется делать небольшую поравку в широте точки, вызывая функцию inaccurateLatitude
						//Иначе случайное распределение вершин получается не случайным непонятно по какой причине

					//lng
					//0,
					-pi/4,
				],
				vertice: [
					//0,//Altitude
					pi/4,//Altitude
			
					//lat
					//0,
					-pi/4,
					//pi/2,//если arc = pi, то противоложные точки дуги будут находиться на разных полюсах. Тогда придется делать небольшую поравку в широте точки, вызывая функцию inaccurateLatitude
						//Иначе случайное распределение вершин получается не случайным непонятно по какой причине

					//lng
					//0,
					-pi/4,
				],
 				//oppositeVertice: [0.4014257279586958, -0.5235987755982988, 2.0943951023931953],
 				//oppositeVertice: [0.401, -0.524, 2.094],
				
 				//oppositeVertice: [0.785, -0.524, 2.094],
				//vertice:         [0.785, -0.524, 0],
				
 				oppositeVertice: [0.3, -0.5, 2],
				vertice:         [0.3, -0.5, 0],
				
				//Противоположные точки за исключением высоты
 				//oppositeVertice: [0.3, -0.524, pi],
				//vertice:         [0.3,  0.524, 0],

				//Противоположные точки за исключением высоты
 				//oppositeVertice: [0.3, 0.1, pi],
				//vertice:         [0.3, -0.1, 0],
				
				//vertice:         [0.4014257279586958, -0.5235987755982988, 2.0943951023931953],
				//vertice: [0.7853981633974483, -0.5235987755982988, 0],

/*Use vertice and oppositeVertice instead
				//arc Длинна дуги, соединяющей две вершины гиперсферы
				arc: //pi,//Вершины дуги расположены на противоположных концах гиперсферы. Длинна дуги максимальная. Окружности вокруг вершины расположены равномерно по всей гиперсфере.
						//если center.lat = pi / 2, то противоложные точки дуги будут находиться на разных полюсах. Тогда придется делать небольшую поравку в широте точки, вызывая функцию inaccurateLatitude
						//Иначе случайное распределение вершин получается не случайным непонятно по какой причине
					pi / 10,
					//1.571,
					//0,//Вершины гиперсферы совпадают. Длинна дуги равна нулю. Окружности вокруг вершины превращаются в точки, которые совпадают с вершиной.
					//0.5,//По умолчанию
					//1.5,//Для вычисления коэффициента k
*/					
				
				random: false,
				onePoint: false,//Have effect only if params.random = true
				onePointArray: false,//Have effect only if params.onePoint = true
				HyperSphere: HyperSphere3D,

			}
			HyperSphere3D.RandomVertices.params(params);

			///////////////////////////////////////////////params
			
			const randomVerticesSettings = {

				//np: 360,
				//R: 0.5,
				debug: {
					
					//log: true,

					//рисуем окружности только вокруг противоположной вершины. Окружности внутри и снаружи противоположной вершины пропускаем. Это нужн чтобы можно было лучше разглядеть окружности.
					oneCircles: {

						altitudeShift: 0,//смещение высоты точек окружности с максимальным диаметром. Смешение высоты точек окружности с меньшим диаметром постепенно уменьшается до нуля для окружности, нажходящейся на противоположной вершине.
						dy: 0,//степень выгнутости пераболы по которой смещение высоты точек зависит от идентификатора окружности. При dy: 0 парабола вырождается в прямую
						
					},//true,
					
				
				},
				//debug: false,
				name: 'Random Arc'
			
			};
			params.randomVertices = new HyperSphere3D.RandomVertices(scene, options, randomVerticesSettings);
//			const params = randomVerticesSettings.params;
			
			//GUI

			const gui = options.dat.gui.addFolder('Hypersphere');

			//vertice
			const fVertice = gui.addFolder('Vertice');
			fVertice.add(params.vertice, 'altitude', anglesRange.altitude.min, anglesRange.altitude.max, 0.001);
			fVertice.add(params.vertice, 'latitude', anglesRange.latitude.min, anglesRange.latitude.max, 0.001);
			fVertice.add(params.vertice, 'longitude', anglesRange.longitude.min, anglesRange.longitude.max, 0.001);

			//oppositeVertice
			const fOppositeVertice = gui.addFolder('Opposite Vertice');
			fOppositeVertice.add(params.oppositeVertice, 'altitude', anglesRange.altitude.min, anglesRange.altitude.max, 0.001);
			fOppositeVertice.add(params.oppositeVertice, 'latitude', anglesRange.latitude.min, anglesRange.latitude.max, 0.001);
			fOppositeVertice.add(params.oppositeVertice, 'longitude', anglesRange.longitude.min, anglesRange.longitude.max, 0.001);

			params.onChangeRandom = (random) => { if (!random) cbParamsOnePoint.setValue(false); }
			const cbParamsRandom = gui.add(params, 'random');
			params.onChangeOnePoint = (onePoint) => {
				
				if (onePoint) cbParamsRandom.setValue(onePoint);
				else cbParamsOnePointArray.setValue(onePoint);
			
			}
			const cbParamsOnePoint = gui.add(params, 'onePoint');
			params.onChangeOnePointArray = (onePointArray) => { if (onePointArray) cbParamsOnePoint.setValue(true); }
			const cbParamsOnePointArray = gui.add(params, 'onePointArray');
			if (randomVerticesSettings.debug && randomVerticesSettings.debug.oneCircles && randomVerticesSettings.debug.oneCircles && (randomVerticesSettings.debug.oneCircles.altitudeShift != undefined)) {
				
				gui.add(randomVerticesSettings.debug.oneCircles, 'dy', -0.5, 0.5, 0.0001);
				gui.add(randomVerticesSettings.debug.oneCircles, 'altitudeShift', -0.5, 0.5, 0.001);

			}

			//////////////////////////////////////////GUI
			
			if (!params.random) {

				if (params.onePoint) {

					console.warn('Please, define params.onePoint = false');
					cbParamsOnePoint.setValue(false);
					
				}
				if (params.onePointArray) {

					console.warn('Please, define params.onePointArray = false');
					cbParamsOnePointArray.setValue(false);
					
				}
				params.randomVertices.determinedVertices(params);
				return;

			}
			if (!params.onePoint) {

//				console.error('Please define params.onePoint = true or params.random = false.');
				if (params.onePointArray) {

					console.warn('Please, define params.onePointArray = false');
					cbParamsOnePointArray.setValue(false);
					
				}
				params.randomVertices.onChangeRandom(params);
				return;

			}
			if (params.onePointArray) {
				
				params.randomVertices.createOnePointArray(params);
				return;

			}
			const randomVertice = params.randomVertices.randomVertice(params);
			params.randomVertices.circlesSphere = params.randomVertices.getHyperSphere(options, {

					edges: false,
					randomArc: true,
					projectParams: { scene: scene, },
					r: randomVerticesSettings.R,//0.5,
					debug: randomVerticesSettings.debug ? {

						probabilityDensity: false,
						middleVertice: false,
						log: false,

					} : false,
					//debug: false,
					settings: {

						object: {

							name: 'Random vertice',
							//color: 'white',
							geometry: {

								angles: randomVertice,
								//indices: { edges: edges },

							},

						},
						overriddenProperties: {
							setDrawRange: (start, count) => {

								if (params.randomVertices.circlesSphere) params.randomVertices.circlesSphere.bufferGeometry.setDrawRange(start, count);

							}

						},

					},


				});

		}, {

			scales: {

				//x: x, y: y, z: z,
				//posAxesIntersection: new THREE.Vector3( 0, 0, 0 ),
				text: { precision: 1, rect: { displayRect: false, }, }

			},
			canvas: {

				noButtonFullScreen: true,

			},
			player: false,
			playerOptions: {
				
				//max: Infinity,
				//interval: 100,
				
			}

		} );

	</script>
</body>
</html>