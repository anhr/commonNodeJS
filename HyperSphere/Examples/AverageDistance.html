<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>–î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –Ω–∞ —Å—Ñ–µ—Ä–µ</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
			font-family: Arial, Helvetica, sans-serif;
		}

		#info {
			position: absolute;
			top: 20px;
			left: 20px;
			background: rgba(0, 0, 0, 0.7);
			color: white;
			padding: 15px 25px;
			border-radius: 8px;
			pointer-events: none;
			z-index: 100;
			box-shadow: 0 4px 15px rgba(0,0,0,0.3);
			border-left: 5px solid #ffaa00;
		}

		#controls {
			position: absolute;
			bottom: 30px;
			left: 30px;
			background: rgba(0, 0, 0, 0.7);
			color: white;
			padding: 20px;
			border-radius: 8px;
			pointer-events: auto;
			z-index: 100;
			backdrop-filter: blur(5px);
			border: 1px solid rgba(255,255,255,0.2);
		}

		button {
			padding: 10px 20px;
			margin: 5px;
			cursor: pointer;
			background: #ffaa00;
			border: none;
			border-radius: 4px;
			font-weight: bold;
			color: black;
			transition: all 0.3s;
		}

			button:hover {
				background: #ffc34d;
				transform: scale(1.05);
			}

			button:disabled {
				background: #666;
				cursor: not-allowed;
				transform: none;
			}

		#stats {
			position: absolute;
			top: 20px;
			right: 20px;
			background: rgba(0, 0, 0, 0.7);
			color: white;
			padding: 15px 25px;
			border-radius: 8px;
			pointer-events: none;
			border-right: 5px solid #00aaff;
		}

		h3 {
			margin-top: 0;
			color: #ffaa00;
		}
	</style>
</head>
<body>
	<div id="info">
		<h2>üåê –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –Ω–∞ —Å—Ñ–µ—Ä–µ</h2>
		<p>–¢–æ—á–∫–∏ —Å—Ç—Ä–µ–º—è—Ç—Å—è –∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º—É —É–¥–∞–ª–µ–Ω–∏—é –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞</p>
	</div>

	<div id="stats">
		<h3>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
		<p id="pointCount">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫: 20</p>
		<p id="iteration">–ò—Ç–µ—Ä–∞—Ü–∏—è: 0</p>
		<p id="avgDistance">–°—Ä. —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: 0</p>
	</div>

	<div id="controls">
		<h3>‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
		<button id="startBtn">‚ñ∂ –ó–∞–ø—É—Å—Ç–∏—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ</button>
		<button id="stopBtn" disabled>‚è∏ –ü–∞—É–∑–∞</button>
		<button id="resetBtn">üîÑ –°–±—Ä–æ—Å–∏—Ç—å</button>
		<button id="addPointsBtn">‚ûï –î–æ–±–∞–≤–∏—Ç—å 5 —Ç–æ—á–µ–∫</button>
		<button id="removePointsBtn">‚ûñ –£–¥–∞–ª–∏—Ç—å 5 —Ç–æ—á–µ–∫</button>
		<div style="margin-top: 15px;">
			<label>–°–∫–æ—Ä–æ—Å—Ç—å: </label>
			<input type="range" id="speedRange" min="0.1" max="2" step="0.1" value="1">
			<span id="speedValue">1.0</span>
		</div>
	</div>

	<!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ Three.js –∏ OrbitControls -->
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.128.0/build/three.module.js",
				"three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
			}
		}
	</script>

	<script type="module">
		/*
–ù–∞–ø–∏—Å–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –Ω–∞ —è–∑—ã–∫–µ javascript.
–ó–∞–¥–∞–Ω –º–∞—Å—Å–∏–≤ : const vertices = [].
–í —ç—Ç–æ—Ç –º–∞—Å—Å–∏–≤ –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ  —Ç–æ—á–µ–∫, —Å–ª—É—á–∞–π–Ω–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω—ã—Ö –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ —Å—Ñ–µ—Ä—ã –≤ –ø–æ–ª—è—Ä–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç. –ù–∞—á–∞–ª–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ü–µ–Ω—Ç—Ä–µ —Å—Ñ–µ—Ä—ã.
–ö–∞–∂–¥–∞—è —Ç–æ—á–∫–∞ –∏–º–µ–µ—Ç –≤–∏–¥: const angles = {
   latitude: latitude,//—à–∏—Ä–æ—Ç–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç -œÄ/2 –¥–æ œÄ/2
   longitude: longitude//–¥–æ–ª–≥–æ—Ç–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç -œÄ –¥–æ œÄ
}
–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –∑–∞–¥–∞–Ω–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º —Ñ—É–Ω–∫—Ü–∏–∏ verticesCount.
–†–∞–∑—Ä–∞–±–æ—Ç–∞—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å, –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –≤—Å–µ —Ç–æ—á–∫–∏ –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ –¥–≤–∏–∂—É—Ç—Å—è –≤ –ø–æ–ª–æ–∂–µ–Ω–∏–µ, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º —Ç–æ—á–∫–∏ –æ–∫–∞–∂—É—Ç—Å—è –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º —É–¥–∞–ª–µ–Ω–∏–∏ –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞.
–°–æ–∑–¥–∞—Ç—å –≤–µ–± —Å—Ç—Ä–∞–Ω–∏—Ü—É, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –¥–≤–∏–∂–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏.
–ù–∞ –≤–µ–± —Å—Ç—Ä–∞–Ω–∏—Ü–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É three.js –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è —Ç–æ—á–µ–∫.
		*/
		//https://chat.deepseek.com/a/chat/s/e808c17c-8258-4029-b70c-d65be630df03
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		// --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ---
		const vertices = []; // –ú–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫ –≤ –ø–æ–ª—è—Ä–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
		let spheres = []; // –ú–∞—Å—Å–∏–≤ —Å—Ñ–µ—Ä Three.js –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
		let scene, camera, renderer, controls;
		let animationId = null;
		let isAnimating = false;
		let iteration = 0;

		// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
		const RADIUS = 5; // –†–∞–¥–∏—É—Å —Å—Ñ–µ—Ä—ã
		let VERTICES_COUNT = 20; // –ù–∞—á–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫
		const REPULSION_STRENGTH = 0.05; // –°–∏–ª–∞ –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è
		const DAMPING = 0.95; // –î–µ–º–ø—Ñ–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è

		// –°–∫–æ—Ä–æ—Å—Ç–∏ —Ç–æ—á–µ–∫ (–¥–ª—è –∏–Ω–µ—Ä—Ü–∏–∏)
		let velocities = [];

		// --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js ---
		function initThree() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x050510);

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(12, 6, 15);
			camera.lookAt(0, 0, 0);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			renderer.setPixelRatio(window.devicePixelRatio);
			document.body.appendChild(renderer.domElement);

			controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;
			controls.autoRotate = true;
			controls.autoRotateSpeed = 0.5;
			controls.enableZoom = true;
			controls.enablePan = true;
			controls.enableShadow = true;

			// –û—Å–≤–µ—â–µ–Ω–∏–µ
			const ambientLight = new THREE.AmbientLight(0x404060);
			scene.add(ambientLight);

			const mainLight = new THREE.DirectionalLight(0xffeedd, 1);
			mainLight.position.set(10, 10, 20);
			mainLight.castShadow = true;
			mainLight.receiveShadow = true;
			mainLight.shadow.mapSize.width = 1024;
			mainLight.shadow.mapSize.height = 1024;
			scene.add(mainLight);

			const backLight = new THREE.PointLight(0x4466aa, 0.5);
			backLight.position.set(-10, 0, -10);
			scene.add(backLight);

			// –î–æ–±–∞–≤–ª—è–µ–º –∑–≤–µ–∑–¥—ã –¥–ª—è —Ñ–æ–Ω–∞
			const starsGeometry = new THREE.BufferGeometry();
			const starsCount = 2000;
			const starsPositions = new Float32Array(starsCount * 3);
			for (let i = 0; i < starsCount * 3; i += 3) {
				starsPositions[i] = (Math.random() - 0.5) * 200;
				starsPositions[i+1] = (Math.random() - 0.5) * 200;
				starsPositions[i+2] = (Math.random() - 0.5) * 200;
			}
			starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
			const starsMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.3, transparent: true});
			const stars = new THREE.Points(starsGeometry, starsMaterial);
			scene.add(stars);

			// –°–æ–∑–¥–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω—É—é —Å—Ñ–µ—Ä—É –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
			const sphereGeometry = new THREE.SphereGeometry(RADIUS, 64, 32);
			const sphereMaterial = new THREE.MeshPhongMaterial({
				color: 0x2266aa,
				transparent: true,
				opacity: 0.1,
				wireframe: true,
				emissive: 0x112233,
				side: THREE.DoubleSide
			});
			const wireframeSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
			wireframeSphere.receiveShadow = true;
			wireframeSphere.castShadow = true;
			scene.add(wireframeSphere);

			// –î–æ–±–∞–≤–ª—è–µ–º —Å–µ—Ç–∫—É –∏ –æ—Å–∏ –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
			const gridHelper = new THREE.GridHelper(30, 20, 0x88aaff, 0x446688);
			scene.add(gridHelper);

			const axesHelper = new THREE.AxesHelper(10);
			scene.add(axesHelper);
		}

		// --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ ---

		// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –ø–æ–ª—è—Ä–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ –¥–µ–∫–∞—Ä—Ç–æ–≤—ã
		function polarToCartesian(latitude, longitude) {
			return {
				x: RADIUS * Math.cos(latitude) * Math.cos(longitude),
				y: RADIUS * Math.sin(latitude),
				z: RADIUS * Math.cos(latitude) * Math.sin(longitude)
			};
		}

		// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–µ–∫–∞—Ä—Ç–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ –ø–æ–ª—è—Ä–Ω—ã–µ
		function cartesianToPolar(x, y, z) {
			const r = Math.sqrt(x*x + y*y + z*z);
			const latitude = Math.asin(y / r);
			const longitude = Math.atan2(z, x);
			return {
				latitude: latitude,
				longitude: longitude
			};
		}

		// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Ç–æ—á–∫–∏ –Ω–∞ —Å—Ñ–µ—Ä–µ
		function normalizeToSphere(x, y, z) {
			const r = Math.sqrt(x*x + y*y + z*z);
			return {
				x: (x / r) * RADIUS,
				y: (y / r) * RADIUS,
				z: (z / r) * RADIUS
			};
		}

		// --- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–π —Ç–æ—á–∫–∏ –Ω–∞ —Å—Ñ–µ—Ä–µ ---
		function generateRandomPoint() {
			// –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ —Å—Ñ–µ—Ä–µ
			const theta = 2 * Math.PI * Math.random(); // –¥–æ–ª–≥–æ—Ç–∞
			const phi = Math.acos(2 * Math.random() - 1); // —É–≥–æ–ª –æ—Ç –æ—Å–∏ Z
			const latitude = Math.asin(Math.cos(phi)); // –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —à–∏—Ä–æ—Ç—É
			const longitude = theta - Math.PI; // –¥–∏–∞–ø–∞–∑–æ–Ω –æ—Ç -œÄ –¥–æ œÄ

			return {
				latitude: latitude,
				longitude: longitude
			};
		}

		// --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–∞—Å—Å–∏–≤–∞ —Ç–æ—á–µ–∫ ---
		function initVertices(count) {
			vertices.length = 0;
			for (let i = 0; i < count; i++) {
				vertices.push(generateRandomPoint());
			}

			// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏
			velocities = new Array(count).fill(null).map(() => ({ x: 0, y: 0, z: 0 }));

			iteration = 0;
			document.getElementById('iteration').innerHTML = `–ò—Ç–µ—Ä–∞—Ü–∏—è: ${iteration}`;
		}

		// --- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç–æ—á–µ–∫ ---
		function updateVisualization() {
			// –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–æ—á–∫–∏
			spheres.forEach(sphere => scene.remove(sphere));
			spheres = [];

			// –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ —Ç–æ—á–∫–∏
			vertices.forEach((point, index) => {
				const { x, y, z } = polarToCartesian(point.latitude, point.longitude);

				// –°–æ–∑–¥–∞–µ–º —Å–≤–µ—Ç—è—â—É—é—Å—è —Å—Ñ–µ—Ä—É
				const geometry = new THREE.SphereGeometry(0.25, 32, 16);

				// –†–∞–∑–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–æ—á–µ–∫
				const hue = (index / vertices.length) * 0.8 + 0.2;
				const color = new THREE.Color().setHSL(hue, 0.9, 0.6);

				const material = new THREE.MeshStandardMaterial({
					color: color,
					emissive: color,
					emissiveIntensity: 0.3,
					roughness: 0.3,
					metalness: 0.1
				});

				const sphere = new THREE.Mesh(geometry, material);
				sphere.position.set(x, y, z);
				sphere.castShadow = true;
				sphere.receiveShadow = true;

				scene.add(sphere);
				spheres.push(sphere);

				// –î–æ–±–∞–≤–ª—è–µ–º –º–∞–ª–µ–Ω—å–∫—É—é —Ç–æ—á–∫—É-–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
				const pointGeometry = new THREE.SphereGeometry(0.08, 8, 8);
				const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
				const pointLight = new THREE.Mesh(pointGeometry, pointMaterial);
				pointLight.position.set(x, y, z);
				scene.add(pointLight);
				spheres.push(pointLight);
			});

			// –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
			document.getElementById('pointCount').innerHTML = `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫: ${vertices.length}`;
			updateAverageDistance();
		}

		// --- –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏ ---
		function updateAverageDistance() {
			if (vertices.length < 2) {
				document.getElementById('avgDistance').innerHTML = `–°—Ä. —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: 0`;
				return;
			}

			let totalDist = 0;
			let pairs = 0;

			for (let i = 0; i < vertices.length; i++) {
				const pos1 = polarToCartesian(vertices[i].latitude, vertices[i].longitude);
				for (let j = i + 1; j < vertices.length; j++) {
					const pos2 = polarToCartesian(vertices[j].latitude, vertices[j].longitude);
					const dx = pos1.x - pos2.x;
					const dy = pos1.y - pos2.y;
					const dz = pos1.z - pos2.z;
					totalDist += Math.sqrt(dx*dx + dy*dy + dz*dz);
					pairs++;
				}
			}

			const avgDist = pairs > 0 ? (totalDist / pairs).toFixed(3) : 0;
			document.getElementById('avgDistance').innerHTML = `–°—Ä. —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${avgDist}`;
		}

		// --- –ò—Ç–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –¥–≤–∏–∂–µ–Ω–∏—è —Ç–æ—á–µ–∫ ---
		function iterationStep() {
			if (!isAnimating) return;

			// –í—ã—á–∏—Å–ª—è–µ–º —Å–∏–ª—ã –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏
			const forces = new Array(vertices.length).fill(null).map(() => ({ x: 0, y: 0, z: 0 }));

			// –î–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã —Ç–æ—á–µ–∫
			for (let i = 0; i < vertices.length; i++) {
				const pos1 = polarToCartesian(vertices[i].latitude, vertices[i].longitude);

				for (let j = i + 1; j < vertices.length; j++) {
					const pos2 = polarToCartesian(vertices[j].latitude, vertices[j].longitude);

					// –í–µ–∫—Ç–æ—Ä –æ—Ç i –∫ j
					let dx = pos1.x - pos2.x;
					let dy = pos1.y - pos2.y;
					let dz = pos1.z - pos2.z;

					const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

					if (dist < 0.001) continue;

					// –°–∏–ª–∞ –æ–±—Ä–∞—Ç–Ω–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
					const forceMagnitude = REPULSION_STRENGTH / (dist * dist);

					// –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–µ–∫—Ç–æ—Ä
					dx /= dist;
					dy /= dist;
					dz /= dist;

					// –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–ª—É: –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ
					forces[i].x += dx * forceMagnitude;
					forces[i].y += dy * forceMagnitude;
					forces[i].z += dz * forceMagnitude;

					forces[j].x -= dx * forceMagnitude;
					forces[j].y -= dy * forceMagnitude;
					forces[j].z -= dz * forceMagnitude;
				}
			}

			// –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–ª—ã –∫ —Ç–æ—á–∫–∞–º
			for (let i = 0; i < vertices.length; i++) {
				const pos = polarToCartesian(vertices[i].latitude, vertices[i].longitude);

				// –û–±–Ω–æ–≤–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å —Å —É—á–µ—Ç–æ–º —Å–∏–ª—ã –∏ –¥–µ–º–ø—Ñ–∏—Ä–æ–≤–∞–Ω–∏—è
				velocities[i].x = velocities[i].x * DAMPING + forces[i].x;
				velocities[i].y = velocities[i].y * DAMPING + forces[i].y;
				velocities[i].z = velocities[i].z * DAMPING + forces[i].z;

				// –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
				let newX = pos.x + velocities[i].x;
				let newY = pos.y + velocities[i].y;
				let newZ = pos.z + velocities[i].z;

				// –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –Ω–∞ —Å—Ñ–µ—Ä—É
				const normalized = normalizeToSphere(newX, newY, newZ);

				// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ –ø–æ–ª—è—Ä–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
				const polar = cartesianToPolar(normalized.x, normalized.y, normalized.z);
				vertices[i].latitude = polar.latitude;
				vertices[i].longitude = polar.longitude;
			}

			// –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
			updateVisualization();

			iteration++;
			document.getElementById('iteration').innerHTML = `–ò—Ç–µ—Ä–∞—Ü–∏—è: ${iteration}`;
		}

		// --- –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª ---
		function animate() {
			requestAnimationFrame(animate);

			if (isAnimating) {
				// –í—ã–ø–æ–ª–Ω—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏—Ç–µ—Ä–∞—Ü–∏–π –∑–∞ –∫–∞–¥—Ä –¥–ª—è –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä–æ–π —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
				for (let i = 0; i < 3; i++) {
					iterationStep();
				}
			}

			controls.update();
			renderer.render(scene, camera);
		}

		// --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π UI ---
		function setupEventListeners() {
			document.getElementById('startBtn').addEventListener('click', () => {
				isAnimating = true;
				document.getElementById('startBtn').disabled = true;
				document.getElementById('stopBtn').disabled = false;
				controls.autoRotate = false;
			});

			document.getElementById('stopBtn').addEventListener('click', () => {
				isAnimating = false;
				document.getElementById('startBtn').disabled = false;
				document.getElementById('stopBtn').disabled = true;
				controls.autoRotate = true;
			});

			document.getElementById('resetBtn').addEventListener('click', () => {
				isAnimating = false;
				document.getElementById('startBtn').disabled = false;
				document.getElementById('stopBtn').disabled = true;
				controls.autoRotate = true;

				initVertices(vertices.length);
				velocities = new Array(vertices.length).fill(null).map(() => ({ x: 0, y: 0, z: 0 }));
				updateVisualization();
			});

			document.getElementById('addPointsBtn').addEventListener('click', () => {
				for (let i = 0; i < 5; i++) {
					vertices.push(generateRandomPoint());
				}
				velocities = velocities.concat(new Array(5).fill(null).map(() => ({ x: 0, y: 0, z: 0 })));
				updateVisualization();
			});

			document.getElementById('removePointsBtn').addEventListener('click', () => {
				if (vertices.length > 1) {
					const removeCount = Math.min(5, vertices.length - 1);
					vertices.splice(-removeCount);
					velocities.splice(-removeCount);
					updateVisualization();
				}
			});

			const speedRange = document.getElementById('speedRange');
			const speedValue = document.getElementById('speedValue');
			speedRange.addEventListener('input', () => {
				speedValue.textContent = speedRange.value;
				// –ò–∑–º–µ–Ω—è–µ–º —Å–∏–ª—É –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏
				REPULSION_STRENGTH = 0.05 * parseFloat(speedRange.value);
			});

			window.addEventListener('resize', onWindowResize, false);
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		// --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ---
		function init() {
			initThree();
			initVertices(VERTICES_COUNT);
			updateVisualization();
			setupEventListeners();
			animate();
		}

		// –ó–∞–ø—É—Å–∫
		init();
	</script>
</body>
</html>