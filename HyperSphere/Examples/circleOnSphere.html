<!DOCTYPE html>

<html>
<head>
    <title>Circle On Sphere</title>

    <!--for mobile devices-->
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <!--<script src="./three.js/dev/build/three.js"></script>-->
    <!--<script src="./three.js/dev/build/three.min.js"></script>-->
    <!--<script src="https://raw.githack.com/anhr/three.js/dev/build/three.js"></script>-->
    <!--<script src="https://raw.githack.com/anhr/three.js/dev/build/three.min.js"></script>-->
    <!--<script src="https://threejs.org/build/three.js"></script>-->
    <!--<script src="https://threejs.org/build/three.min.js"></script>-->
</head>
<body>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
		- <a href="https://github.com/anhr/commonNodeJS/tree/master/myThree" target="_blank" rel="noopener">Circle On Sphere</a>.
		By <a href="https://github.com/anhr" target="_blank" rel="noopener">anhr</a>
	</div>

	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';

		import MyThree from '../../myThree/myThree.js';
		MyThree.three.THREE = THREE;

		import Sphere from '../sphere.js';
		
		new MyThree( function ( scene, options ) {

			const pi = Math.PI,
				R = 1;//Hypersphere radius
			const np = 100;//36;//numPoints
				//l = 2 * pi / np;//длинна дуги между точками окружности для гиперсферы радиусом 1. Нужна для вычисления количества точек на окружности numPoints при равномерном распределении точек
			let circlesPointsCount;//for debug

			/**
			 * DeepSeek: Окружность на сфере (расчеты в радианах) — JavaScript
			 * Генерирует точки окружности на сфере (в радианах)
			 * @param {Array} center - Центр окружности [ 0 широта (рад), 1 долгота (рад) ]
			 * @param {object} [options] options.
			 * @param {number} [options.circleDistance=0.5] - Расстояние до окружности по дуге в радианах для гиперсферы радиусом 1
			 * @param {number} [options.numPoints=36] - Количество точек
			 * @param {number} [options.points=[]] - points array
			 * @returns {Array} Массив точек [ 0 широта (рад), 1 долгота (рад) ]
			 */
			const getCirclePointsRadians = (center, options) =>
			{

				options ||= {};
				if (options.circleDistance === undefined) options.circleDistance = 0.5;
				//const circleDistance = options.circleDistance;
				if (options.numPoints === undefined) options.numPoints = np;
				const numPoints = options.numPoints;
				const circleDistance = options.circleDistance / R; // Расстояние до окружности по дуге в радианах
			
				options.points ||= [];
				const points = options.points;
				
				for (let i = 0; i < numPoints; i++) {
					
					const angle = 2 * pi * (params.random ? Math.random() : i / numPoints); // Текущий угол в радианах
//					const angle = 2 * pi * ( i / numPoints); // Текущий угол в радианах
			
					// Формулы сферической тригонометрии
					const newLat = Math.asin(
						Math.sin(center.lat) * Math.cos(circleDistance) +
						Math.cos(center.lat) * Math.sin(circleDistance) * Math.cos(angle)
					);

					const newLng = center.lng + Math.atan2(
						Math.sin(angle) * Math.sin(circleDistance) * Math.cos(center.lat),
						Math.cos(circleDistance) - Math.sin(center.lat) * Math.sin(newLat)
					);

					const point = [ newLat, newLng ];
					if (options.pointId === undefined) points.push(point);
					else {

						if (points.length > options.pointId) {
							
							points[options.pointId] = point;
							options.pointId++;

						} else console.error('getCirclePointsRadians: Invalid options.pointId = ' + options.pointId);

					}
					circlesPointsCount++;//for debug
					
			    }
			
			    return points;
			}
			
			// Пример использования (вход и выход в радианах!)
//			const centerRad = { lat: 55.751244 * pi / 180, lng: 37.618423 * pi / 180 };
//			const centerRad = [ 0.9730427698827335, 0.6565653407579628 ];
//			const radiusMeters = 10000; // 10 км
//			const radiusMeters = 2;

			//Параметры, которые может менять пользователь
			const params = {

/*				
//				radius: 2,//see appropriate getter and setter
				r: pi / 2,//радиус текущей окружности, пересекающей сферу
*/				
				center: [ 0, 0 ],//центр окружности, пересекающей сферу или вершина гиперсферы, вокруг которой будет облако вероятностей
//				arc: 0.5,//see appropriate getter and setter

				//Длинна дуги, соединяющей две вершины гиперсферы
				a: //pi / 2,//Вершины гиперсферы расположены на противоположных концах гиперсферы. Длинна дуги максимальная. Окружности вокруг вершины расположены равномерно по всей гиперсферы.
					//0,//Вершины гиперсферы совпадают. Длинна дуги равна нулю. Окружности вокруг вершины превращаются в точки, которые совпадают с вершиной.
					0.5,//По умолчанию
					//1.5,//Для вычисления коэффициента k
				rnd: false,//random
				
			}
/*			
			Object.defineProperty(params, 'radius', {
				
				get: () => { return params.r; },
				set: (radius) => {

					params.r = radius;
					setCircles();
					return true;

				},
				
			});
*/			
			Object.defineProperty(params.center, 'lat', {
				
				get: () => { return params.center[0]; },
				set: (lat) => {

					params.center[0] = lat;
					setCircles();
					return true;

				},
				
			});
			Object.defineProperty(params.center, 'lng', {
				
				get: () => { return params.center[1]; },
				set: (lng) => {

					params.center[1] = lng;
					setCircles();
					return true;

				},
				
			});
			Object.defineProperty(params, 'arc', {
				
				get: () => { return params.a; },
				set: (arc) => {

					params.a = arc;
					setCircles();
					return true;

				},
				
			});
			Object.defineProperty(params, 'random', {
				
				get: () => { return params.rnd; },
				set: (random) => {

					params.rnd = random;
					setCirclesCount();
					setCircles();
					return true;

				},
				
			});
/*			
			const circlePointsRad = getCirclePointsRadians(params.center, params.radius);
			console.log(circlePointsRad); // Точки в радианах
*/			
			//GUI

			const gui = options.dat.gui;

			//arc
			gui.add(params, 'arc', 0, pi / 2, 0.001);

			//radius
//			gui.add(params, 'radius', 0, pi, 0.01);

			//center
			gui.add(params.center, 'lat', -pi / 2, pi / 2, 0.001);
			gui.add(params.center, 'lng', 0, 2 * pi, 0.001);

			//random
			gui.add(params, 'random');

			//////////////////////////////////////////GUI

			let circlesCount, d;
			const setCirclesCount = () => {
				
				circlesCount = (params.random ? np : 1 ) *
					np;//100;//если количество окружностей равно количеству точек на окружности, то точки будут равномерно располагаться на гиперсфере
				d = pi / (circlesCount - 1);
			
			}
			setCirclesCount();
			
			//Deepseek Вычислить a, d, c в уравнении y=a/(x+b)+c точностью до 8 знаков при условии:
			//Эта формула нужна для вычисления радиуса окружности radius

			//найти элементарную функцию для массива точек (0.1,0.0033995189605183543),(0.5,0.11673555173106497),(1,0.8759691969420544),(1.5,15.890654938344866)
			//10*(x^3)-10*(x^2)+x залазит в отрицательный y
			//(0.027*exp(3*x)+2.718*(x^4))*0.8
			const exp = Math.exp, pow = Math.pow,
				k = 15.890654938344866/16.163337545114086;//Умножить b на этот множитель что бы b = 15.890654938344866 при arc = 1.5
			let a, b, c;
			const setAbc = () => {
					
					b = (0.027*(exp(3*params.arc)
								-1//отнимаю единицу что бы график выходил из нуля
							   )+2.718*pow(params.arc,4))*k;//Так b зависит от длинны дуги, что бы плотность вероятностей распределялась от равномерной при arc = π/2 до сводящейся в точку при arc = 0
					a = -b*(pi+b); c = -a/b;

				};
//			setAbc();
			
			//есть три точки (0,0), (0,75,2.4), (π,π)
			//y≈ -1.17280918/(x+0.33708757)+3.47926296
			//const b = 0.33708757, a = -1.17280918, c = 3.47926296;
			
			//есть три точки (0,0), (0,π), (π,π)
			//для заданных точек решение не существует.

			//есть три точки (0,0), (0.1,π-0.1), (π,π)
			//const b = 0.01/(pi-0.2), a = -b*(pi+b), c = -a/b;
			//const a = -0.010691460521266596, b = 0.0033995189605183543, c = 3.1449921725503116;

			//есть три точки (0,0), (0.5,π-0.5), (π,π)
			//const b = 1/(4*pi-4), a = -b*(pi+b), c = -a/b;
			//const a = -0.3803627407690211, b = 0.11673555173106497, c = 3.258328205320858;
			
			//есть три точки (0,0), (1,π-1), (π,π)
			//const b = 1/(pi-2), a = -b*(pi+b), c = -a/b;
			//const a = -3.5192604278754165, b = 0.8759691969420544, c = 4.017561850531847;
			
			//есть три точки (0,0), (1.5,π-1.5), (π,π)
			//Почти равномерное распределение
			//const b = 2.25/(pi-3), a = -b*(pi+b), c = -a/b;
			//const a = -302.4348791845787, b = 15.890654938344866, c = 19.03224759193466;

			//есть три точки (0,0), (π/2,π/2), (π,π)
			//Равномерное распределение
			//Не существует функции вида y = a/(x+b)+c, которая проходила бы через все три заданные точки одновременно.
			
			//////////////////////////////////////////Deepseek

			let circlesSphere, circlesPointsOptions = {}, isCreateCirclesPoints;
			const circlesPoints = [],//точки всех окружностей
				setCircles = () => {
				
					setAbc();
					let circleDistance1Prev = 0;//Положение предыдущего кольца
					circlesPointsCount = 0;//for debug
					for (let circleId = 0; circleId < circlesCount; circleId++) {
		
						const x = circleId * d,

							//уголовое расстояние для окружности для гиперсферы радиусом 1
							circleDistance1 = b === 0 ? 0 ://дуга между вершинами гиперсферы равна нулю. Значит радиус окружности вокруг вершины тоже равен нулю
								a / (x + b) + c,
							
							circleDistance = circleDistance1 * R;
						if (circlesSphere) circlesPointsOptions.points = circlesSphere.angles;
						else circlesPointsOptions.points = circlesPoints;
						circlesPointsOptions.circleDistance = circleDistance;
//						circlesPointsOptions.numPoints = params.random ? 1 : parseInt(circleDistance1 / l);//np;
						circlesPointsOptions.numPoints = params.random ? 1 :
							parseInt(
								2 * pi * Math.sin(circleDistance1)//длинна окружности для гиперсферы радиусом 1
								/ (circleDistance1 - circleDistance1Prev)
/*								
								2 * pi * Math.sin(circleDistance1)//длинна окружности для гиперсферы радиусом 1
								/ l//длинна дуги между точками окружности для гиперсферы радиусом 1.
*/								
							);//np;
						circleDistance1Prev = circleDistance1;
						if (!isNaN(circlesPointsOptions.numPoints)) {//не рисовать окружность с бесконечным числом точек
							
							//console.log('circleId = ' + circleId + ', circleDistance1 = ' + circleDistance1 + ', numPoints = ' + circlesPointsOptions.numPoints)
							getCirclePointsRadians(params.center, circlesPointsOptions);

						}
						
					}
					console.log('circlesPointsCount = ' + circlesPointsCount);
					circlesPointsOptions.pointId = 0;
					if (!circlesSphere && !isCreateCirclesPoints)
						circlesSphere = new Sphere(options,
						{

							r: R,
							/*
							onAddControllers: (gui) => {
		
								//circleDistance
								gui.add( params, 'circleDistance', 0, pi, 0.01 );
					//			dat.controllerNameAndTitle( controllerPrecision, lang.precision, lang.precisionTitle );
					
								//center
								gui.add( params.center, 'lat', -pi / 2, pi / 2, 0.001 );
								gui.add( params.center, 'lng', -pi, pi, 0.001 );
								
							},
							*/
							/*
							edges: {
			
								project: false,//Doesn't project edges onto canvas
								//creationMethod: Sphere.edgesCreationMethod.Random,
								
							},
							*/
							edges: false,
							randomArc: true,
							projectParams:{
								
								scene: scene,
								
							},
							//r: 0.5,
							debug: {
			
								probabilityDensity: false,
								middleVertice: false,
								log: false,
								
							},
							//debug: false,
							settings: {
								
								object: {
				
									name: 'circles',// + circleDistance,
									//color: 'white',
									geometry: {
			
										angles: circlesPoints,
									
									}
			
								},
								overriddenProperties: { setDrawRange: (start, count) => {
									
										if (circlesSphere) circlesSphere.bufferGeometry.setDrawRange(start, count);
									
									}
													  
								},
							
							},
							
							
						});
					if (circlesSphere) circlesSphere.setVerticesRange(0, circlesPointsCount);
		
				}
			const arc = params.arc;
			if (arc != pi / 2) {

				//создать максимально возможный массив точек всех окружностей
				isCreateCirclesPoints = true;
				params.arc = pi / 2;

				//создать окружности
				isCreateCirclesPoints = false;
				params.arc = arc;

			}
			else setCircles();

		}, {

			scales: {

				//x: x, y: y, z: z,
				//posAxesIntersection: new THREE.Vector3( 0, 0, 0 ),
				text: {
					
					precision: 5,
					rect: { displayRect: false, },
				
				}

			},
			canvas: {

				noButtonFullScreen: true,

			},
			player: false,
			playerOptions: {
				
				//max: Infinity,
				//interval: 100,
				
			}

		} );

	</script>
</body>
</html>