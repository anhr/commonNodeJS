<!DOCTYPE html>

<html>
<head>
	<title>3D Random Vertice</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<!--<script src="../../../../../three.js/dev/build/three.js"></script>-->
	<!--<script src="../../../../../three.js/dev/build/three.min.js"></script>-->
	<!--<script src="https://raw.githack.com/anhr/three.js/dev/build/three.js"></script>-->
	<!--<script src="https://raw.githack.com/anhr/three.js/dev/build/three.min.js"></script>-->
	<!--<script src="https://threejs.org/build/three.js"></script>-->
	<!--<script src="https://threejs.org/build/three.min.js"></script>-->
</head>
<body>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
		- <a href="https://github.com/anhr/commonNodeJS/tree/master/HyperSphere" target="_blank" rel="noopener">3D Random Vertice</a>.
		By <a href="https://github.com/anhr" target="_blank" rel="noopener">anhr</a>
	</div>

	<script type="module">

		import * as THREE from '../../../../../three.js/dev/build/three.module.js';

		import MyThree from '../../../myThree/myThree.js';
		MyThree.three.THREE = THREE;

		import RandomVertice from '../randomVerticeHSphere.js';
		import HyperSphere from '../../hyperSphere3D.js';
		
		import anglesRange from '../../anglesRange.js'
		import getHyperSphere from '../getHyperSphere.js'
		import * as utils from '../../utilsHSphere.js'
		
		new MyThree((scene, options) => {

			const pi = Math.PI;

			const randomVerticeSettings = {

				//R: 0.5,
				debug: {
					
					notRandomVertices: true,
				
				},
			
			};
			/*https://gemini.google.com/
			Имеется точка point1 на поверхности 3-мерной гиперсферы встроенной в 4-мерное евклидово пространство. Для обозначения положения точки применим полярную систему координат.
			Положение точки обозначим как
			point1.latitude - широта (зенитный угол),
			point1.longitude - долгота (азимутальный угол) и 
			point1.altitude - полярный угол от оси W.
			
			Вычислить координаты антиподальной точки point2
			*/

			const findAntipodalPoint = (point1) => {

			
			  let latitude2 = -point1.latitude;
			  let longitude2 = point1.longitude + Math.PI;
			  let altitude2 = Math.PI - point1.altitude;
			
			  // Приведение долготы к диапазону от -π до π
			  if (longitude2 > Math.PI) {
				longitude2 -= 2 * Math.PI;
			  }
			  if (longitude2 < -Math.PI) {
				longitude2 += 2 * Math.PI;
			  }
				return [
					altitude2,
					latitude2,
					longitude2,
				];
				
			}
			/*
			// Пример использования
			const point1 = {
			  latitude: Math.PI / 4, // 45 градусов
			  longitude: Math.PI / 2, // 90 градусов
			  altitude: Math.PI / 3, // 60 градусов
			};
			
			const point2 = findAntipodalPoint(point1);
			
			console.log("Координаты исходной точки (point1):", point1);
			console.log("Координаты антиподальной точки (point2):", point2);
			
			// Дополнительный пример для проверки приведения долготы
			const point3 = {
			  latitude: 0,
			  longitude: 3 * Math.PI / 4, // 135 градусов
			  altitude: Math.PI / 2,
			};
			
			const point4 = findAntipodalPoint(point3);
			console.log("\nКоординаты исходной точки (point3):", point3);
			console.log("Координаты антиподальной точки (point4):", point4);
			*/
			
			/*
			const vertice = [
				0,//altitude
				pi / 4,//Latitude
				0,//Longitude
			]
			*/
			const vertice = [
				pi / 6,//altitude. Если 0 или pi, то arc = pi
				pi / 4,//Latitude
				pi / 3,//Longitude
			]
			utils.angles(vertice);
			
			const params = {

				//вершины расположены почти друг против друга по диагонали (antipodal points). Облако случайных вершин стянулось недалеко от противоположной вершины
				//Вершины взял из передыдущих вершин и немного изменил Longitude в oppositeVertice
				vertice: vertice,
				oppositeVertice: [
					2.617,//altitude
					-0.785,//0,//Latitude
					-2.094 + 0.107,//-1.987 Longitude
				],
				vertice: [
					pi / 4,//altitude
					pi / 50,//Latitude
					0,//Longitude
				],
				oppositeVertice: [
					pi / 4,//altitude
					0,//Latitude
					0,//Longitude
				],
				/*
				//Вершина и противоположная вершина почти одинаковые. Облако случайных вершин почти равномерно распределено по гиперсфере
				vertice: [
					pi / 6,//altitude
					pi / 4,// + pi / 50,//Latitude
					0,//Longitude
				],
				oppositeVertice: [
					pi / 6,//altitude
					pi / 4,//Latitude
					0,//pi / 40,//Longitude
				],
				*/
				/*
				//вершины расположены друг против друга по диагонали (antipodal points). arc = π. Облако случайных вершин стянулось в точку
				vertice: vertice,
				oppositeVertice: findAntipodalPoint(vertice),//calculateAntipodalPointViaCartesian(vertice),//calculateAntipodalPoint(vertice),
				*/
				vertice: [
					pi / 6,//altitude
					0.785,//Latitude
					pi,//Longitude
				],
				oppositeVertice: [
					pi / 6,//altitude
					0.051,//0,//Latitude
					pi,//Longitude
				],
				debug: randomVerticeSettings.debug,

			}
			utils.angles(params.oppositeVertice);

			//Vertices hyperSphere 

			const verticesSettings = {

				R: randomVerticeSettings.R,
				debug: true,

			};
			let hsVertices;
			hsVertices = new HyperSphere(options, {

				r: verticesSettings.R,
				//edges: false,
				//randomArc: true,
				projectParams: { scene: scene, },
				debug: randomVerticeSettings.debug ? {

					probabilityDensity: false,
					middleVertice: false,
					log: false,

				} : false,
				//debug: false,
				settings: {

					object: {

						name: 'Vertices',
						//color: 'white',
						geometry: {

							params: params,

						},

					},
					overriddenProperties: { setDrawRange: (start, count) => { if (hsVertices) hsVertices.bufferGeometry.setDrawRange(start, count); } },

				},

			});
			
			//Random vertice hyperSphere 

			let hsRandomVertice;
			let randomCloud;// cloud, randomVertice;//сразу не создаю эти объекты потому что они могут не понадобиться и потому, что так легче отлаживать
			const updateRandomVerticeHyperSphere = () => {

				if (!randomCloud) randomCloud = new RandomVertice(params, 750);//, true);
				if (hsRandomVertice) {
					
					const guiSelectPoint = hsRandomVertice.classSettings.settings.options.guiSelectPoint;
					if (guiSelectPoint && guiSelectPoint.isSelectedMesh(hsRandomVertice.object3D)) guiSelectPoint.selectMesh(-1);
					
				} else {

					const debug = {
								
						probabilityDensity: false,
						middleVertice: false,
						log: false,
						
					}
					hsRandomVertice = randomCloud.getHyperSphere(hsVertices.classSettings, scene);
					
				}
					
				}
			updateRandomVerticeHyperSphere();
			
			//GUI

			const gui = options.dat.gui.addFolder('Hypersphere'),
				onChangeVertice = (verticeId) => {

					hsVertices.update(verticeId, 0);

					updateRandomVerticeHyperSphere();

					
				};

			//vertice
			const fVertice = gui.addFolder('Vertice');
			fVertice.add(params.vertice, 'altitude', anglesRange.altitude.min, anglesRange.altitude.max, 0.001).onChange(() => { onChangeVertice(0); });
			fVertice.add(params.vertice, 'latitude', anglesRange.latitude.min, anglesRange.latitude.max, 0.001).onChange(() => { onChangeVertice(0); });
			fVertice.add(params.vertice, 'longitude', anglesRange.longitude.min, anglesRange.longitude.max, 0.001).onChange(() => { onChangeVertice(0); });

			//oppositeVertice
			const fOppositeVertice = gui.addFolder('Opposite Vertice');
			fOppositeVertice.add(params.oppositeVertice, 'altitude', anglesRange.altitude.min, anglesRange.altitude.max, 0.001).onChange(() => { onChangeVertice(1); });
			fOppositeVertice.add(params.oppositeVertice, 'latitude', anglesRange.latitude.min, anglesRange.latitude.max, 0.001).onChange(() => { onChangeVertice(1); });
			fOppositeVertice.add(params.oppositeVertice, 'longitude', anglesRange.longitude.min, anglesRange.longitude.max, 0.001).onChange(() => { onChangeVertice(1); });

			
			//////////////////////////////////////////GUI

		}, {

			/*
			orbitControls: {
				
				//enableRotate: false,
				
				//Эта позиция удобна при ручном выборе коэфициента в params.circleLatitudeMultiplier 
				//target: new THREE.Vector3(-0.41085804008835874, -0.2234325634279063, 0.015116584329208154),
				target: new THREE.Vector3(-0.4415629162745614, -0.2831194023323842, 0.09389333361910926),//видно только первые точки массива
			
			},
			camera: {

				//Эта позиция удобна при ручном выборе коэфициента в params.circleLatitudeMultiplier 
				//position: new THREE.Vector3( 0.18776987557365837, -0.7441773761495519, -0.17576637843473933 ),
				position: new THREE.Vector3( -0.22468319224547928, -0.5083649383369934, 0.007642622222928747 ),//видно только первые точки массива
				//position: new THREE.Vector3( -0.052437394122231695, -0.5412090881135114, -0.09917209654883102 ),
			
			},
			*/
			//stereoEffect: false,
			scene: { rotation: new THREE.Euler(-Math.PI / 2), },
			scales: {

				//x: {},
				//y: {},
				text: { precision: 1, rect: { displayRect: false, }, }

			},
			canvas: {

				noButtonFullScreen: true,

			},
			player: false,
			playerOptions: {
				
				//max: Infinity,
				//interval: 100,
				
			},
			//axesHelper: false,

		} );

	</script>
</body>
</html>