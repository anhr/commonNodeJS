<!DOCTYPE html>

<html>
<head>
    <title>2D Random Vertice</title>

    <!--for mobile devices-->
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <!--<script src="../../../../../three.js/dev/build/three.js"></script>-->
    <!--<script src="../../../../../three.js/dev/build/three.min.js"></script>-->
    <!--<script src="https://raw.githack.com/anhr/three.js/dev/build/three.js"></script>-->
    <!--<script src="https://raw.githack.com/anhr/three.js/dev/build/three.min.js"></script>-->
    <!--<script src="https://threejs.org/build/three.js"></script>-->
    <!--<script src="https://threejs.org/build/three.min.js"></script>-->
</head>
<body>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
		- <a href="https://github.com/anhr/commonNodeJS/tree/master/HyperSphere" target="_blank" rel="noopener">2D Random Vertice</a>.
		By <a href="https://github.com/anhr" target="_blank" rel="noopener">anhr</a>
	</div>

	<script type="module">

		import * as THREE from '../../../../../three.js/dev/build/three.module.js';

		import MyThree from '../../../myThree/myThree.js';
		MyThree.three.THREE = THREE;

		//import RandomVertice from '../randomVerticeSphere.js';
		import { RandomVerticeSphere as RandomVertice } from '../randomVerticeSphere.js';
		import RandomCloud from '../randomCloudSphere.js';
		import Cloud from '../cloudSphere.js';
		import HyperSphere from '../../sphere.js';
		import anglesRange from '../../anglesRange.js'
		import getHyperSphere from '../getHyperSphere.js'
		
		new MyThree((scene, options) => {

			const pi = Math.PI;

			const randomVerticeSettings = {

				//R: 0.5,
				debug: {
					
					notRandomVertices: true,
				
				},
//				cloud: true,
				
				modes: {

					cloud: 0,
					randomVertice: 1,
					randomCloud: 2,
					
				},
				mode: 0,
			
			};
//			randomVerticeSettings.cloud ||= false;
			const params = {

				//вершины расположены друг против друга по диагонали. arc = π
				/*
				vertice: [
					pi / 4,//0,//Latitude
					0,//Longitude
				],
				oppositeVertice: [
					-pi / 4,//0,//Latitude
					pi,//Longitude
				],
				*/
				/*
				vertice: [
					0.785,//Latitude
					pi,//Longitude
				],
				oppositeVertice: [
					0.051,//0,//Latitude
					pi,//Longitude
				],
				*/
				//вершины расположены друг против друга на экваторе
				vertice: [],
				oppositeVertice: [
					0,//Latitude
					pi,//Longitude
				],
				debug: randomVerticeSettings.debug,

			}
			
			//Random vertice hyperSphere 

			let hsRandomVertice;
			const createRandomVerticeHyperSphere = (randomVertice, name) => {

				if (hsRandomVertice) {

					randomVertice.randomAngles;
//					hsRandomVertice.setPositionAttributeFromPoints(randomVertice.randomAngles, true);
					const guiSelectPoint = hsRandomVertice.classSettings.settings.options.guiSelectPoint;
					if (guiSelectPoint && guiSelectPoint.isSelectedMesh(hsRandomVertice.object3D)) guiSelectPoint.selectMesh(-1);
					
				} else {

					const debug = {
								
						probabilityDensity: false,
						middleVertice: false,
						log: false,
						
					}
					if (randomVertice.getHyperSphere) hsRandomVertice = randomVertice.getHyperSphere(options, {
						
							projectParams: { scene: scene },
							debug: debug,
							r: randomVerticeSettings.R,
						
						});
					else
						hsRandomVertice = getHyperSphere(HyperSphere, options, scene, randomVertice, { debug: debug, r: randomVerticeSettings.R, name: name });
/*					
						hsRandomVertice = new HyperSphere(options, {
		
						boRemove: false,//Если не установить этот флаг, то при замене старого hsRandomVertice на новый будут удаляться все гиперсферы на scene. То есть удалится hsVertices
						r: randomVerticeSettings.R,
						edges: false,
						//randomArc: true,
						projectParams: { scene: scene, },
						debug: {
		
							probabilityDensity: false,
							middleVertice: false,
							log: false,
		
						},
						settings: {
		
							object: {
		
								name: name,
								//color: 'white',
	//							geometry: { angles: randomVertice.angles, },
								geometry: randomVertice,
		
							},
							overriddenProperties: { setDrawRange: (start, count) => { if (hsRandomVertice) hsRandomVertice.bufferGeometry.setDrawRange(start, count); } },
		
						},
		
					});
*/					
					
				}
				hsRandomVertice.classSettings.settings.bufferGeometry.userData.drawRange = () => {

					return { start: 0, count: params.pointsCount };//устанавливает количество точек в органе управления 'Meshes\Points'
//					return { start: 0, count: params.verticesAngles.length };//устанавливает количество точек в органе управления 'Meshes\Points'
//					return { start: 0, count: randomVertice.circlesPointsCount != undefined ? randomVertice.circlesPointsCount : 1 };//устанавливает количество точек в органе управления 'Meshes\Points'
					
				}
				if (hsRandomVertice.classSettings.edges.project) {

					hsRandomVertice.classSettings.overriddenProperties.onCreateEdgesCompleted = () => {

//						hsRandomVertice.setDrawRange(0, randomCloud.circlesPointsCount * 2 - 1);//Умножаем на 2 потому что на каждую точку облака случайных точек приходится два ребра
						hsRandomVertice.setDrawRange(0, params.pointsCount * 2 - 1, 1);//Умножаем на 2 потому что на каждую точку облака случайных точек приходится два ребра
						delete hsRandomVertice.classSettings.overriddenProperties.onCreateEdgesCompleted;
						
					}
					
				} else 
					hsRandomVertice.setVerticesRange(0, params.pointsCount != undefined ? params.pointsCount : 1);
//					hsRandomVertice.setVerticesRange(0, randomVertice.circlesPointsCount != undefined ? randomVertice.circlesPointsCount : 1);
	
			}
/*			
			let prevObject = undefined;
			const updateRandomVerticeHyperSphere = () => {

//				if (prevObject != undefined) delete prevObject;
				const modes = randomVerticeSettings.modes;
				switch (randomVerticeSettings.mode) {

					case modes.cloud:
						prevObject = new Cloud(params); break;
					case modes.randomVertice:
						prevObject = new RandomVertice(params);
						prevObject.randomAngles;
						break;
					case modes.randomCloud:
						prevObject = new RandomCloud(params); break;
					default: console.error('Invalid mode = ' + mode);

				}
				createRandomVerticeHyperSphere(prevObject, 'Random Cloud');

			}
*/
			let randomCloud, cloud, randomVertice;//сразу не создаю эти объекты потому что они могут не понадобиться и потому, что так легче отлаживать
			const updateRandomVerticeHyperSphere = () => {

//					if (params.verticesAngles) params.verticesAngles.length = 0;
					const modes = randomVerticeSettings.modes;
					switch (randomVerticeSettings.mode){

						case modes.cloud:
							if (!cloud)
								cloud = new Cloud(params);
							createRandomVerticeHyperSphere(cloud, 'Cloud');
//console.error('debug');
//cloud.getRandomVerticeAngles(cloud, params);
							randomVertice = undefined;
							break;
						case modes.randomVertice:
							if (!randomVertice)//Если не делать эту проверку, то при редактировании положения точки появляется две точки
								randomVertice = new RandomVertice(params);
							createRandomVerticeHyperSphere(randomVertice, 'Random vertice'); break;
						case modes.randomCloud: 
							if (!randomCloud)
								randomCloud = new RandomCloud(params);
							createRandomVerticeHyperSphere(randomCloud, 'Random Cloud');
							randomVertice = undefined;
							break;
						default: console.error('Invalid mode = ' + mode);
							
					}
					
				}
			updateRandomVerticeHyperSphere();
	
			//Vertices hyperSphere 
			
			const verticesSettings = {

				//R: 0.5,
				debug: true,
			
			};
			let hsVertices;
			hsVertices = new HyperSphere(options, {

				r: verticesSettings.R,
				//edges: false,
				//randomArc: true,
				projectParams: { scene: scene, },
//				debug: debug,
				debug: randomVerticeSettings.debug ? {

					probabilityDensity: false,
					middleVertice: false,
					log: false,

				} : false,
				//debug: false,
				settings: {

					object: {

						name: 'Vertices',
						color: 'white',
						geometry: {

//							angles: [params.vertice, params.oppositeVertice],
							params: params,

						},

					},
					overriddenProperties: { setDrawRange: (start, count) => { if (hsVertices) hsVertices.bufferGeometry.setDrawRange(start, count); } },

				},

			});
			hsVertices.setDrawRange(hsVertices.bufferGeometry.drawRange.start, hsVertices.bufferGeometry.attributes.position.count, 0);
			
			//GUI

			const gui = options.dat.gui.addFolder('Hypersphere'),
				onChangeVertice = (verticeId) => {

//					hsVertices.setPositionAttributeFromPoint(verticeId);
					hsVertices.update(verticeId, 0);
					
					updateRandomVerticeHyperSphere();
					
				};

			//vertice
			const fVertice = gui.addFolder('Vertice');
			fVertice.add(params.vertice, 'latitude', anglesRange.latitude.min, anglesRange.latitude.max, 0.001).onChange(() => { onChangeVertice(0); });
			fVertice.add(params.vertice, 'longitude', anglesRange.longitude.min, anglesRange.longitude.max, 0.001).onChange(() => { onChangeVertice(0); });

			//oppositeVertice
			const fOppositeVertice = gui.addFolder('Opposite Vertice');
			fOppositeVertice.add(params.oppositeVertice, 'latitude', anglesRange.latitude.min, anglesRange.latitude.max, 0.001).onChange(() => { onChangeVertice(1); });
			fOppositeVertice.add(params.oppositeVertice, 'longitude', anglesRange.longitude.min, anglesRange.longitude.max, 0.001).onChange(() => { onChangeVertice(1); });


			//mode
			{

				let mode = randomVerticeSettings.mode;
				Object.defineProperty(randomVerticeSettings, 'mode', {
			
					get: () => { return mode; },
					set: (modeNew) => {

						hsRandomVertice.removeHyperSphere();
						hsRandomVertice = undefined;
						
						delete params.verticesAngles;
						delete params.pointsCount;
						delete params.editAnglesId;

						randomCloud = undefined;
						cloud = undefined;
						randomVertice = undefined;

						mode = parseInt(modeNew);
/*						
						const modes = randomVerticeSettings.modes;
						switch (mode){

							case modes.cloud: break;
							case modes.randomVertice:
								if (!randomVertice) randomVertice = new RandomVertice(params);
								else randomVertice.randomAngles;
								break;
							case modes.randomCloud: break;
							default: console.error('Invalid mode = ' + mode);
								
						}
*/						
						
						updateRandomVerticeHyperSphere();
			
					},
			
				});

			}
			gui.add(randomVerticeSettings, 'mode', randomVerticeSettings.modes);
			
			//////////////////////////////////////////GUI

		}, {

			//orbitControls: { enableRotate: false, },
			//camera: { position: new THREE.Vector3( 0, 0, 2 ) },
			//stereoEffect: false,
			scene: { rotation: new THREE.Euler(-Math.PI / 2), },
			scales: {

				//x: {},
				//y: {},
				text: { precision: 1, rect: { displayRect: false, }, }

			},
			canvas: {

				noButtonFullScreen: true,

			},
			player: false,
			playerOptions: {
				
				//max: Infinity,
				//interval: 100,
				
			}

		} );

	</script>
</body>
</html>