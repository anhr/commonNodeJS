<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Player</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">

	<link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">

</head>
<body>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a> - Player - 3D objects animation.
		By <a href="https://github.com/anhr" target="_blank" rel="noopener">anhr</a>
	</div>
	<canvas id="canvas" height="128" width="128"></canvas>

	<script type="module">

		import * as THREE from 'https://threejs.org/build/three.module.js';
		//import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import { THREE } from '../../three.js';//https://github.com/anhr/commonNodeJS
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		//import { dat } from '../../dat/dat.module.js';//https://github.com/anhr/commonNodeJS
		//import { dat } from 'https://raw.githack.com/anhr/commonNodeJS/master/dat/dat.module.js';

		//import cookie from '../../../../cookieNodeJS/master/cookie.js';//https://github.com/anhr/cookieNodeJS
		//import cookie from 'https://raw.githack.com/anhr/cookieNodeJS/master/cookie.js';

		//import { getLanguageCode } from '../../lang.js';//https://github.com/anhr/commonNodeJS
		//import { getLanguageCode } from 'https://raw.githack.com/anhr/commonNodeJS/master/lang.js';

		//import { StereoEffect, spatialMultiplexsIndexs } from '../StereoEffect.js';//https://github.com/anhr/commonNodeJS
		//import { StereoEffect, spatialMultiplexsIndexs } from 'https://raw.githack.com/anhr/commonNodeJS/master/StereoEffect/StereoEffect.js';
		
		//import { OrbitControls } from '../../../../three.js/dev/examples/jsm/controls/OrbitControls.js';//https://github.com/anhr/three.js
		//import { OrbitControls } from 'https://raw.githack.com/anhr/three.js/dev/examples/jsm/controls/OrbitControls.js';

		//import Player from '../player.js';
		import Player from 'https://raw.githack.com/anhr/commonNodeJS/master/player/player.js';

		import ColorPicker from '../../../../colorpicker/master/colorpicker.js';//https://github.com/anhr/colorPicker
		//import ColorPicker from 'https://raw.githack.com/anhr/colorpicker/master/colorpicker.js';
		ColorPicker.palette.setTHREE(THREE);

		var camera, scene, renderer, stereoEffect, controls, player;

		init();
		animate();

		function init() {

			camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
			const defaultCameraPosition = new THREE.Vector3( 0.4, 0.4, 2 );
			camera.position.copy( defaultCameraPosition );

			scene = new THREE.Scene();

			if ( typeof Player !== 'undefined' ) {

				const palette = new ColorPicker.palette( { palette: ColorPicker.paletteIndexes.bidirectional } );
				player = new Player( {

					settings: {

						marks: 110,
						name: "Time (sec.)"

					},
//					cookie: cookie,
					//cookieName: '_' + getCanvasName(),
					onChangeScaleT: function ( scale ) {

						if ( canvasMenu !== undefined )
							canvasMenu.onChangeScale( scale );
						group.children.forEach( function ( mesh ) {

							if ( ( mesh.userData.arrayFuncs === undefined ) || ( typeof mesh.userData.arrayFuncs === "function" ) )
								return;
							mesh.userData.arrayFuncs.forEach( function ( vector ) {

								if ( vector.line === undefined )
									return;
								vector.line.remove();
								vector.line = new Player.traceLine();

							} );

						} );

					},

				}, function ( index, t ) {

//					var t = ( ( options.player.max - options.player.min ) / ( options.player.marks - 1 ) ) * index + options.player.min;
					Player.selectPlayScene( THREE, scene, t, index, { palette: palette } );
					if ( typeof canvasMenu !== 'undefined' )
						canvasMenu.setIndex( index, options.player.name + ': ' + t );
/*						
					if ( typeof frustumPoints !== 'undefined' )
						frustumPoints.updateCloudPoints();
*/						

				} );
/*				
				if ( ( gui !== undefined ) && ( typeof controllerPlay !== 'undefined' ) ) {

					var playController = controllerPlay.create( player );
					gui.add( playController );

				}
*/				
				player.play3DObject();

			}

			const arrayFuncs = [
				//new THREE.Vector3( 0.5, 0.5, 0.5 ),
/*				
				new THREE.Vector3(
					new Function( 't', 'a', 'b', 'return Math.sin(t*a*2*Math.PI)*0.5+b' ),//x
					0.5,
					0.5 ),
*/					
				{

					vector: new THREE.Vector4(
						new Function( 't', 'a', 'b', 'return Math.sin(t*a*2*Math.PI)*0.5+b' ),//x
						new Function( 't', 'a', 'b', 'return Math.cos(t*a*2*Math.PI)*0.5-b' ),//y
						new Function( 't', 'a', 'b', 'return Math.cos(t*a*2*Math.PI)*0.5-0.1' ),//z
						//new Function( 't', 'return 100*t' ),//w
						{

							func: new Function( 't', 'return 1-2*t' ),
							min: -1,
							max: 1,

						},//w
					),//Animated 3D point
					trace: true,//Displays the trace of the point movement.

				},
				new THREE.Vector3( -0.5, -0.5, -0.5 ),
			];
			const points = new THREE.Points( new THREE.BufferGeometry().setFromPoints( Player.getPoints( THREE, arrayFuncs,
				{ group: scene } ) ),
				new THREE.PointsMaterial( {

					/*
					color: 0xffffff,
					alphaTest: 0.5,
					*/
					vertexColors: THREE.VertexColors,
					size: 5,//0.05,
					sizeAttenuation: false,

				} ) );
			/*				
			points.geometry.setAttribute( 'color',
				new THREE.Float32BufferAttribute( Player.getColors( THREE, arrayFuncs,
					{ positions: points.geometry.attributes.position }), 4 ) );
			*/
			scene.add( points );

			//Define this function if you want play the colors of the points.
			points.userData.selectPlayScene = function ( t ) {

//				console.warn( 'points.userData.selectPlayScene(' + t + ')' );

			}
			points.userData.arrayFuncs = arrayFuncs;

			renderer = new THREE.WebGLRenderer( {

				antialias: true,
				canvas: document.getElementById( 'canvas' ),

			} );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			//

			if ( typeof OrbitControls !== 'undefined' ) {

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( scene.position.x * 2, scene.position.y * 2, scene.position.z * 2 );
				controls.update();

			}

			if ( typeof StereoEffect !== "undefined" ) {
				stereoEffect = new StereoEffect( THREE, renderer, {

					spatialMultiplex: spatialMultiplexsIndexs.SbS,//Side by side stereo effect
					far: camera.far,
					camera: camera,
					//stereoAspect: 1,

				} );
				stereoEffect.setSize( window.innerWidth, window.innerHeight );

			}

			//Using [dat.gui](https://github.com/anhr/dat.gui) for change of the StereoEffect settings.

			if ( typeof dat !== "undefined" ) {

				const gui = new dat.GUI();

				if ( stereoEffect )
					stereoEffect.gui( gui, {

						getLanguageCode: getLanguageCode,
						cookie: cookie,//Saves a custom StereoEffect settings in the cookie

					} );
					
				if ( typeof controllerPlay !== 'undefined' ) {

					var playController = controllerPlay.create( player );
					gui.add( playController );

				}

			}

			window.addEventListener( 'resize', onWindowResize, false );


		}
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

			requestAnimationFrame( animate );

			if ( stereoEffect === undefined )
				renderer.render( scene, camera );
			else stereoEffect.render( scene, camera );

			if ( player !== undefined )
				player.animate();

		}

	</script>
</body>
</html>
