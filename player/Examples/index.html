<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Player</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">

	<!--<link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">-->
	<link type="text/css" rel="stylesheet" href="../../../../three.js/dev/examples/main.css">

</head>
<body>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a> - Player - 3D objects animation.
		By <a href="https://github.com/anhr" target="_blank" rel="noopener">anhr</a>
	</div>
	<div>
		<canvas id="canvas"></canvas>
	</div>

	<script type="module">

		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import * as THREE from '../../../../three.js/dev/build/three.module.js';
		import { THREE } from '../../three.js';//https://github.com/anhr/commonNodeJS
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		import { dat } from '../../dat/dat.module.js';//https://github.com/anhr/commonNodeJS
		//import { dat } from 'https://raw.githack.com/anhr/commonNodeJS/master/dat/dat.module.js';

		import cookie from '../../cookieNodeJS/cookie.js';//https://github.com/anhr/commonNodeJS/tree/master/cookieNodeJS
		//import cookie from 'https://raw.githack.com/anhr/cookieNodeJS/master/cookie.js';
		//import cookie from 'https://raw.githack.com/anhr/commonNodeJS/master/cookieNodeJS/cookie.js';

		import { getLanguageCode } from '../../lang.js';//https://github.com/anhr/commonNodeJS
		//import { getLanguageCode } from 'https://raw.githack.com/anhr/commonNodeJS/master/lang.js';
		/*
				//import StereoEffect from '../../StereoEffect/StereoEffect.js';//https://github.com/anhr/commonNodeJS
				//import StereoEffect from 'https://raw.githack.com/anhr/commonNodeJS/master/StereoEffect/StereoEffect.js';
		*/
		import StereoEffect from '../../StereoEffect/StereoEffect.js';//https://github.com/anhr/commonNodeJS
		//import StereoEffect from 'https://raw.githack.com/anhr/commonNodeJS/master/StereoEffect/StereoEffect.js';

		//import { OrbitControls } from '../../../../three.js/dev/examples/jsm/controls/OrbitControls.js';//https://github.com/anhr/three.js
		//import { OrbitControls } from 'https://raw.githack.com/anhr/three.js/dev/examples/jsm/controls/OrbitControls.js';

		import Player from '../player.js';
		//import Player from 'https://raw.githack.com/anhr/commonNodeJS/master/player/player.js';

		import ColorPicker from '../../colorpicker/colorpicker.js';//https://github.com/anhr/commonNodeJS/tree/master/colorpicker
		//import ColorPicker from 'https://raw.githack.com/anhr/commonNodeJS/master/colorpicker/colorpicker.js';
		ColorPicker.palette.setTHREE( THREE );

		//import getShaderMaterialPoints from 'http://localhost/anhr/commonNodeJS/master/getShaderMaterialPoints/getShaderMaterialPoints.js';
		//import getShaderMaterialPoints from '../../getShaderMaterialPoints/getShaderMaterialPoints.js';
		//import getShaderMaterialPoints from 'https://raw.githack.com/anhr/commonNodeJS/master/getShaderMaterialPoints/getShaderMaterialPoints.js';

		//import MyPoints from 'https://raw.githack.com/anhr/commonNodeJS/master/myPoints/myPoints.js';
		import MyPoints from '../../myPoints/myPoints.js';

		//import CanvasMenu from 'https://raw.githack.com/anhr/commonNodeJS/master/canvasMenu/canvasMenu.js';
		import CanvasMenu from '../../canvasMenu/canvasMenu.js';
		//import CanvasMenu from 'http://localhost/anhr/commonNodeJS/master/canvasMenu/canvasMenu.js';

		import controllerPlay from '../../controllerPlay/controllerPlay.js';//https://github.com/anhr/controllerPlay
		//import controllerPlay from 'https://raw.githack.com/anhr/commonNodeJS/master/controllerPlay/controllerPlay.js';


		var camera, scene, renderer, stereoEffect, controls, player;

		init();
		animate();

		function init() {

			camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
			camera.position.copy( new THREE.Vector3( 0.4, 0.4, 2 ) );

			scene = new THREE.Scene();

			const palette = typeof ColorPicker === 'undefined' ? undefined : new ColorPicker.palette( { palette: ColorPicker.paletteIndexes.bidirectional } );

			if ( typeof Player !== 'undefined' ) {

				player = new Player( THREE, scene, {

					selectPlaySceneOptions: {

						palette: palette,

					},
					cookie: typeof cookie === 'undefined' ? undefined : cookie,//Saves a custom StereoEffect settings in the cookie
					settings: {

						marks: 100,//Ticks count of the playing.
						interval: 25,//Ticks per seconds.
						min: -1,
						//max: 1,
						//dt: 5,
						//max: null,//Infinity, первращается в null после чтения из cookie

					},

				} );

			}

			const arrayFuncs = typeof Player === 'undefined' ?
			 [
				new THREE.Vector4( 0.5, 0.5, 0.5, 0.5 ),
				new THREE.Vector3( -0.5, -0.5, -0.5 ),
			] :
			 [
				{

					vector: new THREE.Vector4(
						new Function( 't', 'a', 'b', 'return Math.sin(t*a*2*Math.PI)*0.5+b' ),//x
						new Function( 't', 'a', 'b', 'return Math.cos(t*a*2*Math.PI)*0.5-b' ),//y
						new Function( 't', 'a', 'b', 'return Math.cos(t*a*2*Math.PI)*0.5-0.1' ),//z
						//100,//w
						new Function( 't', 'return 100*t' ),//w
						/*
						{

							func: new Function( 't', 'return 1-2*t' ),
							min: -1,
							max: 1,

						},//w
						*/
					),//Animated 3D point
					trace: true,//Displays the trace of the point movement.

				},
				new THREE.Vector3( -0.5, -0.5, -0.5, 50 ),
			];

			if ( typeof getShaderMaterialPoints !== 'undefined' ) {

				console.log( 'Using getShaderMaterialPoints method for creating of the points.' );
				getShaderMaterialPoints( THREE, scene, arrayFuncs,// Player,
					function ( points ) {

						scene.add( points );
						points.userData.player = {

							arrayFuncs: arrayFuncs,
							selectPlayScene: function ( t ) {

								points.position.x = t;
								points.rotation.z = - Math.PI * 2 * t;

							}

						}

					},
					{

						Player: typeof Player === 'undefined' ? undefined : Player,
						options: { palette: palette, },//нужно на случай если не создан плеер
//						tMin: player ? Player.getSettings().min : undefined,

					}
				);
			} else if ( typeof MyPoints !== 'undefined' ) {

				console.log( 'Using MyPoints method for creating of the points.' );
				MyPoints( THREE, arrayFuncs,
					scene, {

					Player: typeof Player === 'undefined' ? undefined : Player,
					options: {

						point: { size: 15 },
						palette: palette,
						//					player: { player: player },

					},
					pointsOptions: {

						position: new THREE.Vector3( new Function( 't', 'return t' ), 0, 0 ),
						shaderMaterial: {}

					}

				} );

			} else {

				console.log( 'Using THREE.Points method for creating of the points.' );
				const points = new THREE.Points( new THREE.BufferGeometry().setFromPoints(
					typeof Player === 'undefined' ? arrayFuncs:
						Player.getPoints( THREE, arrayFuncs, { group: scene, options: { player: { player: player } } } )
				),
					new THREE.PointsMaterial( {

						vertexColors: THREE.VertexColors,
						size: 5,//0.05,
						sizeAttenuation: false,

					} ) );
				if ( typeof Player === 'undefined' ) {

/*
					points.geometry.setAttribute( 'color',
						new THREE.Float32BufferAttribute( Player.getColors( THREE, arrayFuncs, {

		//						scale: options.scales.w,
							palette: palette,

						} ), 3 ) );
*/
					points.geometry.setAttribute( 'color',
						new THREE.Float32BufferAttribute( [
							1, 0, 0,//first point is red
							1, 1, 1//second point is white
						], 3 ) );

				}
					
				scene.add( points );
				points.userData.player = {

					arrayFuncs: arrayFuncs,
					//palette: palette,
					//palette: typeof ColorPicker === 'undefined' ? undefined : new ColorPicker.palette( { palette: ColorPicker.paletteIndexes.monochrome } ),
					selectPlayScene: function ( t ) {

						//points.position.x = t;
						//points.rotation.z = - Math.PI * 2 * t;

					}

				}

			}
			//player.play3DObject();

			renderer = new THREE.WebGLRenderer( {

				antialias: true,
				canvas: document.getElementById( 'canvas' ),

			} );
//			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );

			//

			if ( typeof OrbitControls !== 'undefined' ) {

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( scene.position.x * 2, scene.position.y * 2, scene.position.z * 2 );
				controls.update();

			}

			if ( typeof StereoEffect !== "undefined" ) {
				stereoEffect = new StereoEffect( THREE, renderer, {

					//spatialMultiplex: StereoEffect.spatialMultiplexsIndexs.SbS,//Side by side stereo effect
					far: camera.far,
					camera: camera,
					//stereoAspect: 1,

				} );
				//				stereoEffect.setSize( window.innerWidth, window.innerHeight );

			}
			if ( typeof CanvasMenu !== "undefined" ) {

				new CanvasMenu( renderer, {

					player: player,
					stereoEffect: stereoEffect,
					getLanguageCode: typeof getLanguageCode === 'undefined' ? undefined : getLanguageCode,

				} );

			}

			//Using [dat.gui](https://github.com/anhr/dat.gui) for change of the StereoEffect settings.

			if ( typeof dat !== "undefined" ) {

				const gui = new dat.GUI();

				if ( stereoEffect )
					stereoEffect.gui( gui, {

						getLanguageCode: typeof getLanguageCode === 'undefined' ? undefined : getLanguageCode,
						cookie: typeof cookie === 'undefined' ? undefined : cookie,//Saves a custom StereoEffect settings in the cookie

					} );
				if ( player !== undefined ) {

					player.gui( gui, typeof getLanguageCode === 'undefined' ? undefined : getLanguageCode );
					if ( typeof controllerPlay !== 'undefined' ) {

						controllerPlay.create( player, gui );
/*						
						const controler = gui.add( controllerPlay.create( player ) );
						controler.__truncationSuspended = true;
*/						

					}

				}

			}

			window.addEventListener( 'resize', onWindowResize, false );

		}
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

			requestAnimationFrame( animate );

			if ( stereoEffect === undefined )
				renderer.render( scene, camera );
			else stereoEffect.render( scene, camera );

		}

	</script>
</body>
</html>
