<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Intersects</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">
</head>
<body>
	<p>
		<a href='https://github.com/anhr' target="_blank">About me</a>
		<!--| <a href="https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane" target="_blank">Three JS - Find all points where a mesh intersects a plane</a>
		| <a href="https://jsfiddle.net/prisoner849/8uxw667m/" target="_blank">Example</a>-->
		| <a href="https://newbedev.com/how-to-detect-collision-in-three-js" target="_blank">How to detect collision in three.js?</a>
	</p>
	<h1>Intersects.</h1>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		import MyThree from '../../myThree/myThree.js';
		//import MyThree from '../../build/myThree.module.js';
		//import MyThree from '../../build/myThree.module.min.js';

		//Error: Access to XMLHttpRequest at 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/build/getShaderMaterialPoints/vertex.c'
		//	from origin 'http://localhost' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
		//import MyThree from 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/myThree.js';

//		import { getWorldPosition } from '../../getPosition.js';

		if ( MyThree.default ) MyThree = MyThree.default;
		MyThree.three.THREE = THREE;

		import { ConvexHull } from '../../../../three.js/dev/examples/jsm/math/ConvexHull.js';

		new MyThree( function ( scene, options ) {

			const collidableMeshList = [];

			//Thanks https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane
			const planeGeom = new THREE.PlaneGeometry( 30, 30 );
//			planeGeom.rotateX( -Math.PI / 2 );
			const plane = new THREE.Mesh( planeGeom, new THREE.MeshBasicMaterial( {
				color: "lightgray",
				transparent: true,
				opacity: 0.75,
				side: THREE.DoubleSide
			} ) );
//			plane.position.y = -3.14;
//			plane.rotation.x = Math.PI / 5;
			plane.name = 'plane';
			scene.add( plane );
			collidableMeshList.push( plane );

//			const objGeom = new THREE.DodecahedronGeometry( 10, 0 );
//			const objGeom = new THREE.TorusGeometry( 10, 3, 16, 100 );
			const objGeom = new THREE.TorusGeometry( 10, 3, 3, 3 );
			//const objGeom = new THREE.TetrahedronGeometry( 10, 0 );
			//const objGeom = new THREE.BoxGeometry( 10, 10, 10 );
			const obj = new THREE.Mesh( objGeom, new THREE.MeshBasicMaterial( {
					color: "green",
					wireframe: true
				} ) );
			//obj.rotation.x = Math.PI / 10;
			obj.rotation.y = Math.PI / 2;//10;
//			obj.position.set( 0, 3.14, 0 );
			scene.add( obj );

			//guiSelectPoint
			obj.name = 'Geometry';
			if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( obj );
/*
const lineSegments = new THREE.LineSegments( new THREE.BufferGeometry().setFromPoints( [
	new THREE.Vector3( 0, 0, 10 ),
	new THREE.Vector3( 10, 0, 10 ),
	new THREE.Vector3( 10, 10, 10 ),
	new THREE.Vector3( 0, 10, 10 ),
	new THREE.Vector3( 0, 0, 10 ),
] ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
scene.add( lineSegments );
*/

			//Player
			var intersectLine;
			var intersectPoints;
			const convexHull = new ConvexHull();
			obj.userData.player = {

				selectPlayScene: function ( t ) {

					obj.position.set( 0, 0, 10 - 30 * t );
					obj.updateMatrix();

					//thanks https://newbedev.com/how-to-detect-collision-in-three-js
					//http://stemkoski.github.io/Three.js/Collision-Detection.html
//					const MovingCube = obj;
					const arrayIntersectPoints = [];
					if ( intersectLine ) { 

						if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectLine );
						scene.remove( intersectLine );

					}
					if ( intersectPoints ) { 

						if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectPoints );
						scene.remove( intersectPoints );

					}
					
					convexHull.setFromObject( obj );
					const faces = convexHull.faces;
/*					
const face = faces[0];
const vertices = [];
while( face.edge.vertex.next ) {


}
*/
/*
function faceEdges( face ) {

	const vertices = [];
	var edge = face.edge;
	vertices.push( new THREE.Vector3().copy( edge.head().point ) );
	edge = edge.next;
	vertices.push( new THREE.Vector3().copy( edge.head().point ) );
	edge = edge.next;
	vertices.push( new THREE.Vector3().copy( edge.head().point ) );
	edge = edge.next;
	vertices.push( new THREE.Vector3().copy( edge.head().point ) );
	edge = edge.next;
	vertices.push( new THREE.Vector3().copy( edge.head().point ) );
	edge = edge.next;
	vertices.push( new THREE.Vector3().copy( edge.head().point ) );
	const convexHullLine = new THREE.LineSegments( new THREE.BufferGeometry().setFromPoints( vertices ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
	convexHullLine.position.set( 1, 1, 1 );
	scene.add( convexHullLine );

}
const face0 = faces[0];
faceEdges( face0 );
const face0_1 = face0.edge.twin.face;
faceEdges( face0_1 );
*/

					let faceIndex = 0;

					function setFace() {

						const face = faces[faceIndex];
						let edge = face.edge;
						function setEdge() {

							function getIntersect( edge, onIntersect ) {

								if ( edge.twin.face.used ) return;
								const globalOriginPoint = edge.head().point,
									globalVertex = edge.prev.head().point,
									directionVector = globalVertex.clone().sub( globalOriginPoint ),
									far = globalVertex.distanceTo( globalOriginPoint ),
									rayOriginPoint = new THREE.Raycaster( globalOriginPoint, directionVector.clone().normalize(), 0, far ),
									collisionResultsOriginPoint = rayOriginPoint.intersectObjects( collidableMeshList );
/*
									rayVertex = new THREE.Raycaster( globalVertex, globalOriginPoint.clone().sub( globalVertex ).clone().normalize(), 0, far ),
									collisionResultsVertex = rayVertex.intersectObjects( collidableMeshList );
*/
/*
if ( collisionResults.length > 1 )
	console.log('collisionResults.length = ' + collisionResults.length);
*/
/*
								if ( ( collisionResultsOriginPoint.length > 0 ) || ( collisionResultsVertex.length > 0 ) ) {

									const distanceToOriginPoint = collisionResultsOriginPoint.length > 0 ? globalOriginPoint.distanceTo( collisionResultsOriginPoint[0].point ) :
											Infinity,
										distanceToVertex = collisionResultsVertex.length > 0 ? globalVertex.distanceTo( collisionResultsVertex[0].point ) :
											Infinity,
										intersectionPoint = distanceToOriginPoint <= distanceToVertex ?
											collisionResultsOriginPoint[0].point : collisionResultsVertex[0].point;
									arrayIntersectPoints.push( intersectionPoint );
									if ( onIntersect ) onIntersect( intersectionPoint );
									
								}
*/
								if ( collisionResultsOriginPoint.length > 0 )
//								if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() )
//								if ( collisionResultsOriginPoint.length > 0 && collisionResultsOriginPoint[0].distance < directionVector.length() )
								{

	//								arrayIntersectPoints.push( new THREE.Vector3().copy( collisionResults[0].point ) );
									arrayIntersectPoints.push( collisionResultsOriginPoint[0].point );
									if ( onIntersect ) onIntersect( collisionResultsOriginPoint[0].point );
									return true;

								}

							}
/*
							while ( edge ) {

								if ( getIntersect( edge ) ) {

									edge = edge.twin.face.edge;
									continue;

								}
								edge = edge.next;
								if ( getIntersect( edge ) ) {

									edge = edge.twin.face.edge;
									continue;

								}
								if ( getIntersect( edge ) ) {

									edge = edge.twin.face.edge;
									continue;

								}

							}
*/							
							if ( getIntersect( edge, function ( point ) {

//								var faceIntersected = face;
								edge.face.used = true;
//								while ( !faceIntersected.used )
								while ( true ) {

/*
									faceIntersected.used = true;
									edge = edge.prev
*/
									const face = edge.twin.face;
									if ( face.used ) return;
									face.used = true;
									edge = face.edge;
									if ( getIntersect( edge ) ) {
								
//										faceIntersected = edge.twin.face;
										continue;
								
									}
									edge = edge.prev;
									if ( getIntersect( edge ) ) {
								
//										faceIntersected = edge.twin.face;
										continue;
								
									}
									edge = edge.prev;
									if ( getIntersect( edge ) ) {
								
//										faceIntersected = edge.twin.face;
										continue;
								
									}

									//нужно если использовать THREE.Line вместо THREE.LineLoop
									//arrayIntersectPoints.push( arrayIntersectPoints[0] );

									break;
								
								}

/*
								while ( !edge.used ) {
								
									edge.used = true;
									edge = edge.twin.face.edge;
									edge.used = true;
									edge = edge.prev
//									if ( edge.used ) edge = edge.prev;
									if ( getIntersect( edge ) ) {
								
										continue;
								
									}
									edge = edge.prev;
									if ( !edge.twin.face.edge.used && getIntersect( edge ) ) {
								
										continue;
								
									}
//									edge = undefined;
								
								}
*/

							} ) ) {

								return true;

							}
							
							edge = edge.next;

						}
						if ( setEdge() ) return true;
						if ( setEdge() ) return true;
						if ( setEdge() ) return true;

					}
					while ( faceIndex < faces.length ) {

						if ( setFace() ) break;
						faceIndex++;

					}

					if ( arrayIntersectPoints.length > 0 ) {

						MyThree.MyPoints( arrayIntersectPoints, scene, {

							options: options,
							pointsOptions: {

								onReady: function( points ) {

									//points
									
									if ( intersectPoints ) { 

										if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectPoints );
										scene.remove( intersectPoints );

									}
									intersectPoints = points;

									//lines
									
									if ( intersectLine ) { 

										if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectLine );
										scene.remove( intersectLine );

									}
									intersectLine = new THREE.LineLoop( points.geometry, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
									scene.add( intersectLine );

									if ( options.guiSelectPoint ) {

										intersectLine.name = 'intersectLine';
										options.guiSelectPoint.addMesh( intersectLine );

									}

								}

							}

						} );
/*
						intersectLine = new THREE.LineSegments( new THREE.BufferGeometry().setFromPoints( arrayIntersectPoints ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
						scene.add( intersectLine );
						if ( options.guiSelectPoint ) {

							intersectLine.name = 'intersectLine';
							options.guiSelectPoint.addMesh( intersectLine );

						}
*/

					}

				},

			}

		}, {

			camera: {

				position: new THREE.Vector3( 0, 10, 50 ),
				fov: 45,
				near: 1,
				far: 1000,

			},

			//axesHelper: false,
			playerOptions: {

				marks: 110,//Number of scenes of 3D objects animation.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {

				//guiSelectPoint: false,

			},
			scales: {

				display: false,
				posAxesIntersection: new THREE.Vector3( 0, 0, -10 ),
				/*
				text: {

					//textHeight: 0.03,
					//fov: camera.fov,
					precision: 4,

				},
				*/
				x: {

					//zoomMultiplier: 2,
					//offset: 1,
					//name: 'latitude(km.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				y: {

					//name: 'Temperature(degrees Celsius)',
					min: -10,
					max: 10,

				},
				z: {

					//name: 'Radius(m.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				/*
				w: {
					name: 'energy',
					//min: 0,
					//max: 10,
					//min: -1,
					//max: 1,
					//min: 0,//default
					//max: 1,//defaukt
				},
				*/

			},

		} );

	</script>
</body>
</html >
