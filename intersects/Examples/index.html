<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Intersects</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">
</head>
<body>
	<p>
		<a href='https://github.com/anhr' target="_blank">About me</a>
		<!--| <a href="https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane" target="_blank">Three JS - Find all points where a mesh intersects a plane</a>
		| <a href="https://jsfiddle.net/prisoner849/8uxw667m/" target="_blank">Example</a>-->
		| <a href="https://newbedev.com/how-to-detect-collision-in-three-js" target="_blank">How to detect collision in three.js?</a>
	</p>
<!--
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/build/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/examples/js/controls/OrbitControls.js"></script>
-->
	<h1>Intersects.</h1>
<!--
	<button id="pressMe" style="position: absolute;">
		PressMe
	</button>
-->
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		//test for duplicate dat library
		//import { dat } from 'https://raw.githack.com/anhr/commonNodeJS/master/dat/dat.module.js';
		//three.dat = dat;

		import MyThree from '../../myThree/myThree.js';
		//import MyThree from '../../build/myThree.module.js';
		//import MyThree from '../../build/myThree.module.min.js';

		//Error: Access to XMLHttpRequest at 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/build/getShaderMaterialPoints/vertex.c'
		//	from origin 'http://localhost' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
		//import MyThree from 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/myThree.js';

		import { getWorldPosition } from '../../getPosition.js';

		if ( MyThree.default ) MyThree = MyThree.default;
		MyThree.three.THREE = THREE;

		import { ConvexHull } from '../../../../three.js/dev/examples/jsm/math/ConvexHull.js';

		new MyThree( function ( scene, options ) {

			const collidableMeshList = [];

			//Thanks https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane
			const planeGeom = new THREE.PlaneGeometry( 30, 30 );
//			planeGeom.rotateX( -Math.PI / 2 );
			const plane = new THREE.Mesh( planeGeom, new THREE.MeshBasicMaterial( {
				color: "lightgray",
				transparent: true,
				opacity: 0.75,
				side: THREE.DoubleSide
			} ) );
//			plane.position.y = -3.14;
//			plane.rotation.x = Math.PI / 5;
			plane.name = 'plane';
			scene.add( plane );
			collidableMeshList.push( plane );

			const objGeom = new THREE.DodecahedronGeometry( 10, 0 );
			//const objGeom = new THREE.TetrahedronGeometry( 10, 0 );
			//const objGeom = new THREE.BoxGeometry( 10, 10, 10 );
			const obj = new THREE.Mesh( objGeom, new THREE.MeshBasicMaterial( {
					color: "green",
					wireframe: true
				} ) );
			obj.rotation.x = Math.PI / 10;
			obj.rotation.y = Math.PI / 10;
//			obj.position.set( 0, 3.14, 0 );
			scene.add( obj );
			const edges = new THREE.EdgesGeometry( obj.geometry );
/*
			const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
			scene.add( line );


*/
/*
			vertices.push( new THREE.Vector3().copy( edge.head().point ) );
			edge = edge.next;
			vertices.push( new THREE.Vector3().copy( edge.head().point ) );
			edge = edge.next;
			vertices.push( new THREE.Vector3().copy( edge.head().point ) );
			edge = edge.next;
			vertices.push( new THREE.Vector3().copy( edge.head().point ) );
			edge = edge.next;
			vertices.push( new THREE.Vector3().copy( edge.head().point ) );
			const convexHullLine = new THREE.LineSegments( new THREE.BufferGeometry().setFromPoints( vertices ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
			convexHullLine.position.set( 1, 1, 1 );
			scene.add( convexHullLine );
*/
/*
			for ( let i = 0; i < faces.length; i ++ ) {

				const face = faces[ i ];
				let edge = face.edge; // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)

				do {

					vertices.push( edge.head().point );
					edge = edge.next;

				} while ( edge !== face.edge );

			} // build geometry
			const convexHullLine = new THREE.LineSegments( new THREE.BufferGeometry().setFromPoints( vertices ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
			convexHullLine.position.set( 1, 1, 1 );
			scene.add( convexHullLine );
*/

			const positions = edges.attributes.position;

			//guiSelectPoint
			obj.name = 'Dodecahedron';
			if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( obj );

			//Player
			var intersectLine;
			var intersectPoints;
			obj.userData.player = {

				selectPlayScene: function ( t ) {

					obj.position.set( 0, 0, 10 - 30 * t );
					obj.updateMatrix();

					//thanks https://newbedev.com/how-to-detect-collision-in-three-js
					//http://stemkoski.github.io/Three.js/Collision-Detection.html
					const MovingCube = obj;
//					for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++)
//					const positions = MovingCube.geometry.attributes.position;
//					const originPoint = MovingCube.position.clone();
/*
					function getVertex( index ) {

						if ( index >= positions.count ) console.error( 'getVertex index = ' + index + ' positions.count = ' + positions.count );
						const vertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
						vertex.fromBufferAttribute( positions, index );
						const vertexWorld = getWorldPosition( MovingCube, vertex );
//						const globalVertex = vertex.applyMatrix4( MovingCube.matrix );
						return vertexWorld;

					}
*/
/*					
					const vertex0 = getVertex( 0 ),
						vertex1 = getVertex( 1 ),
						vertex2 = getVertex( 2 );
					function line( vertex1, vertex2 ) {

						if ( obj.geometry.index ) {

							//see https://threejs.org/docs/index.html?q=buffer#api/en/core/BufferGeometry.index
							console.error( 'under constraction' );
							return;

						}
						const line = new THREE.Line( new THREE.BufferGeometry().setFromPoints( [vertex1, vertex2] ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
//						line.position.copy( obj.position );

						scene.add( line );

						//guiSelectPoint
						line.name = 'ray';
						if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( line );

					}
					line( vertex0, vertex1 );
					line( vertex1, vertex2 );
					line( vertex2, vertex0 );
*/					
					const arrayIntersectPoints = [];
					if ( intersectLine ) { 

						if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectLine );
						scene.remove( intersectLine );

					}
					if ( intersectPoints ) { 

						if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectPoints );
						scene.remove( intersectPoints );

					}
					
		//			const vertices = [];
					const convexHull = new ConvexHull();
					convexHull.setFromObject( obj );
					const faces = convexHull.faces;
					let faceIndex = 0;

					//в этом массиве хранятся все лучи, которые были проверены на пересечение
					//Это позволяет не провреять на пересечение одни и те же лучи по несколько раз
					const testedRays = [];

					function setFace() {

						const face = faces[faceIndex];
						let edge = face.edge;
						function setEdge() {

/*
							function getVertex( index ) {

								if ( index >= positions.count ) console.error( 'getVertex index = ' + index + ' positions.count = ' + positions.count );
								const vertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
								vertex.fromBufferAttribute( positions, index );
								return getWorldPosition( MovingCube, vertex );

							}
							const globalOriginPoint = getVertex( vertexIndex ),
								globalVertex = getVertex( vertexIndex + 1 ),
								directionVector = globalVertex.clone().sub( globalOriginPoint );
*/
/*
							function getVertex( vertex ) {

								return vertex;
//								return getWorldPosition( MovingCube, vertex );
//								return new THREE.Vector3( vertex.x + 1, vertex.y + 1, vertex.z + 1 );

							}
							const globalOriginPoint = getVertex( edge.head().point ),
								globalVertex = getVertex( edge.next.head().point ),
								directionVector = globalVertex.clone().sub( globalOriginPoint );
*/
//							if ( !Object.is(edge.usedWith, edge.next) )
							for( var i = 0; i < testedRays.length; i++ ) {

								const testedRay = testedRays[i];
								if ( Object.is( testedRay[1], edge ) && Object.is( testedRay[2], edge.next ) ) {

									edge = edge.next;
									return;

								}

							}

							const globalOriginPoint = edge.head().point,
								globalVertex = edge.next.head().point,
								directionVector = globalVertex.clone().sub( globalOriginPoint );

							const ray = new THREE.Raycaster( globalOriginPoint, directionVector.clone().normalize() );
							const collisionResults = ray.intersectObjects( collidableMeshList );
							if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
								arrayIntersectPoints.push( new THREE.Vector3().copy(collisionResults[0].point) );
/*
							const line = new THREE.Line( new THREE.BufferGeometry().setFromPoints( [ globalOriginPoint, globalVertex ] ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
//							line.position.set( 1, 1, 1 );
							scene.add( line );
*/
							testedRays.push( [ edge, edge.next ] );
							edge = edge.next;

						}
						setEdge();
						setEdge();
						setEdge();

					}
					while ( faceIndex < faces.length ) {

						setFace();
						faceIndex++;

					}

					for (var vertexIndex = 0; vertexIndex < positions.count; vertexIndex++)
					{		
/*
						var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
						var globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
						var directionVector = globalVertex.sub( MovingCube.position );
		
						var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
						var collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
							appendText(" Hit ");
*/
/*
						const localVertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
						localVertex.fromBufferAttribute( positions, vertexIndex );
*/
/*
						const originPoint = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
						originPoint.fromBufferAttribute( positions, vertexIndex );
						const globalOriginPoint = originPoint.applyMatrix4( MovingCube.matrix );

						const localVertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
						localVertex.fromBufferAttribute( positions, vertexIndex + 1 );
						const globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
*/
						/*
						function getVertex( index ) {

							if ( index >= positions.count ) console.error( 'getVertex index = ' + index + ' positions.count = ' + positions.count );
							const vertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
							vertex.fromBufferAttribute( positions, index );
							return getWorldPosition( MovingCube, vertex );
//							return vertex.applyMatrix4( MovingCube.matrix );

						}
						const globalOriginPoint = getVertex( vertexIndex ),
//							globalVertex = getVertex( vertexIndex + positions.itemSize ),
							globalVertex = getVertex( vertexIndex + 1 ),
							directionVector = globalVertex.clone().sub( globalOriginPoint );
						*/
/*
//if ( vertexIndex === 0 )
{

	const line = new THREE.Line( new THREE.BufferGeometry().setFromPoints( [globalOriginPoint, globalVertex] ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
	//line.position.copy( obj.position );
	scene.add( line );
	//scene.remove( line );

}
*/
						/*
						const ray = new THREE.Raycaster( globalOriginPoint, directionVector.clone().normalize() );
						const collisionResults = ray.intersectObjects( collidableMeshList );
						*/
						/*
						if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
							arrayIntersectPoints.push( collisionResults[0].point );
						*/
/*
						const originPoint = getVertex( vertexIndex );
						const collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {

							console.log( " Hit " );
//							appendText( " Hit " );

						}
*/
/*
						const directionVector = getVertex( vertexIndex + 1 );
						const ray = new THREE.Raycaster( originPoint, directionVector );
						const collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < originPoint.distanceTo(directionVector) ) {

							arrayIntersectPoints.push( collisionResults[0].point );

						}
*/
/*
						const globalOriginPoint = getVertex( vertexIndex );
						const globalVertex = getVertex( vertexIndex + 1 );
						const directionVector = globalVertex.sub( globalOriginPoint );
		
						const ray = new THREE.Raycaster( globalOriginPoint, directionVector.clone().normalize() );
						const collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
							arrayIntersectPoints.push( collisionResults[0].point );
*/

					}
					if ( arrayIntersectPoints.length > 0 ) {

						MyThree.MyPoints( arrayIntersectPoints, scene, {

							options: options,
							pointsOptions: {

								onReady: function( points ) {

									if ( intersectPoints ) { 

										if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectPoints );
										scene.remove( intersectPoints );

									}
									intersectPoints = points;

								}

							}

						} );
						intersectLine = new THREE.LineSegments( new THREE.BufferGeometry().setFromPoints( arrayIntersectPoints ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
						scene.add( intersectLine );
						if ( options.guiSelectPoint ) {

							intersectLine.name = 'intersectLine';
							options.guiSelectPoint.addMesh( intersectLine );

						}

					}

				},

			}

		}, {

			camera: {

				position: new THREE.Vector3( 0, 10, 50 ),
				fov: 45,
				near: 1,
				far: 1000,

			},

			axesHelper: false,
			playerOptions: {

				marks: 110,//Number of scenes of 3D objects animation.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {

				//guiSelectPoint: false,

			},
			scales: {

				//display: true,
				/*
				text: {

					//textHeight: 0.03,
					//fov: camera.fov,
					precision: 4,

				},
				*/
				x: {

					//zoomMultiplier: 2,
					//offset: 1,
					//name: 'latitude(km.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				y: {

					//name: 'Temperature(degrees Celsius)',
					min: -10,
					max: 10,

				},
				z: {

					//name: 'Radius(m.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				/*
				w: {
					name: 'energy',
					//min: 0,
					//max: 10,
					//min: -1,
					//max: 1,
					//min: 0,//default
					//max: 1,//defaukt
				},
				*/

			},

		} );

	</script>
</body>
</html >
