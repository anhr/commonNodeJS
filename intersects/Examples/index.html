<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Intersects</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">
</head>
<body>
	<p>
		<a href='https://github.com/anhr' target="_blank">About me</a>
		<!--| <a href="https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane" target="_blank">Three JS - Find all points where a mesh intersects a plane</a>
		| <a href="https://jsfiddle.net/prisoner849/8uxw667m/" target="_blank">Example</a>-->
		| <a href="https://newbedev.com/how-to-detect-collision-in-three-js" target="_blank">How to detect collision in three.js?</a>
	</p>
<!--
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/build/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/examples/js/controls/OrbitControls.js"></script>
-->
	<h1>Intersects.</h1>
<!--
	<button id="pressMe" style="position: absolute;">
		PressMe
	</button>
-->
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		//test for duplicate dat library
		//import { dat } from 'https://raw.githack.com/anhr/commonNodeJS/master/dat/dat.module.js';
		//three.dat = dat;

		import MyThree from '../../myThree/myThree.js';
		//import MyThree from '../../build/myThree.module.js';
		//import MyThree from '../../build/myThree.module.min.js';

		//Error: Access to XMLHttpRequest at 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/build/getShaderMaterialPoints/vertex.c'
		//	from origin 'http://localhost' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
		//import MyThree from 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/myThree.js';

		import { getWorldPosition } from '../../getPosition.js';

		if ( MyThree.default ) MyThree = MyThree.default;
		MyThree.three.THREE = THREE;

//		import { ConvexHull } from '../../../../three.js/dev/examples/jsm/math/ConvexHull.js';

		new MyThree( function ( scene, options ) {

			const collidableMeshList = [];

			//Thanks https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane
			const planeGeom = new THREE.PlaneGeometry( 30, 30 );
//			planeGeom.rotateX( -Math.PI / 2 );
			const plane = new THREE.Mesh( planeGeom, new THREE.MeshBasicMaterial( {
				color: "lightgray",
				transparent: true,
				opacity: 0.75,
				side: THREE.DoubleSide
			} ) );
//			plane.position.y = -3.14;
//			plane.rotation.x = Math.PI / 5;
			plane.name = 'plane';
			scene.add( plane );
			collidableMeshList.push( plane );

//			const objGeom = new THREE.DodecahedronGeometry( 10, 0 );
//			const objGeom = new THREE.TetrahedronGeometry( 10, 0 );
			const objGeom = new THREE.BoxGeometry( 10, 10, 10 );
			const obj = new THREE.Mesh( objGeom, new THREE.MeshBasicMaterial( {
					color: "green",
					wireframe: true
				} ) );
			//obj.rotation.z = Math.PI / 10;
//			obj.position.set( 0, 3.14, 0 );
			scene.add( obj );
/*
			const edges = new THREE.EdgesGeometry( obj.geometry );
			const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
			scene.add( line );


			const convexHull = new ConvexHull();
			convexHull.setFromObject( obj );
*/
			//guiSelectPoint
			obj.name = 'Dodecahedron';
			if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( obj );

			//Player
			var intersectLine;
			obj.userData.player = {

				selectPlayScene: function ( t ) {

					//obj.position.set( 0, 10 - 30 * t, 0 );
					obj.position.set( 0, 0, 10 - 30 * t );
					obj.updateMatrix();

					//thanks https://newbedev.com/how-to-detect-collision-in-three-js
					//http://stemkoski.github.io/Three.js/Collision-Detection.html
					const MovingCube = obj;
//					for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++)
					const positions = MovingCube.geometry.attributes.position;
//					const originPoint = MovingCube.position.clone();
/*
					function getVertex( index ) {

						if ( index >= positions.count ) console.error( 'getVertex index = ' + index + ' positions.count = ' + positions.count );
						const vertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
						vertex.fromBufferAttribute( positions, index );
						const vertexWorld = getWorldPosition( MovingCube, vertex );
//						const globalVertex = vertex.applyMatrix4( MovingCube.matrix );
						return vertexWorld;

					}
*/
/*					
					const vertex0 = getVertex( 0 ),
						vertex1 = getVertex( 1 ),
						vertex2 = getVertex( 2 );
					function line( vertex1, vertex2 ) {

						if ( obj.geometry.index ) {

							//see https://threejs.org/docs/index.html?q=buffer#api/en/core/BufferGeometry.index
							console.error( 'under constraction' );
							return;

						}
						const line = new THREE.Line( new THREE.BufferGeometry().setFromPoints( [vertex1, vertex2] ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
//						line.position.copy( obj.position );

						scene.add( line );

						//guiSelectPoint
						line.name = 'ray';
						if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( line );

					}
					line( vertex0, vertex1 );
					line( vertex1, vertex2 );
					line( vertex2, vertex0 );
*/					
					const arrayIntersectPoints = [];
					if ( intersectLine ) scene.remove( intersectLine );
					for (var vertexIndex = 0; vertexIndex < positions.count / positions.itemSize ; vertexIndex++) {		
/*
						var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
						var globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
						var directionVector = globalVertex.sub( MovingCube.position );
		
						var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
						var collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
							appendText(" Hit ");
*/
/*
						const localVertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
						localVertex.fromBufferAttribute( positions, vertexIndex );
*/
/*
						const originPoint = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
						originPoint.fromBufferAttribute( positions, vertexIndex );
						const globalOriginPoint = originPoint.applyMatrix4( MovingCube.matrix );

						const localVertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
						localVertex.fromBufferAttribute( positions, vertexIndex + 1 );
						const globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
*/
						function getVertex( index ) {

							if ( index >= positions.count ) console.error( 'getVertex index = ' + index + ' positions.count = ' + positions.count );
							const vertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
							vertex.fromBufferAttribute( positions, index );
							return vertex.applyMatrix4( MovingCube.matrix );

						}
						const globalOriginPoint = getVertex( vertexIndex ),
							directionVector = getVertex( vertexIndex + 1 ).sub( globalOriginPoint );
		
						const ray = new THREE.Raycaster( globalOriginPoint, directionVector.clone().normalize() );
						const collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
							arrayIntersectPoints.push( collisionResults[0].point );
/*
						const originPoint = getVertex( vertexIndex );
						const collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {

							console.log( " Hit " );
//							appendText( " Hit " );

						}
*/
/*
						const directionVector = getVertex( vertexIndex + 1 );
						const ray = new THREE.Raycaster( originPoint, directionVector );
						const collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < originPoint.distanceTo(directionVector) ) {

							arrayIntersectPoints.push( collisionResults[0].point );

						}
*/
/*
						const globalOriginPoint = getVertex( vertexIndex );
						const globalVertex = getVertex( vertexIndex + 1 );
						const directionVector = globalVertex.sub( globalOriginPoint );
		
						const ray = new THREE.Raycaster( globalOriginPoint, directionVector.clone().normalize() );
						const collisionResults = ray.intersectObjects( collidableMeshList );
						if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
							arrayIntersectPoints.push( collisionResults[0].point );
*/

					}
					if ( arrayIntersectPoints.length > 0 ) {

						MyThree.MyPoints( arrayIntersectPoints, scene, {

							options: options,
							pointsOptions: {

								onReady: function() {

									console.log('111');

								}

							}

						} );
/*						
						intersectLine = new THREE.LineSegments( new THREE.BufferGeometry().setFromPoints( arrayIntersectPoints ), new THREE.LineBasicMaterial( { color: 0xffffff } ) );
						scene.add( intersectLine );
*/						

					}

				},

			}

		}, {

			camera: {

				position: new THREE.Vector3( 0, 10, 50 ),
				fov: 45,
				near: 1,
				far: 1000,

			},

			axesHelper: false,
			playerOptions: {

				marks: 110,//Number of scenes of 3D objects animation.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {

				//guiSelectPoint: false,

			},
			scales: {

				//display: true,
				/*
				text: {

					//textHeight: 0.03,
					//fov: camera.fov,
					precision: 4,

				},
				*/
				x: {

					//zoomMultiplier: 2,
					//offset: 1,
					//name: 'latitude(km.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				y: {

					//name: 'Temperature(degrees Celsius)',
					min: -10,
					max: 10,

				},
				z: {

					//name: 'Radius(m.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				/*
				w: {
					name: 'energy',
					//min: 0,
					//max: 10,
					//min: -1,
					//max: 1,
					//min: 0,//default
					//max: 1,//defaukt
				},
				*/

			},

		} );

	</script>
</body>
</html >
