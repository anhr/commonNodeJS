<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: WebGPU.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: WebGPU.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module WebGPU
 * @description [WebGPU]{@link https://gpuweb.github.io/gpuweb/}. GPU Compute on the web.
 * @see [Get started with GPU Compute on the web]{@link https://web.dev/gpu-compute/}
 *
 * @author [Andrej Hristoliubov]{@link https://github.com/anhr}
 *
 * @copyright 2011 Data Arts Team, Google Creative Lab
 *
 * @license under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
*/

//import loadScript from '../loadScriptNodeJS/loadScript.js'
import loadFile from '../loadFileNodeJS/loadFile.js'

class WebGPU {

	/**
	 * [WebGPU]{@link https://gpuweb.github.io/gpuweb/}. GPU Compute on the web.
	 * @param {object} settings The following settings are available
	 * @param {object} [settings.input] Input values for WebGPU. The following Input values are available:
	 * @param {Array} [settings.input.matrices] Array of input matrices. See [Shader programming]{@link  https://web.dev/gpu-compute/#shader-programming}.
	 * &lt;pre>
	 * Example:
	 * &lt;b>[
	 *   [
	 *      [1, 2, 3, 4],
	 *      [5, 6, 7, 8]
	 *   ],
	 *   [
	 *      [1, 2],
	 *      [3, 4],
	 *      [5, 6],
	 *      [7, 8],
	 *   
	 *]&lt;/b>
	 * &lt;/pre>
	 * @param {object} [settings.input.params] input parameters list
	 * @param {object} [settings.input.params.type=Uint32Array] type of the input parameters list. Allowed &lt;b>Float32Array&lt;/b> and &lt;b>Uint32Array&lt;/b>.
	 * &lt;pre>
	 * Example:
	 * &lt;b>params: {
	 *   type: Float32Array,
	 *   c: 0.04,
	 *   count: 10,
	 *},&lt;/b>
	 * &lt;/pre>
	 * @param {Function} [settings.out] &lt;b>function(out, i)&lt;/b> called when output data is ready.
	 * &lt;pre>
	 * &lt;b>out&lt;/b> argument is array of output data. See [ArrayBuffer]{@link https://webidl.spec.whatwg.org/#idl-ArrayBuffer}.
	 * &lt;b>i&lt;/b> argument is index of the &lt;b>settings.results&lt;/b> array item.
	 * &lt;/pre>
	 * @param {Number} [settings.resultMatrixBufferSize] The size of the output buffer in bytes.
	 * @param {Array} [settings.workgroupCount=[1]] For dispatch work to be performed with the current GPUComputePipeline.
	 * &lt;pre>
	 * See [dispatchWorkgroups]{@link https://gpuweb.github.io/gpuweb/#dom-gpucomputepassencoder-dispatchworkgroups} of [GPUComputePipeline]{@link https://gpuweb.github.io/gpuweb/#gpucomputepipeline}.
	 * &lt;b>workgroupCount[0]&lt;/b> is &lt;b>workgroupCountX&lt;/b>
	 * &lt;b>workgroupCount[1]&lt;/b> is &lt;b>workgroupCountY&lt;/b>
	 * &lt;b>workgroupCount[2]&lt;/b> is &lt;b>workgroupCountZ&lt;/b>
	 * &lt;/pre>
	 * @param {USVString} [settings.shaderCode] The [WGSL]{@link https://gpuweb.github.io/gpuweb/wgsl/} source code for the shader module. See [USVString]{@link https://webidl.spec.whatwg.org/#idl-USVString}.
	 * @param {String} [settings.shaderCodeFile] The name of the file with [WGSL]{@link https://gpuweb.github.io/gpuweb/wgsl/} source code.
	 * Have effect only if the &lt;b>shaderCode&lt;/b> undefined.
	 * @param {Function} [settings.shaderCodeText] &lt;b>function(text)&lt;/b> called after downloading of the shader code from file and before creating of the Shader Module.
	 * See [createShaderModule(descriptor)]{@link https://gpuweb.github.io/gpuweb/#dom-gpudevice-createshadermodule}
	 * &lt;pre>
	 * The &lt;b>text&lt;/b> argument is text of the shader code. You can modify shader code and return new text.
	 * Example:
	 * &lt;b>shaderCodeText: function (text) {
	 *   return text.replace( '%debugCount', 1 );
	 *},&lt;/b>
	 * &lt;/pre>
	 */
	constructor(settings) {

		let gpuDevice = null;

		//https://gpuweb.github.io/gpuweb/#initialization-examples
		async function initializeWebGPU() {

			// Check to ensure the user agent supports WebGPU.
//			if (!('gpu' in navigator))
			if ( !WebGPU.isSupportWebGPU() )
			{
				console.error("WebGPU: User agent doesn't support WebGPU. WebGPU is available for now in Chrome Canary https://www.google.com/intl/ru/chrome/canary/ on desktop behind an experimental flag. You can enable it at chrome://flags/#enable-unsafe-webgpu. The API is constantly changing and currently unsafe. As GPU sandboxing isn't implemented yet for the WebGPU API, it is possible to read GPU data for other processes! Don't browse the web with it enabled.");
				return;
			}

			// Request an adapter.
			const gpuAdapter = await navigator.gpu.requestAdapter();

			// requestAdapter may resolve with null if no suitable adapters are found.
			if (!gpuAdapter) {
				console.error('No WebGPU adapters found.');
				return false;
			}

			// Request a device.
			// Note that the promise will reject if invalid options are passed to the optional
			// dictionary. To avoid the promise rejecting always check any features and limits
			// against the adapters features and limits prior to calling requestDevice().
			gpuDevice = await gpuAdapter.requestDevice();

			// requestDevice will never return null, but if a valid device request can't be
			// fulfilled for some reason it may resolve to a device which has already been lost.
			// Additionally, devices can be lost at any time after creation for a variety of reasons
			// (ie: browser resource management, driver updates), so it's a good idea to always
			// handle lost devices gracefully.
			gpuDevice.lost.then((info) => {
				console.error(`WebGPU device was lost: ${info.message}`);

				gpuDevice = null;

				// Many causes for lost devices are transient, so applications should try getting a
				// new device once a previous one has been lost unless the loss was caused by the
				// application intentionally destroying the device. Note that any WebGPU resources
				// created with the previous device (buffers, textures, etc) will need to be
				// re-created with the new one.
				if (info.reason != 'destroyed') {
					initializeWebGPU();
				}
			});

			onWebGPUInitialized();

//			return true;

		}

		function onWebGPUInitialized() {

			const input = settings.input;
			let bindGroupLayout, bindGroup,
				paramBuffer;
			if (input) {

				if (input.matrices)
					input.matrices.forEach(inputMatrix => {

						//create matrix
						const matrix = [
							inputMatrix.length,//rows
							inputMatrix[0].length,//columns
						];
						inputMatrix.forEach(row => row.forEach(value => matrix.push(value)));
						inputMatrix.matrix = new Float32Array(matrix);

						inputMatrix.gpuBuffer = gpuDevice.createBuffer({
							mappedAtCreation: true,
							size: inputMatrix.matrix.byteLength,
							usage: GPUBufferUsage.STORAGE
						});
						new Float32Array(inputMatrix.gpuBuffer.getMappedRange()).set(inputMatrix.matrix);
						inputMatrix.gpuBuffer.unmap();

					});

				//params

				if (input.params) {

					let paramBufferSize = 0, data = [],
						dataType;//true - Uint32Array, false - Float32Array
					input.params.type ||= Uint32Array;
					Object.keys(input.params).forEach( function (key) {
		
						if (key === 'type') return;
						const param = input.params[key];
						if (typeof param === "number") {

							function isInt(n) { return n % 1 === 0; }
							const isInteger = isInt(param);
							if(
//								(isInteger &amp;&amp; (input.params.type === Float32Array)) ||
								(!isInteger &amp;&amp; (input.params.type === Uint32Array))
							) {

								console.error('WebGPU: Invalid ' + key + ' = ' + param + ' parameter type. ' + (input.params.type === Uint32Array ? 'Integer' : 'Float' ) + ' is allowed only.' );
								return;
								
							}
							paramBufferSize += input.params.type.BYTES_PER_ELEMENT;
							data.push(param);
/*							
							function isInt(n) { return n % 1 === 0; }
							const arrayType = isInt(param);
							if ((dataType != undefined ) &amp;&amp; (dataType != arrayType) ) {

								console.error('WebGPU: different types of parameters is not allowed');
								return;
								
							}
							else dataType = arrayType;
							if (arrayType)
								paramBufferSize += Uint32Array.BYTES_PER_ELEMENT;
							else paramBufferSize += Float32Array.BYTES_PER_ELEMENT;
*/							

						} else console.error('WebGPU: Invalid param: ' + param);
					} );
/*					
					console.warn('сейчас возможен только один параметр с плавающей точкой')
					const paramBufferSize = 1 * Float32Array.BYTES_PER_ELEMENT;
*/	 
					paramBuffer = gpuDevice.createBuffer({

						size: paramBufferSize,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,

					});
					gpuDevice.queue.writeBuffer(

						paramBuffer,
						0,
						new input.params.type(data)
					);

				}

			}

			// Result Matrix
			if (settings.results)
				settings.results.forEach(resultMatrix => {

					resultMatrix.type ||= Float32Array;
					const bufferSize = resultMatrix.type.BYTES_PER_ELEMENT * resultMatrix.bufferSize;
					if (!bufferSize) {

						console.error('WebGPU: bufferSize key is not defined in the settings.results item.');
						return;
						
					}
					resultMatrix.buffer = gpuDevice.createBuffer({
	
						size: bufferSize,
						usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
	
					});

				});
/*
			let resultMatrixBuffer, resultMatrixBufferSize;
			if (settings.resultMatrixBufferSize !== undefined) {

				//resultMatrixBufferSize = Float32Array.BYTES_PER_ELEMENT * (2 + settings.resultMatrixBufferSize);
				resultMatrixBufferSize = Float32Array.BYTES_PER_ELEMENT * settings.resultMatrixBufferSize;
				resultMatrixBuffer = gpuDevice.createBuffer({

					size: resultMatrixBufferSize,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC

				});

			}
*/   

			// Bind group layout and bind group

			const entriesBindGroupLayout = [], entriesBindGroup = [];
			let binding = 0;
			if (input &amp;&amp; input.matrices) for (var i = 0; i &lt; input.matrices.length; i++) {

				entriesBindGroupLayout.push({

					binding: binding,//i,
					visibility: GPUShaderStage.COMPUTE,
					buffer: { type: "read-only-storage" }

				});
				entriesBindGroup.push({

					binding: binding,//i,
					resource: { buffer: input.matrices[i].gpuBuffer }

				});
				binding++;

			}
			if (settings.results) settings.results.forEach(resultMatrix => {
				
				entriesBindGroupLayout.push({
	
					binding: binding,//input.length,
					visibility: GPUShaderStage.COMPUTE,
					buffer: { type: "storage" }
	
				});
				entriesBindGroup.push({
	
					binding: binding,//input.length,
					resource: { buffer: resultMatrix.buffer }
	
				});
				binding++;

			});
/*				
			if (resultMatrixBuffer) {
				
				entriesBindGroupLayout.push({
	
					binding: binding,//input.length,
					visibility: GPUShaderStage.COMPUTE,
					buffer: { type: "storage" }
	
				});
				entriesBindGroup.push({
	
					binding: binding,//input.length,
					resource: { buffer: resultMatrixBuffer }
	
				});
				binding++;

			}
*/			
			if (paramBuffer) {

				//				const binding = input.length + 2;
				entriesBindGroupLayout.push({

					binding: binding,
					visibility: GPUShaderStage.COMPUTE,
					buffer: { type: "uniform" }

				});
				entriesBindGroup.push({
					binding: binding,
					resource: { buffer: paramBuffer, }
				});
				binding++;

			}


			bindGroupLayout = gpuDevice.createBindGroupLayout({ entries: entriesBindGroupLayout });

			bindGroup = gpuDevice.createBindGroup({

				layout: bindGroupLayout,
				entries: entriesBindGroup

			});

			// Compute shader code

			const shaderCode = settings.shaderCode;
			if (shaderCode)
				onLoad(shaderCode)
			else loadFile.async(settings.shaderCodeFile, { onload: function (shaderCode, url ) { onLoad(shaderCode) } } );
			async function onLoad(shaderCode) {

				if (settings.shaderCodeText) shaderCode = settings.shaderCodeText(shaderCode);
				const shaderModule = gpuDevice.createShaderModule({ code: shaderCode });

				// Pipeline setup

				const computePipeline = gpuDevice.createComputePipeline({
					layout: gpuDevice.createPipelineLayout({
						bindGroupLayouts: [bindGroupLayout]
					}),
					compute: {
						module: shaderModule,
						entryPoint: "main"
					}
				});

				// Commands submission

				//https://gpuweb.github.io/gpuweb/#dom-gpudevice-createcommandencoder
				const commandEncoder = gpuDevice.createCommandEncoder();

				const passEncoder = commandEncoder.beginComputePass();
				passEncoder.setPipeline(computePipeline);
				passEncoder.setBindGroup(0, bindGroup);//set @group(0) in the shading code

				let workgroupCount = [];
				if (input &amp;&amp; input.matrices)
					input.matrices.forEach((item, i) => workgroupCount.push(Math.ceil(item.matrix[i] / 8)));
				else {
					
//					console.log('under constaction')
					if (settings.workgroupCount) workgroupCount = settings.workgroupCount;
					else {
						
						workgroupCount.push(1);
	//					workgroupCount.push(1);

					}

				}
				const workgroupCountX = workgroupCount[0], workgroupCountY = workgroupCount[1], workgroupCountZ = workgroupCount[3];

				//https://gpuweb.github.io/gpuweb/#dom-gpucomputepassencoder-dispatchworkgroups
				passEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);
				passEncoder.end();

				if (settings.results)
					settings.results.forEach(resultMatrix => {
						
						// Get a GPU buffer for reading in an unmapped state.
						resultMatrix.gpuReadBuffer = gpuDevice.createBuffer({
							size: resultMatrix.buffer.size,
							usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
						});
		
						// Encode commands for copying buffer to buffer.
						commandEncoder.copyBufferToBuffer(
							resultMatrix.buffer, // source buffer
							0, // source offset
							resultMatrix.gpuReadBuffer, // destination buffer
							0, // destination offset
							resultMatrix.buffer.size // size
						);
						
					});
/*				
				let gpuReadBuffer;
				if (resultMatrixBuffer) {
					
					// Get a GPU buffer for reading in an unmapped state.
					gpuReadBuffer = gpuDevice.createBuffer({
						size: resultMatrixBufferSize,
						usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
					});
	
					// Encode commands for copying buffer to buffer.
					commandEncoder.copyBufferToBuffer(
						resultMatrixBuffer, // source buffer
						0, // source offset
						gpuReadBuffer, // destination buffer
						0, // destination offset
						resultMatrixBufferSize // size
					);

				}
*/				

				// Submit GPU commands.
				const gpuCommands = commandEncoder.finish();
				gpuDevice.queue.submit([gpuCommands]);

				// Read buffer.
				if (settings.results) {
					
//					settings.results.forEach(resultMatrix => 
					for (let i = 0; i &lt; settings.results.length; i++)
					{

						const resultMatrix = settings.results[i];
						await resultMatrix.gpuReadBuffer.mapAsync(GPUMapMode.READ);
						if (settings.out) settings.out(resultMatrix.gpuReadBuffer.getMappedRange(), i);
						
					}

				}
/*				
				if (gpuReadBuffer) {
					
					await gpuReadBuffer.mapAsync(GPUMapMode.READ);
					const arrayBuffer = gpuReadBuffer.getMappedRange();
					if (settings.out) settings.out(arrayBuffer);

				}
*/				

			}

		}

		initializeWebGPU();

	}

}

/**
 * @returns true if your browser supports [WebGPU]{@link https://gpuweb.github.io/gpuweb/}.
 * WebGPU is available for now in [Chrome Canary]{@link https://www.google.com/intl/ru/chrome/canary/} on desktop behind an experimental flag.
 * You can enable it at &lt;b>chrome://flags/#enable-unsafe-webgpu&lt;/b>.
 * The API is constantly changing and currently unsafe.
 * As GPU sandboxing isn't implemented yet for the WebGPU API, it is possible to read GPU data for other processes! Don't browse the web with it enabled.
 * */
WebGPU.isSupportWebGPU = function () { return 'gpu' in navigator; }

/**
 * Converts the &lt;b>out&lt;/b> array to matrix.
 * @param {ArrayBuffer} out out [ArrayBuffer]{@link https://webidl.spec.whatwg.org/#idl-ArrayBuffer}. See &lt;b>settings.out&lt;/b> param of &lt;b>WebGPU&lt;/b> class for details.
 * @param {object} [settings={}] The following settings are available
 * @param {object} [settings.type=Float32Array] type of the &lt;b>out&lt;/b> ArrayBuffer. Allowed &lt;b>Float32Array&lt;/b> and &lt;b>Uint32Array&lt;/b>.
 * @param {Array} [settings.size] size of result matrix.
 * &lt;pre>
 * &lt;b>size.length&lt;/b> is dimension of result matrix.
 * &lt;b>size[0]&lt;/b> is first dimension.
 * ---
 * &lt;b>size[i]&lt;/b> is next dimension.
 * ---
 * &lt;b>size[size.length - 1]&lt;/b> is last dimension.
 * Esample:
 * &lt;b>[
 *   10,//rows count
 *   2//columns count
 * ]
 * &lt;/b>
 * creates two dimesional matrix with 10 rows and 2 columns.
 * 
 * If &lt;b>size&lt;/b> is undefined, then dimension and size of result matrix must be defined in the header of the out:
 * First item of the out is dimension of result matrix.
 * Second item of the out is first dimension.
 * ---
 * Next item of the out is next dimension.
 * ---
 * dimension item of the out is last dimension.
 * Example:
 * &lt;b>
 * const array = new Float32Array(out);
 * &lt;/b>
 * if
 * &lt;b>
 * array[0] = 2//two dimesional matrix
 * array[1] = 10//rows count
 * array[2] = 2//columns count
 * &lt;/b>
 * then result matrix is two dimensional matrix with ten rows and two columns.
 * &lt;/pre>
 * @param {Function} [settings.push] &lt;b>function(item)&lt;/b>. &lt;b>item&lt;/b> - new matrix item.
 * Called when a new matrix item is ready. You can add a new item to your matrix.
 * The result matrix is empty if you have added &lt;b>push&lt;/b> to the &lt;b>setting&lt;/b> and &lt;b>settings.returnMatrix&lt;/b> is not true.
 * @param {boolean} [settings.returnMatrix] true - result matrix is not empty. Has effect only if &lt;b>settings.push&lt;/b> is defined.
 * @returns result matrix.
 */
WebGPU.out2Matrix = function(out, settings={}) {
	
//	const array = out.type ? new out.type(out) : new Float32Array(out),
	const array = settings.type ? new settings.type(out) : new Float32Array(out),
		matrix = [];
	let valueIndex,
		dimension;//Dimension of resultMatrix
	const size = settings.size;
	if (size){

		dimension = size.length;
		valueIndex = 0;
		
	} else {
		
		dimension = array[0];
		valueIndex = dimension + 1;

	}
	function iteration (level, matrixLevel) {

		if (level > dimension) return;
		const levelCount = size ? size[level -1] : array[level];
		for (let i = 0; i &lt; levelCount; i++){

			const matrixNextLevel = [];
			if (level === (dimension - 1)) {

				const length = size ? size[dimension - 1] : array[dimension];
				for (let j = 0; j &lt; length; j++) {
					
					matrixNextLevel.push(array[valueIndex]);
					valueIndex++;

				}
				if (settings.push) settings.push(matrixNextLevel);
				
			} else {
				
				const nextlLevel = level + 1;
				iteration (nextlLevel, matrixNextLevel);

			}
			if (!settings.push || settings.returnMatrix) matrixLevel.push(matrixNextLevel);

		}
		
	}
	iteration (1, matrix);
	return matrix;

}

export default WebGPU;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-WebGPU.html">WebGPU</a></li></ul><h3>Classes</h3><ul><li><a href="module-WebGPU-WebGPU.html">WebGPU</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sat Oct 08 2022 07:37:11 GMT+0700 (Красноярск, стандартное время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
