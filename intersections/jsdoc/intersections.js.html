<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: intersections.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: intersections.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>﻿/**
 * @module Intersections
 * @description Creates an intersection line for graphic objects.
 * @author [Andrej Hristoliubov]{@link https://anhr.github.io/AboutMe/}
 *
 * @copyright 2011 Data Arts Team, Google Creative Lab
 *
 * @license under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
*/

import three from '../three.js'
//import MyThree from '../myThree/myThree.js';
import MyPoints from '../myPoints/myPoints.js';
import { SpriteText } from '../SpriteText/SpriteText.js'

/**
 * Creates an array of graphic object [faces]{@link https://threejs.org/docs/index.html?q=fac#examples/en/math/convexhull/Face}.
 * @param {THREE.Mesh} object You can see an array of faces in &lt;b>object.userData.intersections.faces&lt;/b> after creating of class.
 * See [Mech]{@link https://threejs.org/docs/index.html#api/en/objects/Mesh}.
 * @param {array} collidableMeshList Array of meshes, which intersects with &lt;b>object&lt;/b>.
 */
function Faces( object, collidableMeshList ) {

	const THREE = three.THREE, options = three.options, scene = three.group;
	let faces;
	object.userData.intersections = {};
	const positions = object.geometry.attributes.position;

	if ( object.geometry.index ) {

		//ищщем точки, которые совпадают или почти совпадают с небольшой погрешностью
		//что бы у них был одинаковый индекс
		for ( let i = 1; i &lt; object.geometry.index.count; i++ ) {

			const point1 = new THREE.Vector3().fromBufferAttribute( positions, object.geometry.index.array[i] );
			/*
			console.log( 'index: ' + object.geometry.index.array[i] );
			console.log( point1 );
			*/
			for ( let j = i - 1; j >= 0; j-- ) {

				const point2 = new THREE.Vector3().fromBufferAttribute( positions, object.geometry.index.array[j] );

				// @returns
				// 	0 координаты совпадают
				// 	1 коодинаты с маленьким отклонением
				// 	4 коодинаты с большим отклонением
				function Delta( a, b ) {

					const d = Math.abs( a - b )
					if ( d === 0 ) return 0;
					//								if ( ( d > 0 ) &amp;&amp; ( d &lt;= 7.347880586115415e-16 ) ) return 1;
					if ( ( d > 0 ) &amp;&amp; ( d &lt;= 3.1840817637818772e-15 ) ) return 1;
					//								if ( ( d > 0 ) &amp;&amp; ( d &lt;= 3.e-10 ) ) return 1;
					return 4;

				}
				const res = Delta( point2.x, point1.x ) + Delta( point2.y, point1.y ) + Delta( point2.z, point1.z );
				//0 координаты совпадают
				//1,2,3 одна, две или три коодинаты с маленьким отклонением. Остальные совпадают.
				//4 есть хоть одна коодината с большим отклонением
				//if ( ( res > 0 ) &amp;&amp; ( res &lt; 4 ) )
				if ( res &lt; 4 ) {

					object.geometry.index.array[i] = object.geometry.index.array[j];
					break;

				}

			}

		}

	} else {

		const array = []
		for ( var i = 0; i &lt; positions.count; i++ )
			array.push( i );
		object.geometry.index = new THREE.Uint16BufferAttribute( array, 1 );

	}

	/**
	 * @description Marks the selected face in a different color.
	 * @param {Edge} edge &lt;b>face.edge&lt;/b> First edge of selected face.
	 * @param {number} lineFaceIndex &lt;a href="./module-Intersections-Intersections.LineFaceIndex.html" target="_blank">LineFaceIndex&lt;/a> enum item. Example: &lt;b>MyThree.Intersections.LineFaceIndex.mouse&lt;/b>
	 * @param {number} color Color of the edges of the face. Example: 0xffffff - white color.
	 */
	function DrawFace( edge, lineFaceIndex, color ) {

		const THREE = three.THREE;
		const options = three.options;
		const arrayPoints = [

			edge.vertex.pointLocal,
			edge.prev.vertex.pointLocal,
			edge.prev.prev.vertex.pointLocal,

		];
		/*
		console.log(edge.face.name + ' drawFace points');
		console.log(arrayPoints[0]);
		console.log(arrayPoints[1]);
		console.log(arrayPoints[2]);
		console.log('---------------');
		*/
		if ( faceLines[lineFaceIndex] ) {

			if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( faceLines[lineFaceIndex] );
//			three.group.remove( faceLines[lineFaceIndex] );
			object.remove( faceLines[lineFaceIndex] );

		}
		const lineFace = new THREE.LineLoop( new THREE.BufferGeometry().setFromPoints( arrayPoints ), new THREE.LineBasicMaterial( { color: color } ) );
		faceLines[lineFaceIndex] = lineFace;
//		const p = lineFaceIndex === 0 ? 0.1 : 0.2;
//		const p = lineFaceIndex === 0 ? 0.01 : 0.02;
//		lineFace.position.set( p, p, p );
//		three.group.add( lineFace );
		object.add( lineFace );
		if ( options.guiSelectPoint &amp;&amp; ( lineFaceIndex === LineFaceIndex.selected ) ) {

			lineFace.name = edge.face.name;
			options.guiSelectPoint.addMesh( lineFace );
			options.guiSelectPoint.select( { object: lineFace } );//, index: index } );

		}

	}
	/**
	 * @description Hide the face, which was drawn by &lt;a href="./module-Intersections-Intersections.DrawFace.html" target="_blank">DrawFace&lt;/a>.
	 * @param {number} lineFaceIndex &lt;a href="./module-Intersections-Intersections.LineFaceIndex.html" target="_blank">LineFaceIndex&lt;/a> enum item. Example: &lt;b>MyThree.Intersections.LineFaceIndex.mouse&lt;/b>
	 */
	function HideFace( lineFaceIndex ) {

		const lineFace = faceLines[lineFaceIndex];
		if ( !lineFace ) return;
		const options = three.options;
		if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( lineFace );
//		three.group.remove( lineFace );
		object.remove( lineFace );

	}
	/**
	 * @description Array of indexes faces, which is drawn in a different color.
	 * @readonly
	 * @enum {number}
	 */
	const LineFaceIndex = {

		/** Draw the face, which user has selected */
		selected: 0,
		/** Draw the face of the twin of the first edge of the face, which user has selected */
		selectedTwin1: 1,
		/** Draw the face of the twin of the second edge of the face, which user has selected */
		selectedTwin2: 2,
		/** Draw the face of the twin of the third edge of the face, which user has selected */
		selectedTwin3: 3,
		/** Draw the face, which mouse is over */
		mouse: 4,

	}
	Object.freeze( LineFaceIndex );

	function DrawSelectedFace( edge ) {

		/*
		console.log( edge.face.name + ' indexes: ' + edge.index + ', ' + edge.prev.index + ', ' + edge.prev.prev.index + ', ' )
		const point1 = new THREE.Vector3().fromBufferAttribute(object.geometry.attributes.position,edge.index);
		console.log(point1);
		const point2 = new THREE.Vector3().fromBufferAttribute(object.geometry.attributes.position,edge.prev.index);
		console.log(point2);
		const point3 = new THREE.Vector3().fromBufferAttribute( object.geometry.attributes.position, edge.prev.prev.index );
		console.log(point3);
		console.log('world points')
		console.log(point1.applyMatrix4( object.matrix ));
		console.log(point2.applyMatrix4( object.matrix ));
		console.log(point3.applyMatrix4( object.matrix ));
		*/

		//нарисорвать face
		DrawFace( edge, LineFaceIndex.selected, 0xffffff );
		DrawFace( edge.twin.face.edge, LineFaceIndex.selectedTwin1, 0xffff00 );
		DrawFace( edge.prev.twin.face.edge, LineFaceIndex.selectedTwin2, 0xffff00 );
		DrawFace( edge.prev.prev.twin.face.edge, LineFaceIndex.selectedTwin3, 0xffff00 );

	}

	//Raycaster

	var spriteTextIntersection;
	object.userData.raycaster = {

		onIntersection: function ( intersection, mouse ) {

			const faces = object.userData.intersections.faces;
			DrawFace( faces[intersection.faceIndex].edge, LineFaceIndex.mouse, 0xffffff );
			//Options.raycaster.onIntersection( intersection, options, scene );//, camera, renderer );

			if ( !spriteTextIntersection ) {

				const attributesPosition = intersection.object.geometry.attributes.position,
					position = attributesPosition.itemSize >= 4 ? new THREE.Vector4( 0, 0, 0, 0 ) : new THREE.Vector3();
				position.fromArray( attributesPosition.array, intersection.index * attributesPosition.itemSize );
				spriteTextIntersection = new SpriteText( '111',
					position//intersection.point
					//, options.spriteOptions
				);

			} else spriteTextIntersection.position.copy( intersection.point );

		},
		onIntersectionOut: function () {

			HideFace( LineFaceIndex.mouse );

			//Options.raycaster.onIntersectionOut( scene, renderer );

			if ( spriteTextIntersection ) {

				scene.remove( spriteTextIntersection );
				spriteTextIntersection = undefined;

			}

		},
		onMouseDown: function ( intersection ) {

			//alert( 'Clicked over object.' );
			if ( cFaces ) {

				cFaces.__select[intersection.faceIndex].selected = true;
				cFaces.__onChange(intersection.faceIndex);

			} else DrawSelectedFace( object.userData.intersections.faces[intersection.faceIndex].edge );

		},

	}
	options.eventListeners.addParticle( object );

	var cFaces;

	Object.defineProperties( object.userData.intersections, {

		faces: {

			get: function () {

				if ( faces ) return faces;
				faces = [];
				class Face {

					constructor( index ) {

						var edge;
						const vectorIndex = new THREE.Vector3();
						vectorIndex.fromBufferAttribute( object.geometry.index, index );
						Object.defineProperties( this, {

							//for debugging
							name: {

								get: function () {

									for ( var i = 0; i &lt; faces.length; i++ ) {

										if ( Object.is( faces[i], this ) ) return 'Face ' + i;

									}

								}

							},

							edge: {

								get: function () {

									if ( edge ) return edge;
									class Edge {

										constructor( index, face, prev ) {

											const vertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
											this.vertex = {

												get pointLocal() { return vertex.fromBufferAttribute( positions, index ); },
												get point() { return this.pointLocal.applyMatrix4( object.matrix ); },

											};
											this.face = face;
											//this.prev = prev;
											this.index = index;
											this.head = function () { return this.vertex; }
											let twin;
											Object.defineProperties( this, {

												prev: { get: function () { return prev ? prev : this.face.edge; } },
												twin: {

													get: function () {

														if ( twin ) return twin;
														//console.log('vectorIndex');
														//console.log(vectorIndex);
														for ( var i = 0; i &lt; faces.length; i++ ) {

															const item = faces[i];
															const vectorIndexCur = new THREE.Vector3( item.edge.index, item.edge.prev.index, item.edge.prev.prev.index );
															if ( vectorIndexCur.equals( vectorIndex ) ) {

																//console.log( 'vectorIndexCur = vectorIndex' );
																if ( !Object.is( face, item ) )
																	console.error( 'Under constraction' )

															} else {

																function getTwin( s, e ) {

																	twin = item.edge;
																	if ( ( s !== twin.index ) || ( e !== twin.prev.index ) ) {

																		twin = twin.prev;
																		if ( ( s !== twin.index ) || ( e !== twin.prev.index ) ) {

																			twin = twin.prev;
																			if ( ( s !== twin.index ) || ( e !== item.edge.index ) )
																				twin = undefined;//twin.prev;

																		}

																	}
																	return twin;

																}
																//const prev = this.prev ? this.prev : this.face.edge;
																const prev = this.prev;
																if ( !getTwin( this.index, prev.index ) )
																	getTwin( prev.index, this.index )
																/*
																																					if ( !getTwin( prev.index, this.index ) )
																																						if ( !getTwin( prev.index, prev.prev.index ) )
																																							getTwin( prev.prev.index, prev.index )
																*/
																if ( twin ) break;

															}

														}
														if ( !twin ) {

															console.error( face.name + ' Edge.twin = ' + twin );
															console.error( 'index = ' + this.index );
															console.error( this.vertex.point );
															console.error( 'index = ' + this.prev.index );
															console.error( this.prev.vertex.point );
															console.error( '----------------------' );
															twin = { face: { used: true } };

														}
														return twin;

													}

												}

											} );

										}

									}
									edge = new Edge( vectorIndex.x, this, new Edge( vectorIndex.y, this, new Edge( vectorIndex.z, this ) ) );
									return edge;

								},

							},

						} );

					}

				}
				for ( let index = 0; index &lt; object.geometry.index.count; index += 3 )
					faces.push( new Face( index ) );

				//gui

				if ( options.dat &amp;&amp; options.dat.gui ) {

					const selectFace = {};
					for ( var i = 0; i &lt; faces.length; i++ )
						selectFace[faces[i].name] = i;
					cFaces = options.dat.gui.add( { Faces: 'someName' }, 'Faces', selectFace ).onChange( function ( i ) {

						DrawSelectedFace( faces[parseInt( i )].edge );

					} );

				}

				//Player

				var intersectLine;
				var intersectPoints;
				object.userData.player = {

					selectPlayScene: function ( t ) {

						object.position.set( 0, 0, 10 - 30 * t );
						object.updateMatrix();

						//thanks https://newbedev.com/how-to-detect-collision-in-three-js
						//http://stemkoski.github.io/Three.js/Collision-Detection.html
						const arrayIntersectPoints = [];
						if ( intersectLine ) {

							if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectLine );
							scene.remove( intersectLine );

						}
						if ( intersectPoints ) {

							if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectPoints );
							scene.remove( intersectPoints );

						}
						faces.forEach( function ( face ) { face.used = false; } );

						let faceIndex = 0;
						function setFace() {

							const face = faces[faceIndex];
							let edge = face.edge;
							function setEdge() {

								function getIntersect( edge, onIntersect ) {

									if ( edge.twin.face.used ) return;
									const globalOriginPoint = edge.head().point,
										globalVertex = edge.prev.head().point,
										directionVector = globalVertex.clone().sub( globalOriginPoint ),
										far = globalVertex.distanceTo( globalOriginPoint ),
										rayOriginPoint = new THREE.Raycaster( globalOriginPoint, directionVector.clone().normalize(), 0, far + ( far / 100 ) ),
										collisionResultsOriginPoint = rayOriginPoint.intersectObjects( collidableMeshList );
									if ( collisionResultsOriginPoint.length > 0 )
									//								if ( collisionResults.length > 0 &amp;&amp; collisionResults[0].distance &lt; directionVector.length() )
									//								if ( collisionResultsOriginPoint.length > 0 &amp;&amp; collisionResultsOriginPoint[0].distance &lt; directionVector.length() )
									{

										const point = collisionResultsOriginPoint[0].point;
										arrayIntersectPoints.push( point );
										/*
										console.log( 'intersection. ' + arrayIntersectPoints.length + ' ' + edge.face.name + '. point:' );
										console.log( point );
										console.log( 'origin index = ' + edge.index );
										console.log( globalOriginPoint );
										console.log( 'prev index = ' + edge.prev.index );
										console.log( globalVertex );
										console.log( '-------------' );
										*/
										if ( onIntersect ) onIntersect( point );
										return true;

									}

								}
								if ( getIntersect( edge, function ( point ) {

									while ( true ) {

										const face = edge.twin.face;
										if ( face.used ) return;
										face.used = true;
										edge = face.edge;
										if ( getIntersect( edge ) ) continue;
										edge = edge.prev;
										if ( getIntersect( edge ) ) continue;
										edge = edge.prev;
										if ( getIntersect( edge ) ) continue;

										//нужно если использовать THREE.Line вместо THREE.LineLoop
										//arrayIntersectPoints.push( arrayIntersectPoints[0] );

										break;

									}


								} ) ) return true;
								edge = edge.prev;

							}
							if ( setEdge() ) return true;
							if ( setEdge() ) return true;
							if ( setEdge() ) return true;

						}
						while ( faceIndex &lt; faces.length ) {

							if ( setFace() ) break;
							faceIndex++;

						}

						if ( arrayIntersectPoints.length > 0 ) {

							MyPoints( arrayIntersectPoints, scene, {

								options: options,
								pointsOptions: {

									name: 'intersection',
									onReady: function ( points ) {

										//points

										if ( intersectPoints ) {

											if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectPoints );
											scene.remove( intersectPoints );

										}
										intersectPoints = points;

										//lines

										if ( intersectLine ) {

											if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectLine );
											scene.remove( intersectLine );

										}
										intersectLine = new THREE.LineLoop( points.geometry, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
										scene.add( intersectLine );

										if ( options.guiSelectPoint ) {

											intersectLine.name = 'intersectLine';
											options.guiSelectPoint.addMesh( intersectLine );

										}

									}

								}

							} );

						}

					},

				}

				return faces;

			}

		},

	} );
	object.userData.intersections.faces;

}

const faceLines = [];

const Intersections = {

	/** @namespace
	 * @description Array of graphic object faces.
	 * @see &lt;a href="./module-Intersections.html" target="_blank">Faces&lt;/a> method.
	 */
	Faces: Faces,

};

export default Intersections;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Intersections.html">Intersections</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-Intersections-Intersections.Faces.html">Faces</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sat Oct 16 2021 05:52:24 GMT+0700 (Красноярск, стандартное время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
