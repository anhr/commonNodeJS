<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Intersects</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">
</head>
<body>
	<p>
		<a href='https://github.com/anhr' target="_blank">About me</a>
		<!--| <a href="https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane" target="_blank">Three JS - Find all points where a mesh intersects a plane</a>
		| <a href="https://jsfiddle.net/prisoner849/8uxw667m/" target="_blank">Example</a>-->
		| <a href="https://newbedev.com/how-to-detect-collision-in-three-js" target="_blank">How to detect collision in three.js?</a>
	</p>
	<h1>Intersects.</h1>
	<img id="wait" src="../../img/wait.gif">
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		import MyThree from '../../myThree/myThree.js';
		//import MyThree from '../../build/myThree.module.js';
		//import MyThree from '../../build/myThree.module.min.js';

		//Error: Access to XMLHttpRequest at 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/build/getShaderMaterialPoints/vertex.c'
		//	from origin 'http://localhost' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
		//import MyThree from 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/myThree.js';

		//		import { getWorldPosition } from '../../getPosition.js';

		if ( MyThree.default ) MyThree = MyThree.default;
		MyThree.three.THREE = THREE;

		new MyThree( function ( scene, options ) {

			const collidableMeshList = [];

			//Thanks https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane
			//const planeGeom = new THREE.PlaneGeometry( 30, 30 );
			const planeGeom = new THREE.TetrahedronGeometry( 10, 0 );
//			planeGeom.rotateX( -Math.PI / 2 );
			const plane = new THREE.Mesh( planeGeom,
				new THREE.MeshLambertMaterial( {

					color: "lightgray",
					opacity: 0.8,
					transparent: true,
					side: THREE.DoubleSide//от этого ключа зависят точки пересечения объектов

				} )
				/*
				new THREE.MeshBasicMaterial( {

					color: "lightgray",
					opacity: 0.75,
					transparent: true,
					side: THREE.DoubleSide//от этого ключа зависят точки пересечения объектов

				} )
				*/
			);
			//plane.rotation.x = 0.625;
			//plane.rotation.y = 2.386;
			//plane.position.z = -15;//for TorusGeometry
			//plane.position.z = -6;//for BoxGeometry
//			plane.rotation.x = Math.PI / 5;
//			plane.position.y = -3.14;
			scene.add( plane );
			plane.name = 'plane';
			if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( plane );
			collidableMeshList.push( plane );
/*
			const geometry = new THREE.BufferGeometry();
			// create a simple square shape. We duplicate the top left and bottom right
			// vertices because each vertex needs to appear once per triangle.
			const vertices = new Float32Array( [
				-1.0, -1.0,  1.0,
				1.0, -1.0,  1.0,
				1.0,  1.0,  1.0,

				1.0,  1.0,  1.0,
				-1.0,  1.0,  1.0,
				-1.0, -1.0,  1.0
			] );

			// itemSize = 3 because there are 3 values (components) per vertex
			geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
			const objGeom = geometry;
*/
			//const objGeom = new THREE.DodecahedronGeometry( 10, 0 );
			const objGeom = new THREE.TorusGeometry( 10, 3, 16, 100 );
			//const objGeom = new THREE.TorusGeometry( 10, 3, 3, 3 );
			//const objGeom = new THREE.TetrahedronGeometry( 10, 0 );
			//const objGeom = new THREE.BoxGeometry( 10, 10, 10 );
			const obj = new THREE.Mesh( objGeom, new THREE.MeshBasicMaterial( {

				color: "green",
				wireframe: true

			} ) );
			obj.rotation.x = Math.PI / 2;
			//obj.rotation.x = Math.PI / 6;
			//obj.rotation.y = Math.PI / 3;//2;//10;
//			obj.position.set( 0, 3.14, 0 );
			scene.add( obj );
			obj.name = 'Geometry';
			if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( obj );
			MyThree.Intersections.Faces( obj, collidableMeshList );

			const elWait = document.getElementById( 'wait' );
			elWait.parentNode.removeChild( elWait );

		}, {

			pointLight: {

				pointLight1: {

					position: new THREE.Vector3( 13, 2, 2 ),

				},
				pointLight2: {

					position: new THREE.Vector3( -20, -2, -2 ),

				},

			},
			//point: { size: 100 },
			camera: {

				position: new THREE.Vector3( 0, 10, 50 ),
				fov: 45,
				near: 1,
				far: 1000,

			},

			//axesHelper: false,
			playerOptions: {

				marks: 110,//Number of scenes of 3D objects animation.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {

				//guiSelectPoint: false,

			},
			//dat: false,
			scales: {

				display: false,
				posAxesIntersection: new THREE.Vector3( 0, 0, -10 ),
				/*
				text: {

					//textHeight: 0.03,
					//fov: camera.fov,
					precision: 4,

				},
				*/
				x: {

					//zoomMultiplier: 2,
					//offset: 1,
					//name: 'latitude(km.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				y: {

					//name: 'Temperature(degrees Celsius)',
					min: -10,
					max: 10,

				},
				z: {

					//name: 'Radius(m.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				/*
				w: {
					name: 'energy',
					//min: 0,
					//max: 10,
					//min: -1,
					//max: 1,
					//min: 0,//default
					//max: 1,//defaukt
				},
				*/

			},

		} );

	</script>
</body>
</html >
