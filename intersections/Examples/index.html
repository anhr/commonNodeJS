<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Intersects</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">
</head>
<body>
	<p>
		<a href='https://github.com/anhr' target="_blank">About me</a>
		<!--| <a href="https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane" target="_blank">Three JS - Find all points where a mesh intersects a plane</a>
		| <a href="https://jsfiddle.net/prisoner849/8uxw667m/" target="_blank">Example</a>-->
		| <a href="https://newbedev.com/how-to-detect-collision-in-three-js" target="_blank">How to detect collision in three.js?</a>
	</p>
	<h1>Intersects.</h1>
	<!--
	<div id="wait">
		<img src="../../img/wait.gif">
	</div>
	-->
	<div id="canvasContainer1">
		<img src="../../img/wait.gif">
		Loading... Wait about 30 seconds.<!--<input type="range" min="0" max="100" value="0" id="loadingProgress" title="Loading progress">-->
	</div>
	Intersection lines
	<div id="intersectionLines">
		<img src="../../img/wait.gif">
	</div>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		import MyThree from '../../myThree/myThree.js';
		//import MyThree from '../../build/myThree.module.js';
		//import MyThree from '../../build/myThree.module.min.js';

		//Error: Access to XMLHttpRequest at 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/build/getShaderMaterialPoints/vertex.c'
		//	from origin 'http://localhost' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
		//import MyThree from 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/myThree.js';

//		import { getWorldPosition } from '../../getPosition.js';

//		import { NURBSSurface } from '../../../../three.js/dev/examples/jsm/curves/NURBSSurface.js';

		import { FibonacciSphereGeometry } from '../../FibonacciSphere/FibonacciSphereGeometry.js'

		if ( MyThree.default ) MyThree = MyThree.default;
		MyThree.three.THREE = THREE;

		const scales = {

				display: false,
				posAxesIntersection: new THREE.Vector3( 0, 0, -10 ),
				/*
				text: {

					//textHeight: 0.03,
					//fov: camera.fov,
					precision: 4,

				},
				*/
				x: {

					//zoomMultiplier: 2,
					//offset: 1,
					//name: 'latitude(km.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				y: {

					//name: 'Temperature(degrees Celsius)',
					min: -10,
					max: 10,

				},
				z: {

					//name: 'Radius(m.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				/*
				w: {
					name: 'energy',
					//min: 0,
					//max: 10,
					//min: -1,
					//max: 1,
					//min: 0,//default
					//max: 1,//defaukt
				},
				*/

			},
			cameraOptions = {

				position: new THREE.Vector3( 0, 10, 50 ),
				fov: 45,
				near: 1,
				far: 1000,

			}
		new MyThree( function ( scene, options ) {

			const collidableMeshList = [];

			//Thanks https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane
			const planeGeom = new THREE.PlaneGeometry( 30, 30 );
			//const planeGeom = new THREE.TetrahedronGeometry( 30, 0 );
			//planeGeom.rotateX( -Math.PI / 2 );
			const plane = new THREE.Mesh( planeGeom,
				new THREE.MeshLambertMaterial( {

					color: "lightgray",
					opacity: 0.8,
					transparent: true,
					side: THREE.DoubleSide//от этого ключа зависят точки пересечения объектов

				} )
				/*
				new THREE.MeshBasicMaterial( {

					color: "lightgray",
					opacity: 0.75,
					transparent: true,
					side: THREE.DoubleSide//от этого ключа зависят точки пересечения объектов

				} )
				*/
			);
			//plane.rotation.x = 0.625;
			//plane.rotation.y = 2.386;
			//plane.position.z = -15;//for TorusGeometry
			//plane.position.z = -6;//for BoxGeometry
			//			plane.rotation.x = Math.PI / 5;
			//			plane.position.y = -3.14;
			scene.add( plane );
			plane.name = 'plane';
			if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( plane );
			collidableMeshList.push( plane );
/*
			const geometry = new THREE.BufferGeometry();
			// create a simple square shape. We duplicate the top left and bottom right
			// vertices because each vertex needs to appear once per triangle.
			const vertices = new Float32Array( [
				-10.0, -10.0,  10.0,
				10.0, -10.0,  10.0,
				10.0,  10.0,  -10.0,
//				1.0,  1.0,  1.0,
//				-1.0,  1.0,  1.0,
//				-1.0, -1.0,  1.0
			] );

			// itemSize = 3 because there are 3 values (components) per vertex
			geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
			const objGeom = geometry;
*/
			const objGeom = new THREE.DodecahedronGeometry( 10, 0 );
			//const objGeom = new THREE.SphereGeometry( 15, 32, 16 );
			//const objGeom = new FibonacciSphereGeometry( 10, 320 );
			//const objGeom = new THREE.TorusGeometry( 10, 3, 16, 100 );
			//const objGeom = new THREE.TorusGeometry( 10, 3, 3, 3 );
			//const objGeom = new THREE.TetrahedronGeometry( 10, 0 );
			//const objGeom = new THREE.BoxGeometry( 10, 10, 10 );
			const obj = new THREE.Mesh( objGeom, new THREE.MeshBasicMaterial( {

				color: "green",
				wireframe: true

			} ) );
			//obj.rotation.x = Math.PI / 2;
			//obj.rotation.x = Math.PI / 6;
			//obj.rotation.y = Math.PI / 2;//10;
			//			obj.position.set( 0, 3.14, 0 );
			scene.add( obj );
			obj.name = 'Geometry';
			if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( obj );
//			const elLoadingProgress = document.getElementById( 'loadingProgress' );

			//Player

			//				var intersectLine;
			//				var intersectPoints;
			obj.userData.player = {

				selectPlayScene: function ( t ) {

					//obj.position.set( 0, 0, 10 - 30 * t );
					//obj.updateMatrix();

				},

			}

			const arrayIntersectLines = [];
//			MyThree.Intersections.Faces( obj, collidableMeshList,
			new MyThree.Intersections( obj, collidableMeshList, {

				onReady: function ( arrayIntersectLoops ) {

					if ( !sceneIntersectionLines ) return;
					while ( arrayIntersectLines.length ) sceneIntersectionLines.remove( arrayIntersectLines.pop() );
					arrayIntersectLoops.forEach( function ( arrayIntersectLoop ) {

						const geometry = new THREE.BufferGeometry().setFromPoints( arrayIntersectLoop );
						const object = new THREE.LineLoop( geometry, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
						//const object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
						const index = arrayIntersectLines.push( object );
						sceneIntersectionLines.add( arrayIntersectLines[index -1 ] );
/*
						function surface( nsControlPoints ) {

							const degree1 = 2;
							const degree2 = 3;
							const knots1 = [0, 0, 0, 1, 1, 1];
							const knots2 = [0, 0, 0, 0, 1, 1, 1, 1];
							const nurbsSurface = new NURBSSurface( degree1, degree2, knots1, knots2, nsControlPoints );

							const map = new THREE.TextureLoader().load( '../../../../three.js/dev/examples/textures/uv_grid_opengl.jpg' );
							map.wrapS = map.wrapT = THREE.RepeatWrapping;
							map.anisotropy = 16;

							function getSurfacePoint( u, v, target ) {

								return nurbsSurface.getPoint( u, v, target );

							}

							const geometry = new THREE.ParametricBufferGeometry( getSurfacePoint, 20, 20 );
							const material = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );
							const object = new THREE.Mesh( geometry, material );
							//					object.position.set( - 200, 100, 0 );
							//					object.scale.multiplyScalar( 1 );
							sceneIntersectionLines.add( object );

						}
						surface( [arrayIntersectLoop] );
*/

					} );

				},
/*
				onProgress: function ( index, min, max ) {

					console.log( index );
					elLoadingProgress.value = index * ( 100 / ( max - min ) );

				},
*/

			} );
			/*
			const elWait = document.getElementById( 'wait' );
			elWait.parentNode.removeChild( elWait );
			*/

		}, {

			elContainer: "canvasContainer1",
			pointLight: {

				pointLight1: {

					position: new THREE.Vector3( 13, 2, 2 ),

				},
				pointLight2: {

					position: new THREE.Vector3( -20, -2, -2 ),

				},

			},
			//point: { size: 100 },

			//axesHelper: false,
			playerOptions: {

				marks: 110,//Number of scenes of 3D objects animation.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {

				//guiSelectPoint: false,

			},
			//dat: false,
			camera: cameraOptions,
			scales: scales,

		} );
		var sceneIntersectionLines;
		new MyThree( function ( scene, options ) {

			sceneIntersectionLines = scene;

		}, {

			elContainer: "intersectionLines",
			camera: cameraOptions,
			scales: scales,

		} );

	</script>
</body>
</html >
