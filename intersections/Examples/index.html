<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>Intersects</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">
</head>
<body>
	<p>
		<a href='https://github.com/anhr' target="_blank">About me</a>
		<!--| <a href="https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane" target="_blank">Three JS - Find all points where a mesh intersects a plane</a>
		| <a href="https://jsfiddle.net/prisoner849/8uxw667m/" target="_blank">Example</a>-->
		| <a href="https://newbedev.com/how-to-detect-collision-in-three-js" target="_blank">How to detect collision in three.js?</a>
	</p>
	<h1>Intersects.</h1>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import { THREE } from 'https://raw.githack.com/anhr/commonNodeJS/master/three.js';

		import MyThree from '../../myThree/myThree.js';
		//import MyThree from '../../build/myThree.module.js';
		//import MyThree from '../../build/myThree.module.min.js';

		//Error: Access to XMLHttpRequest at 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/build/getShaderMaterialPoints/vertex.c'
		//	from origin 'http://localhost' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
		//import MyThree from 'https://raw.githack.com/anhr/commonNodeJS/master/myThree/myThree.js';

//		import { getWorldPosition } from '../../getPosition.js';

		if ( MyThree.default ) MyThree = MyThree.default;
		MyThree.three.THREE = THREE;

		new MyThree( function ( scene, options ) {

			const collidableMeshList = [];

			//Thanks https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane
			const planeGeom = new THREE.PlaneGeometry( 30, 30 );
//			planeGeom.rotateX( -Math.PI / 2 );
			const plane = new THREE.Mesh( planeGeom, new THREE.MeshBasicMaterial( {

				color: "lightgray",
				transparent: true,
				opacity: 0.75,
				side: THREE.DoubleSide

			} ) );
//			plane.position.y = -3.14;
//			plane.rotation.x = Math.PI / 5;
			plane.name = 'plane';
			scene.add( plane );
			collidableMeshList.push( plane );
/*
			const geometry = new THREE.BufferGeometry();
			// create a simple square shape. We duplicate the top left and bottom right
			// vertices because each vertex needs to appear once per triangle.
			const vertices = new Float32Array( [
				-1.0, -1.0,  1.0,
				 1.0, -1.0,  1.0,
				 1.0,  1.0,  1.0,

				 1.0,  1.0,  1.0,
				-1.0,  1.0,  1.0,
				-1.0, -1.0,  1.0
			] );

			// itemSize = 3 because there are 3 values (components) per vertex
			geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
			const objGeom = geometry;
*/
			//const objGeom = new THREE.DodecahedronGeometry( 10, 0 );
			const objGeom = new THREE.TorusGeometry( 10, 3, 16, 100 );
			//const objGeom = new THREE.TorusGeometry( 10, 3, 3, 3 );
			//const objGeom = new THREE.TetrahedronGeometry( 10, 0 );
			//const objGeom = new THREE.BoxGeometry( 10, 10, 10 );
			const obj = new THREE.Mesh( objGeom, new THREE.MeshBasicMaterial( {

				color: "green",
				wireframe: true

			} ) );
			//obj.rotation.x = Math.PI / 10;
			obj.rotation.y = Math.PI / 3;//2;//10;
//			obj.position.set( 0, 3.14, 0 );
			scene.add( obj );

			function drawFace( edge, lineFaceIndex, color ) {

				const arrayPoints = [

					edge.vertex.point,
					edge.prev.vertex.point,
					edge.prev.prev.vertex.point,

				];
				/*
				console.log(edge.face.name + ' drawFace points');
				console.log(arrayPoints[0]);
				console.log(arrayPoints[1]);
				console.log(arrayPoints[2]);
				console.log('---------------');
				*/
				if ( faceLines[lineFaceIndex] ) {

					if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( faceLines[lineFaceIndex] );
					scene.remove( faceLines[lineFaceIndex] );

				}
				faceLines[lineFaceIndex] = new THREE.LineLoop( new THREE.BufferGeometry().setFromPoints( arrayPoints ), new THREE.LineBasicMaterial( { color: color } ) );
//						const p = lineFaceIndex === 0 ? 0.1 : 0.2;
				const p = lineFaceIndex === 0 ? 0.01 : 0.02;
				faceLines[lineFaceIndex].position.set( p, p, p );
				scene.add( faceLines[lineFaceIndex] );

			}

			//Raycaster

			const lineFaceIndex = 0;
			obj.userData.raycaster = {

				onIntersection: function ( intersection, mouse ) {

					const faces = obj.userData.intersections.faces;
					drawFace( faces[intersection.faceIndex].edge, lineFaceIndex, 0xffffff );
/*					
					if ( obj.userData.currentHex === undefined )
						obj.userData.currentHex = obj.material.color.getHex();
					obj.material.color.setHex( 0xffff00 );
*/					
					//Options.raycaster.onIntersection( intersection, options, scene );//, camera, renderer );

				},
				onIntersectionOut: function () {

					const lineFace = faceLines[lineFaceIndex];
					if ( !lineFace ) return;
//					if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( lineFace );
					scene.remove( lineFace );

/*
					if ( obj.userData.currentHex !== undefined )
						obj.material.color.setHex( obj.userData.currentHex );
					obj.userData.currentHex = undefined;
*/					
					//Options.raycaster.onIntersectionOut( scene, renderer );

				},
				onMouseDown: function ( intersection ) {

					alert( 'Clicked over obj.' );

				},

			}
			options.eventListeners.addParticle( obj );

			//guiSelectPoint

			obj.name = 'Geometry';
			if ( options.guiSelectPoint ) options.guiSelectPoint.addMesh( obj );

			class Faces {

				constructor( object ) {

					let faces;
					object.userData.intersections = {};
					const positions = object.geometry.attributes.position;

					if ( object.geometry.index ) {

						//ищщем точки, которые совпадают или почти совпадают с небольшой погрешностью
						//что бы у них был одинаковый индекс
						for ( let i = 1; i < object.geometry.index.count; i++ ) {

							const point1 = new THREE.Vector3().fromBufferAttribute( positions, object.geometry.index.array[i] );
							console.log( 'index: ' + object.geometry.index.array[i] );
							console.log( point1 );
							for ( let j = i - 1; j >= 0; j-- ) {

								const point2 = new THREE.Vector3().fromBufferAttribute( positions, object.geometry.index.array[j] );

								// @returns
								// 	0 координаты совпадают
								// 	1 коодинаты с маленьким отклонением
								// 	4 коодинаты с большим отклонением
								function Delta( a, b ) {

									const d = Math.abs( a - b )
									if ( d === 0 ) return 0;
	//								if ( ( d > 0 ) && ( d <= 7.347880586115415e-16 ) ) return 1;
									if ( ( d > 0 ) && ( d <= 3.1840817637818772e-15 ) ) return 1;
	//								if ( ( d > 0 ) && ( d <= 3.e-10 ) ) return 1;
									return 4;

								}
								const res = Delta( point2.x, point1.x ) +  Delta( point2.y, point1.y ) +  Delta( point2.z, point1.z );
								//0 координаты совпадают
								//1,2,3 одна, две или три коодинаты с маленьким отклонением. Остальные совпадают.
								//4 есть хоть одна коодината с большим отклонением
								//if ( ( res > 0 ) && ( res < 4 ) )
								if ( res < 4 ) {

									object.geometry.index.array[i] = object.geometry.index.array[j];
									break;

								}

							}

						}

					} else {

						const array = []
						for ( var i = 0; i < positions.count; i ++ )
							array.push( i );
						object.geometry.index = new THREE.Uint16BufferAttribute( array, 1 );
						
					}
					Object.defineProperties( object.userData.intersections, {

						faces: {

							get: function () {

								if ( faces ) return faces;
								faces = [];
								class Face {

									constructor( index ) {

										var edge;
										const vectorIndex = new THREE.Vector3();
										vectorIndex.fromBufferAttribute( object.geometry.index, index );
										Object.defineProperties( this, {

											//for debugging
											name: {

												get: function(){

													for ( var i = 0; i < faces.length; i++ ){

														if ( Object.is(faces[i], this) ) return 'Face ' + i;
																
													}

												}

											},

											edge: {

												get: function () {

													if ( edge ) return edge;
													class Edge {

														constructor( index, face, prev ){

															const vertex = positions.itemSize === 3 ? new THREE.Vector3() : positions.itemSize === 4 ? new THREE.Vector3() : undefined;
															this.vertex = {

																get point() {

																	return vertex.fromBufferAttribute( positions, index ).applyMatrix4( object.matrix );

																}

															};
															this.face = face;
															//this.prev = prev;
															this.index = index;
															this.head = function() { return this.vertex; }
															let twin;
															Object.defineProperties( this, {

																prev: { get: function () { return prev ? prev : this.face.edge; } },
																twin: {

																	get: function () {

																		if ( twin ) return twin;
																		//console.log('vectorIndex');
																		//console.log(vectorIndex);
																		for ( var i = 0; i < faces.length; i++ ) {

																			const item = faces[i];
																			const vectorIndexCur = new THREE.Vector3( item.edge.index, item.edge.prev.index, item.edge.prev.prev.index );
																			if ( vectorIndexCur.equals( vectorIndex ) ) {

																				//console.log( 'vectorIndexCur = vectorIndex' );
																				if ( !Object.is(face,item) )
																					console.error( 'Under constraction' )

																			} else {

																				function getTwin( s, e ) {

																					twin = item.edge;
																					if ( ( s !== twin.index ) || ( e !== twin.prev.index ) ) {

																						twin = twin.prev;
																						if ( ( s !== twin.index ) || ( e !== twin.prev.index ) ) {

																							twin = twin.prev;
																							if ( ( s !== twin.index ) || ( e !== item.edge.index ) )
																								twin = undefined;//twin.prev;

																						}

																					}
																					return twin;

																				}
																				//const prev = this.prev ? this.prev : this.face.edge;
																				const prev = this.prev;
																				if ( !getTwin( this.index, prev.index ) )
																					getTwin( prev.index, this.index )
/*
																					if ( !getTwin( prev.index, this.index ) )
																						if ( !getTwin( prev.index, prev.prev.index ) )
																							getTwin( prev.prev.index, prev.index )
*/
																				if ( twin ) break;

																			}

																		}
																		if ( !twin ) {

																			console.error( face.name + ' Edge.twin = ' + twin );
																			console.error( 'index = ' + this.index );
																			console.error( this.vertex.point );
																			console.error( 'index = ' + this.prev.index );
																			console.error( this.prev.vertex.point );
																			console.error( '----------------------' );
																			twin = { face: { used: true } };

																		}
																		return twin;

																	}

																}

															} );

														}

													}
													edge = new Edge( vectorIndex.x, this, new Edge( vectorIndex.y, this, new Edge( vectorIndex.z, this ) ) );
													return edge;

												},

											},

										} );

									}

								}
								for ( let index = 0; index < object.geometry.index.count; index += 3 )
									faces.push( new Face( index ) );
								return faces;

							}

						},

					} );

				}

			}

			new Faces( obj );
			const faces = obj.userData.intersections.faces;
			if ( options.dat && options.dat.gui ) {

				var faceLines = [];
				const selectFace = {};
				for ( var i = 0; i < faces.length; i++ )
					selectFace[faces[i].name] = i;
				options.dat.gui.add({ Faces: 'someName' }, 'Faces', selectFace ).onChange( function ( i ) {

					const edge = faces[parseInt( i )].edge;

					/*
					console.log( edge.face.name + ' indexes: ' + edge.index + ', ' + edge.prev.index + ', ' + edge.prev.prev.index + ', ' )
					const point1 = new THREE.Vector3().fromBufferAttribute(obj.geometry.attributes.position,edge.index);
					console.log(point1);
					const point2 = new THREE.Vector3().fromBufferAttribute(obj.geometry.attributes.position,edge.prev.index);
					console.log(point2);
					const point3 = new THREE.Vector3().fromBufferAttribute( obj.geometry.attributes.position, edge.prev.prev.index );
					console.log(point3);
					console.log('world points')
					console.log(point1.applyMatrix4( obj.matrix ));
					console.log(point2.applyMatrix4( obj.matrix ));
					console.log(point3.applyMatrix4( obj.matrix ));
					*/

					//нарисорвать face
					drawFace( edge, 0, 0xffffff );
					drawFace( edge.twin.face.edge, 1, 0xffff00 );
					drawFace( edge.prev.twin.face.edge, 2, 0xffff00 );
					drawFace( edge.prev.prev.twin.face.edge, 3, 0xffff00 );

				} );

			}

			//Player
			var intersectLine;
			var intersectPoints;
			obj.userData.player = {

				selectPlayScene: function ( t ) {

					obj.position.set( 0, 0, 10 - 30 * t );
					obj.updateMatrix();

					//thanks https://newbedev.com/how-to-detect-collision-in-three-js
					//http://stemkoski.github.io/Three.js/Collision-Detection.html
					const arrayIntersectPoints = [];
					if ( intersectLine ) { 

						if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectLine );
						scene.remove( intersectLine );

					}
					if ( intersectPoints ) { 

						if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectPoints );
						scene.remove( intersectPoints );

					}
					faces.forEach( function( face ) { face.used = false; } );

					let faceIndex = 0;
					function setFace() {

						const face = faces[faceIndex];
						let edge = face.edge;
						function setEdge() {

							function getIntersect( edge, onIntersect ) {

								if ( edge.twin.face.used ) return;
								const globalOriginPoint = edge.head().point,
									globalVertex = edge.prev.head().point,
									directionVector = globalVertex.clone().sub( globalOriginPoint ),
									far = globalVertex.distanceTo( globalOriginPoint ),
									rayOriginPoint = new THREE.Raycaster( globalOriginPoint, directionVector.clone().normalize(), 0, far + ( far /100 ) ),
									collisionResultsOriginPoint = rayOriginPoint.intersectObjects( collidableMeshList );
								if ( collisionResultsOriginPoint.length > 0 )
//								if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() )
//								if ( collisionResultsOriginPoint.length > 0 && collisionResultsOriginPoint[0].distance < directionVector.length() )
								{

									const point = collisionResultsOriginPoint[0].point;
									arrayIntersectPoints.push( point );
									console.log( 'intersection. ' + arrayIntersectPoints.length + ' ' + edge.face.name + '. point:' );
									console.log( point );
									console.log( 'origin index = ' + edge.index );
									console.log( globalOriginPoint );
									console.log( 'prev index = ' + edge.prev.index );
									console.log( globalVertex );
									console.log( '-------------' );
									if ( onIntersect ) onIntersect( point );
									return true;

								}

							}
							if ( getIntersect( edge, function ( point ) {

								while ( true ) {

									const face = edge.twin.face;
									if ( face.used ) return;
									face.used = true;
									edge = face.edge;
									if ( getIntersect( edge ) ) continue;
									edge = edge.prev;
									if ( getIntersect( edge ) ) continue;
									edge = edge.prev;
									if ( getIntersect( edge ) ) continue;

									//нужно если использовать THREE.Line вместо THREE.LineLoop
									//arrayIntersectPoints.push( arrayIntersectPoints[0] );

									break;
								
								}


							} ) ) return true;
							edge = edge.prev;

						}
						if ( setEdge() ) return true;
						if ( setEdge() ) return true;
						if ( setEdge() ) return true;

					}
					while ( faceIndex < faces.length ) {

						if ( setFace() ) break;
						faceIndex++;

					}

					if ( arrayIntersectPoints.length > 0 ) {

						MyThree.MyPoints( arrayIntersectPoints, scene, {

							options: options,
							pointsOptions: {

								name: 'intersection',
								onReady: function( points ) {

									//points
									
									if ( intersectPoints ) { 

										if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectPoints );
										scene.remove( intersectPoints );

									}
									intersectPoints = points;

									//lines
									
									if ( intersectLine ) { 

										if ( options.guiSelectPoint ) options.guiSelectPoint.removeMesh( intersectLine );
										scene.remove( intersectLine );

									}
									intersectLine = new THREE.LineLoop( points.geometry, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
									scene.add( intersectLine );

									if ( options.guiSelectPoint ) {

										intersectLine.name = 'intersectLine';
										options.guiSelectPoint.addMesh( intersectLine );

									}

								}

							}

						} );

					}

				},

			}

		}, {

			camera: {

				position: new THREE.Vector3( 0, 10, 50 ),
				fov: 45,
				near: 1,
				far: 1000,

			},

			//axesHelper: false,
			playerOptions: {

				marks: 110,//Number of scenes of 3D objects animation.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {

				//guiSelectPoint: false,

			},
			scales: {

				display: false,
				posAxesIntersection: new THREE.Vector3( 0, 0, -10 ),
				/*
				text: {

					//textHeight: 0.03,
					//fov: camera.fov,
					precision: 4,

				},
				*/
				x: {

					//zoomMultiplier: 2,
					//offset: 1,
					//name: 'latitude(km.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				y: {

					//name: 'Temperature(degrees Celsius)',
					min: -10,
					max: 10,

				},
				z: {

					//name: 'Radius(m.)',
					min: -10,
					max: 10,
					//marks: 11,

				},
				/*
				w: {
					name: 'energy',
					//min: 0,
					//max: 10,
					//min: -1,
					//max: 1,
					//min: 0,//default
					//max: 1,//defaukt
				},
				*/

			},

		} );

	</script>
</body>
</html >
