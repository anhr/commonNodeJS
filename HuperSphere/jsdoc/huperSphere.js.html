<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: huperSphere.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: huperSphere.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module HuperSphere
 * @description Base class for n dimensional hupersphere.
 *
 * @author [Andrej Hristoliubov]{@link https://github.com/anhr}
 *
 * @copyright 2011 Data Arts Team, Google Creative Lab
 *
 * @license under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
*/


import ND from '../nD/nD.js';
//import ND from '../nD/build/nD.module.js';
//import ND from '../nD/build/nD.module.min.js';
//import ND from 'https://raw.githack.com/anhr/commonNodeJS/master/nD/nD.js';
//import ND from 'https://raw.githack.com/anhr/commonNodeJS/master/nD/build/nD.module.js';
//import ND from 'https://raw.githack.com/anhr/commonNodeJS/master/nD/build/nD.module.min.js';
if (ND.default) ND = ND.default;

//Когда хочу вывести на холст точки вместо ребер то использую MyPoints вместо ND
//При этом ребра не создаются что дает экономию времени
import MyPoints from '../myPoints/myPoints.js';
import ColorPicker from '../colorpicker/colorpicker.js';

//Получаю ошибку
//myThree: duplicate myThree. Please use one instance of the myThree class.
//если на веб странце импортировать import MyThree from '../../../commonNodeJS/master/myThree/build/myThree.module.js';
//import MyThree from '../myThree/myThree.js';
import three from '../three.js'

import ProgressBar from '../ProgressBar/ProgressBar.js'
//import WebGPU from '../../../WebGPU/master/WebGPU.js';
import PositionController from '../PositionController.js';

const sHuperSphere = 'HuperSphere', sOverride = sHuperSphere + ': Please override the %s method in your child class.',
	π = Math.PI;
//	verticeEdges = true;//Эту константу добавил на случай если захочу не включать индексы ребер в вершину если classSettings.debug != true

class HuperSphere {

	#verticeEdgesLength;
	
	//rotateLatitude = 0;
	rotateLatitude = - π / 2;//Поворачиваем широту на 90 градусов что бы начало координат широты находилось на экваторе;
	getRotateLatitude = (i) => i === (this.dimension - 3) ? this.rotateLatitude : 0;
	
	get verticeEdgesLength() { return this.#verticeEdgesLength; }
	set verticeEdgesLength(length) {

		this.#verticeEdgesLength = length;
		this.removeMesh();
		this.pushEdges();

	}

	//base methods

	pushRandomLongitude(verticeAngles) {

		const ranges = this.classSettings.settings.object.geometry.angles.ranges, longitudeRange = ranges[ranges.length - 1];
		verticeAngles.push(Math.random() * (longitudeRange.max - longitudeRange.min) + longitudeRange.min);
		
	}
	color() { if (this.classSettings.settings.object.color === undefined) this.classSettings.settings.object.color = 'lime'; }
	name() { console.error(sOverride.replace('%s', 'name')); }
	logHuperSphere() {

		if (!this.classSettings.debug) return;
		console.log(this.cookieName);
		let i = 0, progressBarValue = 0,
			log = 0;//position log
		const settings = this.classSettings.settings, geometry = settings.object.geometry, position = geometry.position, edges = geometry.indices.edges,
			sLogHuperSphere = sHuperSphere + ': logHuperSphere()',
			progressBar = new ProgressBar(settings.options.renderer.domElement.parentElement, () => {

				switch (log){
					case 0://position log
						const vertice = position[i];
						console.log('vertice[' + i + '] = ' + JSON.stringify(vertice) + ' angles = ' + JSON.stringify(vertice.angles) + ' edges = ' + JSON.stringify(vertice.edges));
						break;
					case 1://edges log
						const edge = edges[i];
						console.log('edges[' + i + '] = ' + JSON.stringify(edge))
						break;
					default: console.error(sLogHuperSphere + '. Invalid log = ' + log);
				}
				progressBar.value = progressBarValue;
				progressBarValue++;
				i++;
				switch (log){
					case 0://position log
						if (i === position.length) {
							
							log++;//edges log
							i = 0;

						}
						progressBar.step();
						break;
					case 1://edges log
						if (i >= edges.length) {
							
							progressBar.remove();
							if (this.classSettings.debug)
								this.classSettings.debug.logTimestamp('Geometry log. ');
							
						} else progressBar.step();
						break;
					default: console.error(sLogHuperSphere + '. Invalid log = ' + log);
				}
				
			}, {

			sTitle: 'Geometry log',
			max: position.length - 1 + edges.length - 1,

		});
		
	}
	Test(){

		if (!this.classSettings.debug) return;
		
		const geometry = this.classSettings.settings.object.geometry;
		geometry.position.test();

		//for future using
		if (geometry.indices.faces) geometry.indices.faces.test();
		
	}
	boTestVertice = true;
	TestVertice(vertice, strVerticeId){

		if (!this.boTestVertice) return;
		if (this.classSettings.edges === false) return;
		if (vertice.edges.length &lt; (this.verticeEdgesLength - 1))//Допускается количество ребер на одно меньше максимального значения потому что при опреденном количестве вершин для некоротых вершин не хватает противоположных вершин
			console.error(sHuperSphere + ': Test(). Invalid ' + strVerticeId + '.edges.length = ' + vertice.edges.length);
		
	}
	angles2Vertice(angles) {

		const a2v = (angles) => {

			//https://en.wikipedia.org/wiki/N-sphere#Spherical_coordinates
			const n = this.dimension, φ = [],//angles,
				x = [], cos = Math.cos, sin = Math.sin;
			//нужно для того, чтобы начало координат широты находилось на экваторе
			//angles.forEach((angle, i) => φ.push(angle - this.getRotateLatitude(i)));//Почемуто не получается скопировать углы если по умолчанию угол не задан
			for (let i = 0; i &lt; angles.length; i++) {

				const rotateLatitude = this.getRotateLatitude(i);
				φ.push((rotateLatitude === 0 ? 1 : - 1) * angles[i] - rotateLatitude);//Для широты меняем знак угола что бы положительная широта была в северном полушарии

			}

			//добавляем оси
			
			for (let index = 0; index &lt; n; index++) {

				let axis = 1.0;
				const i = this.axes.indices[index],
					mulCount = //количество множителей для данной оси
					i &lt; (n - 1) ?
						i + 1: //на один больше порядкового номера оси
						i;//или равно порядковому номеру оси если это последняя ось
				for (let j = 0; j &lt; mulCount; j++) {

					if(j === (mulCount - 1)){

						//Это последний множитель для текущей оси
						if (i != (n - 1)) {
							
							//Это не последняя ось
							axis *= cos(φ[j]);
							continue;

						}
						
					}
					axis *= sin(φ[j]);

				}
				x.push(axis);

			}
			return x;

		}
		const vertice = a2v(angles);
		if (this.classSettings.debug &amp;&amp; this.classSettings.debug.testVertice){

			const vertice2angles = this.vertice2angles(vertice),
				angles2vertice = a2v(vertice2angles);
			const value = vertice;
			if (angles2vertice.length != value.length) console.error(sHuperSphere + ': Set vertice failed. angles2vertice.length = ' + angles2vertice.length + ' is not equal value.length = ' + value.length);
			const d = 6e-16;
			angles2vertice.forEach((axis, i) => { if(Math.abs(axis - value[i]) > d) console.error(sHuperSphere + ': Set vertice failed. axis = ' + axis + ' is not equal to value[' + i + '] = ' + value[i]) } );
			
		}
		
		return vertice;

	}
	vertice2angles(vertice) {

		//Сейчас эта функция используется для вычисления middle vertice
		//if (!this.classSettings.debug) console.warn(sHuperSphere + ': Use vertice2angles in debug version only');
		
		//https://en.wikipedia.org/wiki/N-sphere#Spherical_coordinates
		//тангенс — отношение стороны противолежащего катета vertice[1] к стороне прилежащегоvertice[0], (tg или tan);
		const x = [],//для разных размерностей вселенной координаты вершины расположены в разном порядке в соответствии с this.axes.indices
			n = this.dimension - 1, φ = [], atan2 = Math.atan2, sqrt = Math.sqrt;

		for (let index = 0; index &lt; vertice.length; index++) x.push(vertice[this.axes.indices[index]]);

		for (let i = 0; i &lt; n; i++) {

			const axes = {};
			if (i === (n - 1)) {
				
				axes.y = x[n]; axes.x = x[n - 1];
				
			} else {
				
				let sum = 0;
				for(let j = (i + 1); j &lt;= n; j++) sum += x[j] * x[j];
				axes.y = sqrt(sum); axes.x = x[i];

			}
			const rotateLatitude = this.getRotateLatitude(i);
			φ.push((rotateLatitude === 0 ? 1 : -1) * atan2(axes.y, axes.x) - rotateLatitude);//Для широты меняем знак угола что бы положительная широта была в северном полушарии
			
			
		}

		//установить углы так, что бы они влезли допустимый диапазон органов управления углов, когда пользователь захочет посмотреть или изменить эти углы
		const longitudeId = φ.length - 1, latitudeId = longitudeId - 1, altitudeId = latitudeId - 1,
			ranges = this.classSettings.settings.object.geometry.angles.ranges;
		let latitude = φ[latitudeId], longitude = φ[longitudeId], altitude = φ[altitudeId];
		if (altitude != undefined) {//у одномерной и двумерной вселенной нет высоты

			const altitudeRange = ranges[altitudeId];
			if (altitude > altitudeRange.max) {//π / 2
				
				//altitude = π - altitude;

/*				
				//широту развернуть на 180 градусов
				if (latitude > 0) latitude -= π / 2;
				else if (latitude &lt; 0) latitude += π / 2;
*/
/*
				//долготу развернуть на 180 градусов
				if (longitude > 0) longitude -= π;
				else if (longitude &lt; 0) longitude += π;
*/				
				
			} else if (altitude &lt; altitudeRange.min) {//0
				
				console.error('Under constraction')
				altitude -= π;
	
			}
			φ[altitudeId] = altitude;
			
		}
		if (latitude != undefined) {//у одномерной вселенной нет широты
			
			const latitudeRange = ranges[latitudeId];//, longitudeRange = ranges[longitudeId];
			if (latitude > latitudeRange.max) {//π / 2
				
				latitude = π - latitude;
	
				//долготу развернуть на 180 градусов
				if (longitude > 0) longitude -= π;
				else if (longitude &lt; 0) longitude += π;
				
			} else if (latitude &lt; latitudeRange.min) {//- π / 2
				
				console.error('Under constraction')
				latitude -= π;
	
			}
			φ[latitudeId] = latitude;
			φ[longitudeId] = longitude;

		}
		
		return φ;

	}

	/**
	 * Base class for n dimensional universe.
	 * @param {Options} options See &lt;a href="../../../commonNodeJS/master/jsdoc/Options/Options.html" target="_blank">Options&lt;/a>.
	 * @param {object} [classSettings] &lt;b>HuperSphere&lt;/b> class settings.
	 * @param {object} [classSettings.intersection] HuperSphere intersection.
	 * &lt;pre>
	 *	For Circle intersector is line.
	 *	For Sphere intersector is plane.
	 *	For HuperSphere intersector is sphere.
	 * &lt;/pre>
	 * @param {float} [classSettings.intersection.position=0.0] Position of the intersector.
	 * &lt;pre>
	 *	For Circle &lt;b>position&lt;/b> is Y coordinate of the intersection line.
	 *	For Sphere &lt;b>position&lt;/b> is Z coordinate of the intersection plane.
	 *	For HuperSphere &lt;b>position&lt;/b> is radius of the intersection sphere.
	 * &lt;/pre>
	 * @param {number|string} [classSettings.intersection.color=0x0000FF] Color of the intersector. Example: 'red'.
	 * @param {object} [classSettings.projectParams] Parameters of project the universe onto the canvas.
	 * @param {THREE.Scene} classSettings.projectParams.scene [THREE.Scene]{@link https://threejs.org/docs/index.html?q=sce#api/en/scenes/Scene}
	 * @param {object} [classSettings.projectParams.params={}] The following parameters are available
	 * @param {object} [classSettings.projectParams.params.center={x: 0.0, y: 0.0, z: 0.0}] center of the universe
	 * @param {float} [classSettings.projectParams.params.center.x=0.0] X axis of the center
	 * @param {float} [classSettings.projectParams.params.center.y=0.0] Y axis of the center
	 * @param {float} [classSettings.projectParams.params.center.z=0.0] Y axis of the center
	 * @param {float} [classSettings.t=1.0] HuperSphere start time. Time is the radius of the HuperSphere.
	 * @param {boolean|object} [classSettings.edges={}] HuperSphere edges
	 * &lt;pre>
	 *	false - Doesn't create edges to reduce the creation time of the universe
	 * &lt;/pre>
	 * @param {boolean} [classSettings.edges.project=true] false - Doesn't project edges onto canvas
	 * @param {enum} [classSettings.edges.creationMethod=edgesCreationMethod.Random] method for creating edges. See &lt;a href="./module-HuperSphere-HuperSphere.html#.edgesCreationMethod" target="_blank">edgesCreationMethod&lt;/a>
	 * @param {object} [classSettings.settings] The following settings are available
	 * @param {object} [classSettings.settings.object] HuperSphere object.
	 * @param {String} [classSettings.settings.object.name] name of universe.
	 * @param {String|number} [classSettings.settings.object.color='lime'] color of edges or vertices.
	 * &lt;pre>
	 * String - color name. See list of available color names in the &lt;b>_colorKeywords&lt;/b> object in the [Color.js]{@link https://github.com/mrdoob/three.js/blob/dev/src/math/Color.js} file.
	 * number - color [Hex triplet]{@link https://en.wikipedia.org/wiki/Web_colors#Hex_triplet}. Example: 0x0000ff - blue color.
	 * &lt;pre>
	 * @param {object} [classSettings.settings.object.geometry] HuperSphere geometry.
	 * @param {array|object} [classSettings.settings.object.geometry.angles] n-dimensional universe vertice angles.
	 * &lt;pre>
	 * array - array of vertex angles.
	 *	Every item of array is n-dimensional array of vertex angles.
	 *	
	 *	All the vertices of the &lt;b>&lt;a href="module-HuperSphere1D.html" target="_blank">Circle&lt;/a>&lt;/b> form a circle.
	 *	For &lt;b>&lt;a href="module-Circle.html" target="_blank">Circle&lt;/a>&lt;/b> every vertice is array of one angle.
	 *		Vertex angle is the longitude of the circle of the universe in the range from &lt;b>- π&lt;/b> to &lt;b>π&lt;/b>.
	 *		Vertex angle is angle of rotation around of &lt;b>Z&lt;/b> axis in 3D space.
	 *		Angle is begin from &lt;b>X = 0, Y = 1&lt;/b>.
	 *		Every vertex is &lt;b>[
				Math.cos(θ),//x
				Math.sin(θ)//y
			]&lt;/b> array. &lt;b>θ&lt;/b> is vertex angle.
	 *		Example of Circle with three vertices is triangle:
	 *		&lt;b>classSettings.settings.object.geometry.angles: angles: [
	 *			[],                 //vertice[0] = [0                   ,1]
	 *			[Math.PI * 2 / 3],  //vertice[1] = [0.8660254037844387	,-0.4999999999999998]
	 *			[- Math.PI * 2 / 3] //vertice[2] = [-0.8660254037844387	,-0.4999999999999998]
	 *		]&lt;/b>,
	 *		
	 *	All the vertices of the &lt;b>&lt;a href="module-Sphere.html" target="_blank">Sphere&lt;/a>&lt;/b> form a sphere.
	 *	For &lt;b>&lt;a href="module-Sphere.html" target="_blank">Sphere&lt;/a>&lt;/b> every vertice is array of two angles.
	 *		The first vertex angle is the latitude of the sphere of the universe in the range from &lt;b>- π / 2&lt;/b> to &lt;b>π / 2&lt;/b>.
	 *		Zero latitude is located at the equator.
	 *		
	 *		The second vertex angle is the longitude of the sphere of the universe in the range from &lt;b>- π&lt;/b> to &lt;b>π&lt;/b>.
	 *		The second vertex angle is angle of rotation of the cross section around of &lt;b>Y&lt;/b> axis.
	 *		
	 *		Example of Sphere with 4 vertices is pyramid:
	 *		&lt;b>classSettings.settings.object.geometry.angles: [
	 *		
	 *			[ Math.PI / 2,  0                  ],//vertice[0] = [ 0                 , 1  , 0   ]
	 *			[-Math.PI / 6,  Math.PI * 2 * 0 / 3],//vertice[1] = [-0.8660254037844387,-0.5, 0   ]
	 *			[-Math.PI / 6,  Math.PI * 2 * 1 / 3],//vertice[2] = [ 0.4330127018922192,-0.5,-0.75]
	 *			[-Math.PI / 6, -Math.PI * 2 * 1 / 3,//vertice[3] = [ 0.4330127018922195,-0.5, 0.75]
	 *			
	 *		]&lt;/b>,
	 *		
	 *	All the vertices of the &lt;a href="module-HuperSphere3D.html" target="_blank">HuperSphere3D&lt;/a>&lt;/b> form a [hupersphere]{@link https://en.wikipedia.org/wiki/N-sphere}.
	 *	For &lt;b>&lt;a href="module-HuperSphere3D.html" target="_blank">HuperSphere3D&lt;/a>&lt;/b> every vertice is array of three angles.
	 *		The first vertex angle is the altitude of the hupersphere of the universe in the range from &lt;b>0&lt;/b> to &lt;b>π / 2&lt;/b>.
	 *		Zero altitude is located at the center of the hupersphere.
	 *		
	 *		The second vertex angle is the latitude of the hupersphere of the universe in the range from &lt;b>- π / 2&lt;/b> to &lt;b>π / 2&lt;/b>.
	 *		Zero latitude is located at the equator.
	 *		
	 *		The third vertex angle is the longitude of the hupersphere of the universe in the range from &lt;b>- π&lt;/b> to &lt;b>π&lt;/b>.
	 *		The third vertex angle is angle of rotation of the cross section around of &lt;b>Y&lt;/b> axis.
	 *		
	 *		Example of HuperSphere with 5 vertices is [pentahedroid]{@link https://en.wikipedia.org/wiki/5-cell}:
	 *		&lt;b>classSettings.settings.object.geometry.angles: [
	 *			[],
	 *			[Math.PI / 2, Math.PI / 2],
	 *			[
	 *				  Math.PI / 2,//Altitude
	 *				- Math.PI / 6,//Latitude
	 *				  Math.PI * 0,//Longitude
	 *			],
	 *			[Math.PI / 2, - Math.PI / 6,   Math.PI * 2 * 1 / 3],
	 *			[Math.PI / 2, - Math.PI / 6, - Math.PI * 2 * 1 / 3],
			]&lt;/b>,
	 * object - see below:
	 * &lt;/pre>
	 * @param {number} [classSettings.settings.object.geometry.angles.count=3|4|5] Count of vertices with random position.
	 * &lt;pre>
	 * Default values:
	 *	3 for &lt;b>&lt;a href="module-Circle.html" target="_blank">Circle&lt;/a>&lt;/b> - triangle.
	 *	4 for &lt;b>&lt;a href="module-Sphere.html" target="_blank">Sphere&lt;/a>&lt;/b> - pyramid.
	 *	5 for &lt;b>&lt;a href="module-HuperSphere3D.html" target="_blank">HuperSphere3D&lt;/a>&lt;/b> - [pentahedroid]{@link https://en.wikipedia.org/wiki/5-cell}.
	 * &lt;/pre>
	 * @param {array} [classSettings.settings.object.geometry.opacity] array of opacities of each vertice. Each item of array is float value in the range of 0.0 - 1.0 indicating how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque.
	 * @param {object} [classSettings.settings.object.geometry.indices] Array of &lt;b>indices&lt;/b> of edges of universe.
	 * @param {array|object} [classSettings.settings.object.geometry.indices.edges] HuperSphere edges.
	 * &lt;pre>
	 * array - array of edges.
	 *	Every edge is array of indices of vertices from
	 *	&lt;b>classSettings.settings.object.geometry.position&lt;/b>
	 *	Example: &lt;b>[[0,1], [1,2], [2,0]],//triangle&lt;/b>
	 * object - see below:
	 * &lt;/pre>
	 * @param {number} [classSettings.settings.object.geometry.indices.edges.count=3] edges count.
	 * @param {boolean|object} [classSettings.debug=false] Debug mode.
	 * &lt;pre>
	 *	true - Diagnoses your code and display detected errors to console.
	 *	object - Diagnoses your code and display detected errors to console.
	 * &lt;/pre>
	 * @param {boolean|Array} [classSettings.debug.probabilityDensity=[]] Probability density of distribution of vertices over the surface of the universe.
	 * &lt;pre>
	 *	false - do not calculate probability density.
	 *	[] - calculate probability density.
	 * &lt;/pre>
	 * @param {boolean} [classSettings.debug.testVertice=true]
	 * &lt;pre>
	 * Test of converting of the vertice coordinates from Cartesian Coordinates to Polar Coordinates
	 * and Polar Coordinates to Cartesian Coordinates
	 * and display detected errors to console.
	 * &lt;/pre>
	 * @param {boolean} [classSettings.debug.middleVertice=true] Log middle vertice.
	 * @param {function} [classSettings.continue] Callback function that called after universe edges was created.
	 * @param {boolean} [classSettings.boRemove] false - do not delete the previous universe while projecting a new universe on scene.
	 * @param {boolean} [classSettings.boGui] false - do not include universe GUI.
	 **/
	constructor(options, classSettings={}) {

		const _this = this, THREE = three.THREE;
		if (classSettings.debug === true) classSettings.debug = {};
		if (classSettings.debug) {
			
			classSettings.debug.timestamp = window.performance.now();
			classSettings.debug.logTimestamp = (text = '', timestamp) =>
				console.log('time: ' + text + ((window.performance.now() - (timestamp ? timestamp : classSettings.debug.timestamp)) / 1000) + ' sec.');
			if (classSettings.debug.testVertice != false) classSettings.debug.testVertice = true;
			if (classSettings.debug.middleVertice != false) classSettings.debug.middleVertice = true;
			
		}
		this.classSettings = classSettings;

		const cookieOptions = {};
		if (options.dat) options.dat.cookie.getObject(this.cookieName, cookieOptions);

		let edgesOld = cookieOptions.edgesOld || { project: true, };
		classSettings.edges = cookieOptions.edges === false ? false : cookieOptions.edges || classSettings.edges;
		if (classSettings.edges != false) classSettings.edges = classSettings.edges || {};
		if ((classSettings.edges != false) &amp;&amp; (classSettings.edges.project === undefined)) classSettings.edges.project = true;

		if (classSettings.t === undefined) classSettings.t = 1.0;
		classSettings.settings = classSettings.settings || {};
		const settings = classSettings.settings;
		settings.options = options;
		settings.object = settings.object || {};
		settings.object.name = settings.object.name || this.name( options.getLanguageCode );
  
		//не получается сменить имя оси
		//if (options.scales.w.name === 'w') options.scales.w.name = 't';
  
		settings.object.geometry = settings.object.geometry || {};

		//for debug
		//для 2D вселенной это плотность вероятности распределения вершин по поверхности сферы в зависимости от третьей координаты вершины z = vertice.[2]
		//Плотности разбил на несколько диапазонов в зависимости от третьей координаты вершины z = vertice.[2]
		//Разбил сферу на sc = 5 сегментов от 0 до 4.
		//Границы сегментов вычисляю по фомулам:
		//Высота сегмента hs = d / sc = 2 / 5 = 0.4
		//Нижняя граница сегмента hb = hs * i - r
		//Верхняя граница сегмента ht = hs * (i + 1) - r
		//где r = 1 - радиус сферыб d = 2 * r = 2 - диаметр сферы, i - индекс сегмента
		if (classSettings.debug &amp;&amp; (classSettings.debug.probabilityDensity != false)) classSettings.debug.probabilityDensity = [
			
				/*
				{ count: 0, },//0. From -1 to -0.6
				{ count: 0, },//1. From -0.6 to -0.2
				{ count: 0, },//2. From -0.2 to 0.2
				{ count: 0, },//3. From 0.2 to 0.6
				{ count: 0, },//4. From 0.6 to 1
				*/
			
		];
		classSettings.debug = classSettings.debug || {};
		const probabilityDensity = classSettings.debug.probabilityDensity;
		if (probabilityDensity) {
			
			for (let i = 0; i &lt; 5; i++) probabilityDensity.push({ count: 0, });
			probabilityDensity.options = { d: classSettings.t * 2, };
			probabilityDensity.options.sc = probabilityDensity.length;//Количество сегментов
			probabilityDensity.options.hs = probabilityDensity.options.d / probabilityDensity.options.sc;//Высота сегмента
			let sectorsValue = 0;
			probabilityDensity.forEach((sector, i) => {

				sector.hb = probabilityDensity.options.hs * i - classSettings.t;//Нижняя граница сегмента
				sector.ht = probabilityDensity.options.hs * (i + 1) - classSettings.t;//Верхняя граница сегмента
				sectorsValue += _this.probabilityDensity.sectorValue(probabilityDensity, i);

			});
			let unverseValue = this.probabilityDensity.unverseValue;
			if (unverseValue === undefined) {
				
				unverseValue = π;
				const r = classSettings.t;//probabilityDensity.options.r;
				for (let i = 0; i &lt; (_this.dimension - 1); i++) unverseValue *= 2 * r;

			}
			if (unverseValue != sectorsValue) console.error(sHuperSphere + ': Unverse value = ' + unverseValue + '. Sectors value = ' + sectorsValue);
		
		}
		settings.object.geometry.angles = settings.object.geometry.angles || this.defaultAngles();
		if(!(settings.object.geometry.angles instanceof Array)) {

			const angles = [];
			Object.keys(settings.object.geometry.angles).forEach((key) => angles[key] = settings.object.geometry.angles[key]);
			settings.object.geometry.angles = angles;
			
		}

		settings.object.geometry.angles = new Proxy(settings.object.geometry.angles || this.defaultAngles(), {

			get: (angles, name) => {

				const verticeId = parseInt(name);
				if (!isNaN(verticeId)) {

					return new Proxy(angles[verticeId], {

						get: (verticeAngles, name) => {

							const angleId = parseInt(name);
							if (!isNaN(angleId)) {

								if (angleId >= verticeAngles.length) return 0.0;
								let angle = verticeAngles[angleId];

								/*
								//Normalize angle to value from -π to π
								while (angle > π) angle -= 2 * π;
								while (angle &lt; - π) angle += 2 * π;
								*/

								return angle;

							}
							switch (name) {

								case 'length': return _this.dimension - 1;
								case 'length': return _this.dimension - 1;

							}
							return verticeAngles[name];

						},
						set: (verticeAngles, name, value) => {

							const angleId = parseInt(name);
							if (!isNaN(angleId)) {

								const angle = value;
								if (verticeAngles[angleId] != angle) {

									const range = angles.ranges[angleId];
									if((angle &lt; range.min) || (angle > range.max)) console.error(sHuperSphere + ': Set angle[' + angleId + '] = ' + angle + ' of the vertice ' + verticeId + ' is out of range from ' + range.min + ' to ' + range.max);
									
									verticeAngles[angleId] = angle;
									//если тут обновлять вселенную, то будет тратиться лишнее время, когда одновременно изменяется несколько вершин
									//Сейчас я сначала изменяю все вершины, а потом обновляю вселенную
									//_this.update(verticeId);

								}

							} else verticeAngles[name] = value;
							return true;

						}

					});

				}
				switch(name){

					case 'pushRandomAngle': return () => {
						
						const verticeAngles = [];
						_this.pushRandomAngle(verticeAngles);
						angles.push(verticeAngles);

					}
					case 'push': return (verticeAngles) => {

						for (let angleId = 0; angleId &lt; verticeAngles.length; angleId++) {
							
							const angle = verticeAngles[angleId], range = angles.ranges[angleId];
							if((angle &lt; range.min) || (angle > range.max)) console.error(sHuperSphere + ': Vertice angle[' + angleId + '] = ' + angle + ' is out of range from ' + range.min + ' to ' + range.max);

						}
						angles.push(verticeAngles);

					}
					case 'guiLength': return angles.length;
						
				}
				return angles[name];

			},
			//set settings.object.geometry.angles
			set: (aAngles, name, value) => {

				switch(name){

					case 'guiLength'://изменилось количество вершин
						for (let i = aAngles.length; i &lt; value; i++) angles.pushRandomAngle();//add vertices
						aAngles.length = value;//remove vrtices
						if (classSettings.edges) {//Для экономии времени не добавляю ребра если на холст вывожу только вершины

							_this.removeMesh();
							_this.pushEdges();

						}
						else _this.project();
						return true;
					case 'length':
						console.warn(sHuperSphere + ': set geometry.angles.length. Use guiLength instead')
						return true;
						
				}
				const i = parseInt(name);
				if (!isNaN(i)) {

					aAngles[i] = value;
					_this.object().userData.myObject.setPositionAttribute(i);
					
				}
				else aAngles[name] = value;
				return true;
				
			}
			
		});
		const angles = settings.object.geometry.angles;

		//Angles range
		angles.ranges = [];
		for (let angleId = 0; angleId &lt; this.dimension - 1; angleId++) {
			
			const range = {}
			switch(this.dimension - 2 - angleId) {

				case 0:
					range.angleName = 'Longitude';
					range.min = - π;
					range.max =   π;
					break;
				case 1:
					range.angleName = 'Latitude';
					range.min = 0 + this.rotateLatitude;//- π / 2;
					range.max = π + this.rotateLatitude;//π / 2;
					break;
				case 2:
					range.angleName = this.altitudeRange.angleName;//'Altitude';
					range.min = this.altitudeRange.min;//0;
					range.max = this.altitudeRange.max;//π / 2;
					break;
				default: console.error(sHuperSphere + ': vertice angles ranges. Invalid angleId = ' + angleId);
					
			}
			angles.ranges.push(range);

		}
		
		//angles[0][0] = 10;//error universe.js:548 HuperSphere: Set angle[0] = 10 of the vertice 0 is out of range from -1.5707963267948966 to 1.5707963267948966
		if (angles.count != undefined)
			for (let i = angles.length; i &lt; angles.count; i++) angles.pushRandomAngle();
		settings.object.geometry.position = new Proxy(angles, {

			get: (_position, name) => {

				const i = parseInt(name);
				if (!isNaN(i)) {

					if (i > _position.length) console.error(sHuperSphere + ': position get. Invalid index = ' + i + ' position.length = ' + _position.length);
					else if (i === _position.length)
						settings.object.geometry.angles.pushRandomAngle();
					const _vertice = _position[i];
					const angle2Vertice = () => {

						const vertice = _this.angles2Vertice(_vertice), r = classSettings.t;
						//Эта проверка не проходит для HuperSphere3D
						if (classSettings.debug) {

							let sum = 0;
							vertice.forEach(axis => sum += axis * axis);
							if (Math.abs((sum - r)) > 4.5e-16) console.error(sHuperSphere + ': Invalid vertice[' + i + '] sum = ' + sum);
							
						}
						vertice.forEach((axis, i) => vertice[i] *= r);
						return vertice;
						
					}
					return new Proxy(angle2Vertice(), {

						get: (vertice, name) => {

							switch (name) {

								//дуга между вершинами
								case 'arcTo': return (verticeTo) => {

									//Calculate the arc length between two points over a hyper-sphere
									//Reference: https://www.physicsforums.com/threads/calculate-the-arc-length-between-two-points-over-a-hyper-sphere.658661/post-4196208
									const a = vertice, b = verticeTo, R = 1, acos = Math.acos;
									let ab = 0;//dot product
									for (let i = 0; i &lt; a.length; i++) ab += a[i] * b[i];
									return R * acos(ab / (R * R))
									
								}
								//расстояние между вершинами по прямой в декартой системе координат
								//Если надо получить расстояние между вершинами по дуге в полярной системе координат, то надо вызвать 
								//classSettings.settings.object.geometry.position.angles[verticeId].distanceTo
								case 'distanceTo': return (verticeTo) => {

									if (verticeTo.length != vertice.length) {

										console.error(sHuperSphere + ': vertice.distanceTo. Invalid vertice.length.');
										return;
										
									}
									let distance = 0;
									vertice.forEach((axis, i) => distance += Math.pow(axis - verticeTo[i], 2));
									return Math.sqrt(distance);
									
								}
								case 'edges':

									_vertice.edges = _vertice.edges || new Proxy([], {

										get: (edges, name) => {

											switch (name) {

												case 'push': return (edgeId, verticeId) => {

													const sPush = sHuperSphere + ': Vertice' + (verticeId === undefined ? '' : '[' + verticeId + ']') + '.edges.push(' + edgeId + '):';

													if (edges.length >= _this.verticeEdgesLength) {

														console.error(sPush + ' invalid edges.length = ' + edges.length);
														return;

													}
													//find for duplicate edgeId
													for (let j = 0; j &lt; edges.length; j++) {

														if (edges[j] === edgeId) {

															console.error(sPush + ' duplicate edgeId: ' + edgeId);
															return;

														}

													}

													edges.push(edgeId);

												}

											}
											return edges[name];

										},
									});
									return _vertice.edges;

								case 'angles': return _vertice;
								case 'vector':
									//для совместимости с Player.getPoints. Туда попадает когда хочу вывести на холст точки вместо ребер и использую дя этого MyPoints вместо ND
									const vertice2 = vertice[2], vertice3 = vertice[3];
									//Если вернуть THREE.Vector4 то будет неправильно отображаться цвет точки
									if (vertice3 === undefined)
										return new three.THREE.Vector3(vertice[0], vertice[1], vertice2 === undefined ? 0 : vertice2);
									return new three.THREE.Vector4(vertice[0], vertice[1], vertice2 === undefined ? 0 : vertice2, vertice3 === undefined ? 1 : vertice3);
								case 'x': return vertice[0];
								case 'y': return vertice[1];
								case 'z': return vertice[2];
								case 'w': return vertice[3];//для совместимости с Player.getColors. Туда попадает когда хочу вывести на холст точки вместо ребер и использую для этого MyPoints вместо ND
									

							}
							if (!isNaN(parseInt(name))) return vertice[name] === undefined ? 0 : vertice[name];
							return vertice[name];

						},
						set: (vertice, name, value) => {

							switch(name) {

								case 'edges':
									_vertice[name] = value;
									if (value === undefined) delete _vertice[name];
									return true;
									
							}
							vertice[name] = value;
							return true;

						}

					});

				}
				switch (name) {

					case 'angles': return new Proxy(_position, {

						get: (angles, name) => {

							const verticeId = parseInt(name);
							if (isNaN(verticeId)) {

								console.error(sHuperSphere + ': Get vertice angles failed. Invalid verticeId = ' + verticeId);
								return;
								
							}
							const vertice = new Proxy(angles[name], {
								
								get: (angles, name) => {
		
									switch (name) {

										case 'middleVertice': return (oppositeVerticesId = vertice.oppositeVerticesId) => {

											//find middle vertice between opposite vertices

											//https://wiki5.ru/wiki/Mean_of_circular_quantities#Mean_of_angles Среднее значение углов

											//массив для хранения сумм декартовых координат прпотивоположных вершин
											//для 1D вселенной это: aSum[0] = x, aSum[1] = y.
											//для 2D вселенной это: aSum[0] = x, aSum[1] = y, aSum[2] = z.
											//для 3D вселенной это: aSum[0] = x, aSum[1] = y, aSum[2] = z, aSum[3] = w.
											const aSum = [];
											for (let i = 0; i &lt; _this.dimension; i++) aSum.push(0.0);
											
											oppositeVerticesId.forEach(oppositeAngleId => {

												const oppositeVertice = position[oppositeAngleId];
												oppositeVertice.forEach((axis, i) => aSum[i] += axis);
											
											});
											const muddleVertice = _this.vertice2angles(aSum);
											if (classSettings.debug &amp;&amp; classSettings.debug.middleVertice) {

												console.log('');
												oppositeVerticesId.forEach(oppositeVerticeId => {
													
													const verticeAngles = position[oppositeVerticeId].angles;
													console.log('vertice[' + oppositeVerticeId + '] anlges: ' + JSON.stringify(verticeAngles));
												
												});
												console.log('Middle vertice angles: ' + JSON.stringify(muddleVertice));
												
											}
											return muddleVertice;
											
										}
										//идентификаторы всех вершин, которые связаны с текущей вершиной через ребра
										case 'oppositeVerticesId': return new Proxy(angles.edges, {

											get: (verticeEdges, name) => {

												const i = parseInt(name);
												if (!isNaN(i)) {
			
													const edge = settings.object.geometry.indices.edges[verticeEdges[i]];
													if (verticeId === edge[0]) return edge[1];
													if (verticeId === edge[1]) return edge[0];
													console.error(sHuperSphere + ': Get oppositeVerticesId failed.');
													return;
													
												}
												return verticeEdges[name];
											
											}
												
										});
											
									}
									return angles[name];
									
								},
							
							});
							return vertice;
							
						},
						set: (angles, name, value) => {

							const i = parseInt(name);
							if (!isNaN(i)) {
								
								const verticeAngles = angles[i];
								if (classSettings.debug &amp;&amp; ((verticeAngles.length != (_this.dimension - 1)) || (value.length != (_this.dimension - 1)))) console.error(sHuperSphere + ': Set vertice[' + i + '] angles failed. Invalid angles count.')
								for(let j = 0; j &lt; value.length; j++) verticeAngles[j] = value[j];

							} else angles[name] = value;
							return true;

						}
					});
					case 'count': return _position.count === undefined ? _position.length : _position.count;
					case 'push': return (position) => { console.error(sHuperSphere + ': deprecated push vertice. Use "settings.object.geometry.angles.pushRandomAngle()" instead.'); };

					//for debug
					case 'test': return () => {

						if (!classSettings.debug) return;

						_position.forEach((verticeAngles, verticeId) => {

							for (let angleId = 0; angleId &lt; verticeAngles.length; angleId++) {

								const angle = verticeAngles[angleId], range = angles.ranges[angleId];
								if((angle &lt; range.min) || (angle > range.max)) console.error(sHuperSphere + ': ' + range.angleName + ' angle[' + angleId + '] = ' + angle + ' of the vertice ' + verticeId + ' is out of range from ' + range.min + ' to ' + range.max);
								
							}
							const vertice = settings.object.geometry.position[verticeId], strVerticeId = 'vertice[' + verticeId + ']'
							_this.TestVertice(vertice, strVerticeId);
							vertice.edges.forEach(edgeId => {

								if (typeof edgeId !== "number") console.error(sHuperSphere + ': position.test()', strVerticeId = 'position(' + verticeId + ')' + '. ' + strVerticeId + '. Invalid edgeId = ' + edgeId);

							});

						})
					}

				}
				return _position[name];

			},
			//set settings.object.geometry.position
			set: (_position, name, value) => {

				const i = parseInt(name);
				if (!isNaN(i)) {

					if (value instanceof Array === true) {//для совместимости с Player.getPoints. Туда попадает когда хочу вывести на холст точки вместо ребер и использую дя этого MyPoints вместо ND

						console.warn(sHuperSphere + ': Set vertice was deprecated. Use set angle instead.')
						const angles = this.vertice2angles(value);
						if(classSettings.debug) {

							const angles2vertice = this.angles2Vertice(angles);
							if (angles2vertice.length != value.length) console.error(sHuperSphere + ': Set vertice failed. angles2vertice.length = ' + angles2vertice.length + ' is not equal value.length = ' + value.length);
							const d = 0;
							angles2vertice.forEach((axis, i) => { if(Math.abs(axis - value[i]) > d) console.error(sHuperSphere + ': Set vertice failed. axis = ' + axis + ' is not equal to value[' + i + '] = ' + value[i]) } );
							
						}
						settings.object.geometry.position[i].angles(angles);

					}

				} else _position[name] = value;
				return true;

			}

		});
		const position = settings.object.geometry.position;
		
		settings.object.geometry.indices = settings.object.geometry.indices || [];
		if (!(settings.object.geometry.indices instanceof Array)) {

			const indices = [];
			Object.keys(settings.object.geometry.indices).forEach((key) => indices[key] = settings.object.geometry.indices[key]);
			settings.object.geometry.indices = indices;
			
		}
		const indices = settings.object.geometry.indices;
		indices[0] = indices[0] || [];
		if (indices.edges)
			if(indices.edges instanceof Array) {
				
				indices[0] = indices.edges;
				indices[0].count = indices.edges.length;
				
			} else {

				const edges = indices[0];
				Object.keys(indices.edges).forEach((key) => edges[key] = indices.edges[key]);
				indices.edges = edges;
				
			}
		indices.edges = new Proxy(indices[0], {
			
			get: (_edges, name) => {

				const edgeId = parseInt(name);
				if (!isNaN(edgeId)) {

					let edge = _edges[edgeId];
					return edge;
					
				}
				const setVertice = (edge, edgeVerticeId, verticeId, edgeId) => {

					if (verticeId >= position.length) verticeId = 0;
					const vertice = position[verticeId];//push random vertice if not exists
					if (edgeVerticeId != undefined) edge[edgeVerticeId] = verticeId;

					vertice.edges.push(edgeId === undefined ? _edges.length : edgeId, verticeId);
					
				}
				switch (name) {

					case 'setVertices': return () => {

						if (_edges.length > 0) _this.boTestVertice = false;
						/*пока что это не нужно
						_edges.forEach((edge, edgeId) => {

							setVertice(edge, undefined, edge[0], edgeId);
							setVertice(edge, undefined, edge[1], edgeId);
							
						})
						*/

					}
					case 'push': return (edge=[]) => {

						let vertice0Id = edge[0] === undefined ? _edges.length : edge[0],
							  vertice1Id = edge[1] === undefined ? _edges.length + 1 : edge[1];
						const sPushEdge = ': Push edge. '
						if ((vertice0Id >= position.length) || (vertice1Id >= position.length)) {

							console.error(sHuperSphere + sPushEdge + 'edge[' + vertice0Id + ', ' + vertice1Id + ']. Invalid vertice range from 0 to ' + (position.length - 1));
							return;

						}
						if ((position[vertice0Id].edges.length >= _this.verticeEdgesLength) || (position[vertice1Id].edges.length >= _this.verticeEdgesLength))
							return;//Не добавлять новое ребро если у его вершин количество ребер больше или равно _this.verticeEdgesLength
						setVertice(edge, 0, vertice0Id);
						setVertice(edge, 1, vertice1Id);
						if (classSettings.debug) {
							
							if (edge.length != 2) console.error(sHuperSphere + sPushEdge + 'Invalid edge.length = ' + edge.length);
							else if (edge[0] === edge[1]) console.error(sHuperSphere + sPushEdge + 'edge = [' + edge + '] Duplicate vertices.');
							_edges.forEach((edgeCur, i) => { if (((edgeCur[0] === edge[0]) &amp;&amp; (edgeCur[1] === edge[1])) || ((edgeCur[0] === edge[1]) &amp;&amp; (edgeCur[1] === edge[0]))) console.error(sHuperSphere + sPushEdge + 'edges[' + i + ']. Duplicate edge[' + edge + ']') });

						}

						return _edges.push(edge);

					}
					case 'pushEdges': return (edge=[]) => {

						_edges.count = _edges.count || 3;
						for (let i = 0; i &lt; _edges.count; i++) {
							
							const edge = _edges[i];
							if (edge){

								setVertice(edge, 0, edge[0], i);
								setVertice(edge, 1, edge[1], i);

							} else {
								
								if(i === (_edges.count - 1)) indices.edges.push([settings.object.geometry.position.length - 1, 0])//loop edges
								else indices.edges.push();

							}

						}
						
					}

				}
				return _edges[name];

			},
			//set indices.edges
			set: (_edges, name, value) => {

				switch(name){

					case 'length':
						const position = settings.object.geometry.position;
						for (let i = value; i &lt; settings.object.geometry.position.length; i++) position[i].edges = undefined;//delete position[i].edges;
						break;
						
				}
				_edges[name] = value;
				return true;
				
			}

		});
		indices.edges.setVertices();

		//Эту функцию надо содать до вызова this.pushEdges(); потому что когда используется MyPoints для вывода на холст вершин вместо ребер,
		//вызывается this.project вместо this.pushEdges()
		/**
		 * Projects the universe onto the canvas 
		 * @param {THREE.Scene} scene [THREE.Scene]{@link https://threejs.org/docs/index.html?q=sce#api/en/scenes/Scene}
		 * @param {object} [params={}] The following parameters are available
		 * @param {object} [params.center={x: 0.0, y: 0.0, z: 0.0}] center of the universe
		 * @param {float} [params.center.x=0.0] X axis of the center
		 * @param {float} [params.center.y=0.0] Y axis of the center
		 * @param {float} [params.center.z=0.0] Z axis of the center
		 */
		this.project = (scene, params = {}) => {

			if (scene) {

				_this.classSettings.projectParams = _this.classSettings.projectParams || {};
				_this.classSettings.projectParams.scene = scene;
				
			} else scene = _this.classSettings.projectParams.scene;
			
			let nd, myPoints;
			this.object = () => { return  nd &amp;&amp; nd.object3D ? nd.object3D : myPoints ? myPoints : undefined; }
			const aAngleControls = [];

			this.objectOpacity = 0.3;
			this.opacityObject3D = (object3D, transparent, opacity = this.objectOpacity) => {

				object3D.material.transparent = transparent;
				object3D.material.opacity = transparent ? opacity : 1;
				object3D.material.needsUpdate = true;//for THREE.REVISION = "145dev"
					
			}
			this.opacity = (transparent = true, opacity = this.objectOpacity) => {

				if (!nd) {
					
					myPoints.userData.opacity(transparent ? opacity : 1);
					return;

				}
				this.opacityObject3D(nd.object3D, transparent, opacity);
					
			}

			const removeObject = (object) => {

				if (!object) return;
				scene.remove(object);
				if (options.guiSelectPoint) options.guiSelectPoint.removeMesh(object);
				
			}
			
			//remove previous universe
			this.remove = (scene) => {

				if (classSettings.boRemove === false) return;
				for (var i = scene.children.length - 1; i >= 0; i--) {

					const child = scene.children[i];
					this.remove(child);
					removeObject(child);

				}

			}
			this.remove(scene);
			this.removeHuperSphere = () => {

				const object = _this.object();
				if (nd) nd = undefined;
				if (myPoints) myPoints = undefined;
				removeObject(object);

			}
			this.removeMesh = () => {

				settings.object.geometry.indices.edges.length = 0;
				_this.remove(classSettings.projectParams.scene);
				if (nd) nd = undefined;
				if (myPoints) myPoints = undefined;

			}

			this.Test();

			this.color();

			if (this.setW) this.setW();

			this.isUpdate = true;
			this.update = (verticeId, changedAngleId) => {

				if (!this.isUpdate) return;
				const points = nd &amp;&amp; (nd.object3D.visible === true) ? nd.object3D : myPoints,
					vertice = settings.object.geometry.position[verticeId],
					itemSize = points.geometry.attributes.position.itemSize;
				if (verticeId != undefined) for (let axesId = 0; axesId &lt; itemSize; axesId++)
					points.geometry.attributes.position.array [axesId + verticeId * itemSize] = vertice[axesId] != undefined ? vertice[axesId] : 0.0;
				points.geometry.attributes.position.needsUpdate = true;
				if (settings.options.axesHelper)
					settings.options.axesHelper.updateAxes();
				const guiSelectPoint = settings.options.guiSelectPoint;
				if (guiSelectPoint) {
					
					guiSelectPoint.setReadOnlyPosition(false);
					settings.options.guiSelectPoint.update(true);
					guiSelectPoint.setReadOnlyPosition(true);
					const setControl = (control) => {

						if (!control || !control.getValue()) return;
						control.setValue(false);
						control.setValue(true);
						
					}
					setControl(aAngleControls.cHighlightEdges);
					setControl(aAngleControls.cMiddleVertice);
					
					if (aAngleControls.cross) {
						
						aAngleControls.cross.position.copy(settings.object.geometry.position[aAngleControls.oppositeVerticeId]);
						if (aAngleControls.cross.position.z === undefined) aAngleControls.cross.position.z = 0;

					}
					
					if (aAngleControls.arc) aAngleControls.createArc();
					
					if (aAngleControls.planes) aAngleControls.planes.update(changedAngleId);//vertice);

				}
				
			}
			this.projectGeometry = () => {

				this.line = (settings) => {

/*					
					settings.object.geometry.indices = settings.object.geometry.indices || {}
					settings.object.geometry.indices.edges = settings.object.geometry.indices.edges || {}
*/					
					return this.newHuperSphere(
						classSettings.settings.options,
						{
	
							cookieName: settings.cookieName,
							boRemove: false,
							boGui: false,
							edges: settings.edges === undefined? {
	
								project: true,//Если линия создается в виде ребер, то отображать ребра на холсте
								creationMethod: HuperSphere.edgesCreationMethod.Random,
	
							} : settings.edges,
							projectParams: { scene: classSettings.projectParams.scene, },
/*							
							debug: {
	
								probabilityDensity: false,
	
							},
							//debug: false,
*/
							debug: classSettings.debug,
							settings: {
	
								object: {
	
									name: settings.object.name,
									color: settings.object.color,
									geometry: {

										MAX_POINTS: settings.object.geometry.MAX_POINTS,
										angles: settings.object.geometry.angles,
										opacity: settings.object.geometry.opacity,
										indices: {
	
											/*
											edges: {
											
												count: 3,
										
											}
											*/
											edges: settings.object.geometry.indices.edges,
	
										}
	
									}
	
								}
	
							},
	
						});
					
				}
				const intersection = (parent) => {

					if (!classSettings.intersection) return;

					if (classSettings.intersection.position === undefined) classSettings.intersection.position = 0;
					const mesh = this.intersection(classSettings.intersection.color === undefined ? "lightgray" ://0x0000FF : //blue
						classSettings.intersection.color, scene);

					//Localization

					const lang = {

						intersector: 'Intersector',

					};

					switch (options.getLanguageCode()) {

						case 'ru'://Russian language

							lang.intersector = 'Сечение';

							break;

					}
					mesh.name = lang.intersector;
					parent.add(mesh);
					if (options.guiSelectPoint) options.guiSelectPoint.addMesh(mesh);

				},
					guiSelectPoint = settings.options.guiSelectPoint,
					gui = (object) => {

						const anglesDefault = [];
						object.userData.gui = {
							
							get isLocalPositionReadOnly(){ return true; },
							setValues: (verticeId) => {

								//пользователь выбрал вершину
								
								anglesDefault.length = 0;
								const verticeAngles = angles[verticeId];

								for (let i = (aAngleControls.cEdges.__select.length - 1); i > 0; i--)
									aAngleControls.cEdges.__select.remove(i);
								_display(aAngleControls.fOppositeVertice.domElement, false);

								if (verticeAngles.edges) {
									
									const edges = settings.object.geometry.indices.edges;
									verticeAngles.edges.forEach(edgeId => {
										
										const opt = document.createElement('option'),
											edge = edges[edgeId];
										opt.innerHTML = '(' + edgeId + ') ' + verticeId + ', ' + (edge[0] === verticeId ? edge[1] : edge[1] === verticeId ? edge[0] : console.error(sHuperSphere + ': Vertice edges GUI. Invalid edge vertices: ' + edge));
										opt.setAttribute('value', edgeId);
										aAngleControls.cEdges.__select.appendChild(opt);
										
									});

								}
								
								aAngleControls.verticeId = verticeId;

								//если оставить эту линию то если угол выходит за пределы допустимого,
								//то этот угол автоматически возвращается в пределы допустимого с помощью органа управления gui
								//Но это не отображается на изображении вселенной
								//_this.isUpdate = false;
								
								for (let i = 0; i &lt; verticeAngles.length; i++){

									const angle = verticeAngles[i], cAngle = aAngleControls[i], min = cAngle.__min, max = cAngle.__max;
									cAngle.setValue(angle);
									if ((angle &lt; min) || (angle > max)) {
										
										//Localization
					
										const lang = {
					
											error: '%n = %s  of the %v vertice is out of range from %min to %max',
					
										};
					
										switch (options.getLanguageCode()) {
					
											case 'ru'://Russian language
					
												lang.error = '%n = %s вершины %v выходит из допустимого диапазона от %min до %max';
					
												break;
					
										}

										alert(lang.error.replace('%s', angle).
											  replace('%n', cAngle.__li.querySelector( ".property-name" ).innerHTML).
											  replace('%v', verticeId).
											  replace('%min', min).
											  replace('%max', max)
											 );

									}
									anglesDefault.push(angle);
									
								}

							},
							reset: (verticeId) => {

								const resetControl = (control) => {

										if (!control) return;
										const boValue = control.getValue();
										control.setValue(false);//Убрать выделенные ребра.
										if ((verticeId != -1) &amp;&amp; boValue) control.setValue(boValue);//если у предыдущей вершины выделялись ребра, то и у новой вершины выделять ребра
										
									};
								resetControl(aAngleControls.cHighlightEdges);
								resetControl(aAngleControls.cMiddleVertice);
								resetControl(aAngleControls.cPlanes);

								if (aAngleControls.removeCross) aAngleControls.removeCross();
								if (aAngleControls.removeArc) aAngleControls.removeArc();
								
							},
							addControllers: (fParent) => {

								//Localization
	
								const getLanguageCode = options.getLanguageCode;
	
								const lang = {
	
									advansed: 'Advansed',
									
									angles: 'Angles',
									anglesTitle: 'Polar coordinates.',
									
									angle: 'Angle',

									edges: 'Edges',
									edgesTitle: 'Edges indexes of the vertice',
									oppositeVertice: 'Opposite vertice',

									highlightEdges: 'Highlight',
									highlightEdgesTitle: 'Highlight edges of the vertice.',
								
									middleVertice: 'Middle vertice',
									middleVerticeTitle: 'Find middle vertice between opposite vertices.',

									plane: 'Plane',
									planes: 'Planes',
									planesTitle: 'Planes of rotation of angles.',
									
									defaultButton: 'Default',
									defaultAnglesTitle: 'Restore default angles.',

									notSelected: 'not selected',
									arc: 'Arc',
	
								};
	
								const _languageCode = getLanguageCode();
	
								switch (_languageCode) {
	
									case 'ru'://Russian language
	
										lang.advansed = 'Дополнительно';
										
										lang.angles = 'Углы';
										lang.anglesTitle = 'Полярные координаты.';
										
										lang.angle = 'Угол';

										lang.edges = 'Ребра';
										lang.edgesTitle = 'Индексы ребер, имеющих эту вершину';
										lang.oppositeVertice = 'Противоположная вершина';

										lang.highlightEdges = 'Выделить';
										lang.highlightEdgesTitle = 'Выделить ребра этой вершины.';

										lang.middleVertice = 'Средняя';
										lang.middleVerticeTitle = 'Найти среднюю вершину между противоположными вершинами.';

										lang.plane = 'Плоскость';
										lang.planes = 'Плоскости';
										lang.planesTitle = 'Плоскости вращения углов.';

										lang.defaultButton = 'Восстановить';
										lang.defaultAnglesTitle = 'Восстановить углы по умолчанию';
										
										lang.notSelected = 'Не выбрано';
										lang.arc = 'Дуга';
										
										break;
									default://Custom language
	
								}
								const geometry = settings.object.geometry,
									position = geometry.position,
									edges = geometry.indices.edges,
									dat = three.dat,
									fAdvansed = fParent.addFolder(lang.advansed);

								//Angles

								const createAnglesControls = (fParent, aAngleControls, anglesDefault) => {
									
									const fAngles = fParent.addFolder(lang.angles);
									dat.folderNameAndTitle(fAngles, lang.angles, lang.anglesTitle);
									for (let i = 0; i &lt; (_this.dimension - 1); i++) {
	
										const range = angles.ranges[i];
										const cAngle = fAngles.add({ angle: 0, }, 'angle', range.min, range.max, 2 * π / 360).onChange((angle) => {
											
												angles[aAngleControls.verticeId][i] = angle;
												_this.update(aAngleControls.verticeId, i);
	
											});
										const name = (i) => {
							
											//Localization
											
											const lang = [
									
												'Altitude',
												'Latitude',
												'Longitude',
									
											]
									
											switch (options.getLanguageCode()) {
									
												case 'ru'://Russian language
									
													lang[0] = 'Высота';
													lang[1] = 'Широта';
													lang[2] = 'Долгота';
													break;
									
											}
											return lang[i + 4 - _this.dimension];
											
										}
										dat.controllerNameAndTitle(cAngle, name(i));
									
										aAngleControls.push(cAngle);
										
									}
								
									//Restore default angles.
									const cRestoreDefaultAngles = fAngles.add( {
						
										defaultF: () => { aAngleControls.forEach((cAngle, i) => cAngle.setValue(anglesDefault[i])); },
						
									}, 'defaultF' );
									dat.controllerNameAndTitle( cRestoreDefaultAngles, lang.defaultButton, lang.defaultAnglesTitle );
									
									return fAngles;

								}
								const fAngles = createAnglesControls(fAdvansed, aAngleControls, anglesDefault);


								//Edges
								
								aAngleControls.cEdges = fAdvansed.add({ Edges: lang.notSelected }, 'Edges', { [lang.notSelected]: -1 }).onChange((edgeId) => {

									edgeId = parseInt(edgeId);
									_display(aAngleControls.fOppositeVertice.domElement, edgeId === -1 ? false : true);
									aAngleControls.removeArc = () => {

										if (aAngleControls.arc &amp;&amp; aAngleControls.arc.removeHuperSphere) aAngleControls.arc.removeHuperSphere();
										aAngleControls.arc = undefined;

									}
									aAngleControls.removeCross = () => {

										if (aAngleControls.cross) classSettings.projectParams.scene.remove(aAngleControls.cross);
										aAngleControls.cross = undefined;
										
									}
									let boTransparent;
									if (edgeId === -1) {
										
										aAngleControls.removeCross();
										aAngleControls.removeArc();
										aEdgeAngleControls.verticeId = undefined;
										boTransparent = false;
										
									} else {
										
										const sChangeVerticeEdge = ': Change vertice edge. ',
											edge = edges[edgeId],
											oppositeVerticeId = edge[0] === aAngleControls.verticeId ? edge[1] : edge[1] === aAngleControls.verticeId ? edge[0] : console.error(sHuperSphere + sChangeVerticeEdge + 'Invalid edge vertices: ' + edge),
											oppositeVerticeAngles = position[oppositeVerticeId].angles;
										if (oppositeVerticeAngles.length != aEdgeAngleControls.length) console.error(sHuperSphere + sChangeVerticeEdge + 'Invalid opposite vertice angles length = ' + oppositeVerticeAngles.length);
										aEdgeAngleControls.verticeId = oppositeVerticeId;
										edgeAnglesDefault.length = 0;
										for (let i = 0; i &lt; oppositeVerticeAngles.length; i++){

											const angle = oppositeVerticeAngles[i];
											aEdgeAngleControls[i].setValue(angle);
											edgeAnglesDefault.push(angle);

										}

										//рисуем крестик на противоположной вершине выбранного ребра
										aAngleControls.removeCross();
										vertices.length = 0;
										itemSize = undefined;
										const oppositeVertice = position[oppositeVerticeId],
											crossSize = 0.05;
										pushVertice([0, 0, crossSize]);
										pushVertice([0, 0, -crossSize]);
										pushVertice([-crossSize, -crossSize, 0]);
										pushVertice([crossSize, crossSize, 0]);
										pushVertice([crossSize, -crossSize, 0]);
										pushVertice([-crossSize, crossSize, 0]);
										aAngleControls.cross = addObject2Scene(vertices, 'white');
										aAngleControls.cross.position.copy(oppositeVertice);
										if (aAngleControls.cross.position.z === undefined) aAngleControls.cross.position.z = 0;
										aAngleControls.oppositeVerticeId = oppositeVerticeId;
										aAngleControls.MAX_POINTS = 1 + 2 * 2 * 2 * 2;// * 2 * 2 * 2;//17;//количество вершин дуги когда угол между крайними вершинами дуги 180 градусов. https://stackoverflow.com/questions/31399856/drawing-a-line-with-three-js-dynamically/31411794#31411794

										//Create arc between edge's vertices i.e between vertice and opposite vertice.
										aAngleControls.createArc = () => {

											let verticeId = 0;
//											const MAX_POINTS = 1 + 2 * 2 * 2 * 2;// * 2 * 2 * 2;//17;//количество вершин дуги когда угол между крайними вершинами дуги 180 градусов. https://stackoverflow.com/questions/31399856/drawing-a-line-with-three-js-dynamically/31411794#31411794
											//for (let i = 0; i &lt; maxLevel - 1; i++) aAngleControls.MAX_POINTS *= 2;
											//aAngleControls.MAX_POINTS++;
											const arcAngles = [],//массив вершин в полярной системе координат, которые образуют дугу
												//если не копировать каждый угол в отделности, то в новой вершине останутся старые ребра
												copyVertice = (vertice) => {

													const verticeAngles = _this.vertice2angles(vertice)
													if (aAngleControls.arc) {
														
														aAngleControls.arc.classSettings.settings.object.geometry.angles[verticeId] = verticeAngles;
														verticeId++;

													} else arcAngles.push(verticeAngles);
													
												},
												arcVerticesCount = 2,
												d = π / arcVerticesCount,
												cd = 1 / Math.sin(d),//Поправка для координат вершин что бы они равномерно располагались по дуге
												vertice = position[aAngleControls.verticeId], oppositeVertice = position[aAngleControls.oppositeVerticeId],
												distance = vertice.arcTo(oppositeVertice),
												arcCount = distance * (aAngleControls.MAX_POINTS - 1) / π;
											//Не получилось равномерно разделить дугу на части.
											//Если начало и конец дуги расположены напротив друг друга на окружности или на сфере или на 4D hypersphere
											//то все вершины стягиваются к началу и концу дуги за исключением вершины, расположенной посередине дуги
											//Поэтому вершины на дуге получаю путем деления дуги на пополам. Полученные половинки снова делю пополам и т.д.
											let maxLevel = 1;//на сколько частей делить дугу.
												//если maxLevel = 1 то дуга делится на 2 части с одной вершиной посередине
												//если maxLevel = 2 то дуга делится на 4 части с тремя вершинами посередине
												//если maxLevel = 3 то дуга делится на 8 частей с 7 вершинами посередине
												//Таким образом дугу можно разделит только на 2 в степени maxLevel частей
											let count = 2;
											while (count &lt; arcCount) {

												count *= 2;
												maxLevel++;
												
											}
											//console.log('vertice.angles[0] = ' + vertice.angles[0] + ' oppositeVertice.angles[0] = ' + oppositeVertice.angles[0] + ' distance = ' + distance + ' maxLevel = ' + maxLevel + (aAngleControls.arc ? ( ' position.count = ' + aAngleControls.arc.object().geometry.attributes.position.count): ''));
											let level = 1;//текущий уровень деления дуги
											copyVertice(vertice);
											let i = 0;
											let halfArcParams = { vertice: vertice, oppositeVertice: oppositeVertice, level: level };
											if (aAngleControls.progressBar) aAngleControls.progressBar.boStop = true;
											aAngleControls.progressBar = new ProgressBar(
												undefined,//settings.options.renderer.domElement.parentElement,
												(progressBar, index, callback) => {

													if (progressBar.boStop) {

														//Этот процес вычисления дуги нужно остановть потому что начался другой процесс вычисления дуги
														progressBar.remove();
														return;

													}

													progressBar.value = i;
													i++;

													//делить дугу на две части

													if (callback) halfArcParams = callback;
													const vertice = halfArcParams.vertice,
														oppositeVertice = halfArcParams.oppositeVertice;
													let level = halfArcParams.level;

													const arcVerticeStep = [];//Шаги, с которым изменяются углы при построении дуги в полярной системе координат
													for (let k = 0; k &lt; vertice.length; k++)
														arcVerticeStep.push((oppositeVertice[k] - vertice[k]) / arcVerticesCount);
													const arcVerice = [];//Координаты вершины в полярной системе координат
													for (let j = 0; j &lt; vertice.length; j++) arcVerice.push(vertice[j] + arcVerticeStep[j] * cd);
													level++;
													if (level &lt;= maxLevel) {

														//если не делать это преобразование,
														//то когда начало и конец дуги на ходятся на противоположных концах вселенной,
														//средняя точка попадает в центр окружности или сферы или гиперсферы,
														//а это находится вне вселенной.
														//В этом случае все вершины дуги, кроме средней вершины, стягиваются к началу или концу дуги.
														const halfVertice = _this.angles2Vertice(_this.vertice2angles(arcVerice));

														progressBar.step({

															vertice: vertice, oppositeVertice: halfVertice, level: level,
															next: { vertice: halfVertice, oppositeVertice: oppositeVertice, level: level, next: halfArcParams.next }

														});

													} else {

														if (halfArcParams.next)
															progressBar.step(halfArcParams.next);
														copyVertice(arcVerice);
														copyVertice(oppositeVertice);
														if (!halfArcParams.next) {

															if (aAngleControls.arc) {
																
																const geometry = aAngleControls.arc.object().geometry;
																geometry.setDrawRange(0, verticeId * 2 - 1);//geometry.attributes.position.itemSize);//Непонятно почему draw count так вычисляется. Еще смотри class ND.constructor.create3DObject
																console.log(' maxLevel = ' + maxLevel + ' position.count = ' + aAngleControls.arc.object().geometry.attributes.position.count + ' drawRange.count = ' + aAngleControls.arc.object().geometry.drawRange.count + ' Vertices count = ' + verticeId);
																geometry.attributes.position.needsUpdate = true;
																
															} else {

																if (this.child) this.child.arc(aAngleControls, lang, arcAngles);
																else {
																	
																	const arcEdges = [];
																	for (let i = 0; i &lt; (aAngleControls.MAX_POINTS - 1); i++) arcEdges.push([i, i + 1]);
																	aAngleControls.arc = this.line({
						
																		cookieName: 'arc',//если не задать cookieName, то настройки дуги будут браться из настроек вселенной
																		//edges: false,
																		object : {
																			
																			name: lang.arc,
																			geometry: {
											
																				MAX_POINTS: aAngleControls.MAX_POINTS,
																				angles: arcAngles,
																				//opacity: 0.3,
																				indices: {
											
																					edges: arcEdges,
						
																				}
																				
																			}
						
																		},
																		
																	});

																}
																
															}
															console.log(' maxLevel = ' + maxLevel + ' position.count = ' + aAngleControls.arc.object().geometry.attributes.position.count + ' drawRange.count = ' + aAngleControls.arc.object().geometry.drawRange.count + ' Vertices count = ' + verticeId);
															//console.log('array =' + aAngleControls.arc.object().geometry.attributes.position.array);
															const distance = position[aAngleControls.verticeId].arcTo(position[aAngleControls.oppositeVerticeId]);
															if (classSettings.debug) {
										
																let vertice, distanceDebug = 0;
																const position = aAngleControls.arc.classSettings.settings.object.geometry.position;
																for (let i = 0; i &lt; (verticeId === 0 ? position.length: verticeId); i++) {
										
																	const verticeCur = position[i];
																	if (vertice)
																		distanceDebug += vertice.distanceTo(verticeCur);
																	vertice = verticeCur;
																	
																}
																console.log('distance = ' + distance + ' distanceDebug = ' + distanceDebug + ' error = ' + (distanceDebug - distance) + ' arcAngles.length = ' + arcAngles.length);
																
															}
															progressBar.remove();
															aAngleControls.progressBar = undefined;

														}

													}

												}, {

												sTitle: 'Long time iteration process',
												max: maxLevel * maxLevel - 2,

											});
											
										}
										aAngleControls.createArc();
										boTransparent = true;
										
									}
									_this.opacity(boTransparent);

					
								});
								aAngleControls.cEdges.__select[0].selected = true;
								dat.controllerNameAndTitle(aAngleControls.cEdges, lang.edges, lang.edgesTitle);
								const aEdgeAngleControls = [],
									edgeAnglesDefault = [];
								aAngleControls.fOppositeVertice = fAdvansed.addFolder(lang.oppositeVertice);
								_display(aAngleControls.fOppositeVertice.domElement, false);
								createAnglesControls(aAngleControls.fOppositeVertice, aEdgeAngleControls, edgeAnglesDefault);

								let itemSize;
								const vertices = [],
									pushVertice = (vertice) => {

										if (itemSize === undefined) itemSize = vertice.length;
										else if (itemSize != vertice.length) console.error(sHuperSphere + ': Middle vertice GUI. Invalid itemSize = ' + itemSize);
										vertice.forEach(axis => vertices.push(axis))

										//Каждая вершина должна иметь не меньше 3 координат что бы не поучить ошибку:
										//THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values. 
										for (let i = 0; i &lt; (3 - itemSize); i++) vertices.push(0);

									},
									addObject2Scene = (vertices, color) => {

										const buffer = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), itemSize > 3 ? itemSize : 3)),
											lineSegments = new THREE.LineSegments(buffer, new THREE.LineBasicMaterial({ color: color, }));
										classSettings.projectParams.scene.add(lineSegments);
										return lineSegments;

									}

								//highlight edges Подсветить ребра для этой вершины
								
								let oppositeVerticeEdges;
								aAngleControls.cHighlightEdges = fAdvansed.add({ boHighlightEdges: false }, 'boHighlightEdges').onChange((boHighlightEdges) => {

									_this.opacity(boHighlightEdges);
									if (boHighlightEdges) {
										
										const verticeId = aAngleControls.verticeId,
											angles = position.angles[verticeId];
										vertices.length = 0;
										itemSize = undefined;
										angles.edges.forEach(edgeId => {

											const edge = geometry.indices.edges[edgeId];
											edge.forEach(edgeVerticeId => { pushVertice(position[edgeVerticeId]); });

										});
										oppositeVerticeEdges = addObject2Scene(vertices, 'white');
										
									} else {

										if (oppositeVerticeEdges) classSettings.projectParams.scene.remove(oppositeVerticeEdges);
										oppositeVerticeEdges = undefined;
										
									}
									
								} );
								dat.controllerNameAndTitle(aAngleControls.cHighlightEdges, lang.highlightEdges, lang.highlightEdgesTitle);

								//Middle vertice
								
								let middleVerticeEdges;
								aAngleControls.cMiddleVertice = fAdvansed.add({ boMiddleVertice: false }, 'boMiddleVertice').onChange((boMiddleVertice) => {

									_this.opacity(boMiddleVertice);
									if (boMiddleVertice) {
										
										const verticeId = aAngleControls.verticeId,
											angles = position.angles[verticeId],
											oppositeVerticesId = angles.oppositeVerticesId,
											middleVertice = _this.angles2Vertice(angles.middleVertice(oppositeVerticesId));
										vertices.length = 0;
										itemSize = undefined;
										oppositeVerticesId.forEach(oppositeVerticeId => {
											
											pushVertice(middleVertice);
											pushVertice(position[oppositeVerticeId]);
											
										});
										middleVerticeEdges = addObject2Scene(vertices, 'blue');
										
									} else {

										if (middleVerticeEdges) classSettings.projectParams.scene.remove(middleVerticeEdges);
										middleVerticeEdges = undefined;
										
									}
									
								} );
								dat.controllerNameAndTitle(aAngleControls.cMiddleVertice, lang.middleVertice, lang.middleVerticeTitle);

								//Planes of rotation of angles.

								aAngleControls.cPlanes = fAdvansed.add({ boPlanes: false }, 'boPlanes').onChange((boPlanes) => {

									
									if (!boPlanes) {
										
										if (aAngleControls.planes) aAngleControls.planes.forEach((plane) => plane.removeHuperSphere())
										aAngleControls.planes = undefined;
										return;

									}

									const vertice = position.angles[aAngleControls.verticeId],
										longitudeId = this.dimension - 2, latitudeId = longitudeId - 1, altitudeId = latitudeId - 1;
									const planeGeometry = (verticeAngleId, planeAngles) => {
										
										const plane = aAngleControls.planes ? aAngleControls.planes[verticeAngleId] : undefined;
										planeAngles ||= plane.classSettings.settings.object.geometry.angles;
										let planeVerticeId = 0;

										let start, stop;//, step;
										switch (verticeAngleId) {

											case latitudeId:
												/*
												start = - π / 2; stop = π / 2;//, step = 1;
												break;
												*/
											case longitudeId:
											case altitudeId:
												start = -π; stop = π;//, step = 2;
												break;
											default: console.error(sHuperSphere + ': Planes of rotation of angles. Invalid verticeAngleId = ' + verticeAngleId);

										}
										for (let i = start; i &lt;= stop; i = i + (π / 20))
										//for (let i = -π; i &lt;= π; i = i + (π / 20))
										{

											const planeAngle = [];
											const vertice = position.angles[aAngleControls.verticeId];
											for (let verticeAngleId = 0; verticeAngleId &lt; vertice.length; verticeAngleId++) planeAngle.push(vertice[verticeAngleId]);
											planeAngle[verticeAngleId] = i;

											if (this.classSettings.debug) console.log(sHuperSphere + ': ' + settings.object.geometry.angles.ranges[verticeAngleId].angleName + '. VerticeId = ' + planeAngles.length);
											planeAngles[planeVerticeId++] = this.vertice2angles(this.angles2Vertice(planeAngle));

										}
										if (plane) plane.object().geometry.attributes.position.needsUpdate = true;

									}
									for (let verticeAngleId = 0; verticeAngleId &lt; vertice.length; verticeAngleId++) {

										const planeAngles = [],
											angleName = settings.object.geometry.angles.ranges[verticeAngleId].angleName;
										planeGeometry(verticeAngleId, planeAngles);
										const planeEdges = [];
										for (let i = 0; i &lt; (planeAngles.length - 1); i++) planeEdges.push([i, i + 1]);
										if (!aAngleControls.planes) {
												
											aAngleControls.planes = [];
											aAngleControls.planes.update = (changedAngleId) => {
												
												this.planesGeometry(changedAngleId, aAngleControls, planeGeometry, longitudeId);

											}

										}
										aAngleControls.planes[verticeAngleId] = this.line({

											cookieName: 'plane_' + verticeAngleId,//если не задать cookieName, то настройки дуги будут браться из настроек вселенной
											object : {
													
												name: angleName,
												color: 'white',
												geometry: {
					
													angles: planeAngles,
													opacity: 0.3,
													indices: { edges: planeEdges, }
														
												}

											},
												
										});
										const plane = aAngleControls.planes[verticeAngleId];
										plane.opacity();
										
									}

								});
								dat.controllerNameAndTitle(aAngleControls.cPlanes, lang.planes, lang.planesTitle);
								
								return fAdvansed;
	
							},

						}

					};
				if ((classSettings.edges != false) &amp;&amp; classSettings.edges.project) {
	
					if (myPoints) {
						
						myPoints.visible = false;
						if (options.eventListeners) options.eventListeners.removeParticle(myPoints);
						if (guiSelectPoint) {
							
							guiSelectPoint.removeMesh(myPoints, false);
							myPoints.children.forEach(child => guiSelectPoint.removeMesh(child, false));
							
						}

					}
					if (nd) {
						
						nd.object3D.visible = true;
						if (options.eventListeners) options.eventListeners.addParticle(nd.object3D);
						if (guiSelectPoint) {
							
							guiSelectPoint.addMesh(nd.object3D);
							nd.object3D.children.forEach(child => guiSelectPoint.addMesh(child));

						}
						
					} else {
						
						settings.scene = scene;
						if ((settings.object.geometry.indices.edges.length === 0)) this.pushEdges();
						else {
							
							if ((settings.object.geometry.position[0].length > 3 ) &amp;&amp; (!settings.object.color)) settings.object.color = {};//Color of vertice from palette
							nd = new ND(this.dimension, settings);
			
							params.center = params.center || {}
							nd.object3D.position.x = params.center.x || 0;
							nd.object3D.position.y = params.center.y || 0;
							nd.object3D.position.z = params.center.z || 0;

							gui(nd.object3D);
							
							intersection(nd.object3D);

							if (this.onSelectScene) this.onSelectScene();

						}

					}
	
				} else {
	
					if (nd) {
	
						nd.object3D.visible = false;
						if (options.eventListeners) options.eventListeners.removeParticle(nd.object3D);
						if (guiSelectPoint) {
							
							guiSelectPoint.removeMesh(nd.object3D);
							nd.object3D.children.forEach(child => guiSelectPoint.removeMesh(child, false));

						}
	
					}
					if (myPoints) {

						if (myPoints.visible != true) {
							
							myPoints.visible = true;
							if (options.eventListeners) options.eventListeners.addParticle(myPoints);
							if (guiSelectPoint) {
								
								guiSelectPoint.addMesh(myPoints);
								myPoints.children.forEach(child => guiSelectPoint.addMesh(child));
	
							}

						}
						
					} else {
						
						let points = settings.object.geometry.position;
		
						//for debug
						//Выводим углы вместо вершин. Нужно для отладки равномерного распределения верши во вселенной
						//См. randomPosition()
						/*
						points = [];
						settings.object.geometry.position.forEach(vertive => points.push(vertive.angles));
						*/

						if (
							(classSettings.settings.object.color != undefined) &amp;&amp;
							(typeof classSettings.settings.object.color != "object")
						) {

							const color = new three.THREE.Color(classSettings.settings.object.color);
							classSettings.settings.options.setPalette(new ColorPicker.palette( { palette: [{ percent: 0, r: color.r * 255, g: color.g * 255, b: color.b * 255, },] } ));
							
						}

						new MyPoints(points, scene, {
							
							pointsOptions: {
								
								name: settings.object.name,
								color: settings.object.color,
								colors: settings.object.geometry.colors,
								opacity: settings.object.geometry.opacity,
								onReady: (points) => {
									
									myPoints = points;
									gui(myPoints);
									intersection(points);
								
								},
								//shaderMaterial: false,
							
							},
							options: settings.options,
							
						});
		
					}
					
				}

			}
			this.projectGeometry();

			//шаг проигрывателя player
			//Вычислем middle vertices
			options.onSelectScene = (index, t) => {

				if (index === 0) return;
				const geometry = settings.object.geometry, position = geometry.position, edges = geometry.indices.edges;
				if (edges.length === 0) {

					//Create edges
					this.onSelectScene = () => {
						
						options.onSelectScene(index, t);
						delete this.onSelectScene;
					
					}
					if (cEdges) cEdges.setValue(true);
					else {

						//нет ручной настройки
						classSettings.edges = cookieOptions.edgesOld || edgesOld;
						_this.projectGeometry();

					}
					return;

				}
				let progressBar, verticeId = 0;
				if ((typeof WebGPU != 'undefined') &amp;&amp; WebGPU.isSupportWebGPU()) {

					const firstMatrix = [
						[1, 2, 3, 4],
						[5, 6, 7, 8]
					],
						secondMatrix = [
							[1, 2],
							[3, 4],
							[5, 6],
							[7, 8],
						];
					new WebGPU({

						input: { matrices: [firstMatrix, secondMatrix] },

						//shaderCode: shaderCode,
						shaderCodeFile: '../Shader.c',

						results: [

							{

								count: firstMatrix.length * secondMatrix[0].length +

									//result matrix has reserved three elements in the head of the matrix for size of the matrix.
									//First element is dimension of result matrix.
									//Second element is rows count of the matrix.
									//Third element is columns count of the matrix.
									//See settings.size of out2Matrix method in https://raw.githack.com/anhr/WebGPU/master/jsdoc/module-WebGPU-WebGPU.html
									3,
								out: out => {

									console.log('out:');
									console.log(new Float32Array(out));
									const matrix = WebGPU.out2Matrix(out);
									console.log('matrix:');
									console.log(matrix);

								}

							},
						],

					});

				}
				const vertices = [],
					timestamp = classSettings.debug ? window.performance.now() : undefined,
					step = () => {

						progressBar.value = verticeId;
						const stepItem = () => {

							vertices.push(position.angles[verticeId].middleVertice());
							verticeId += 1;
							if (verticeId >= position.length) {

								progressBar.remove();

								if (classSettings.debug) {
									
									classSettings.debug.logTimestamp('Play step. ', timestamp);

								}
								
								this.isUpdate = false;//для ускорения
								for (verticeId = 0; verticeId &lt; position.length; verticeId++) 
									position.angles[verticeId] = vertices[verticeId];//Обновление текущей вершины без обновления холста для экономии времени
								this.isUpdate = true;

								//обновляю позицию первой вершины что бы обновить холст
								position[0][0] = position[0][0];

								if (classSettings.debug) {
									
									classSettings.debug.logTimestamp('Copy vertices. ', timestamp);
									this.logHuperSphere();

								}
								options.player.continue();
								return true;

							}

						}
						if (!stepItem()) progressBar.step();

					};
				progressBar = new ProgressBar(options.renderer.domElement.parentElement, step, {

					sTitle: 't = ' + t + '&lt;br> Take middle vertices',
					max: position.length - 1,

				});
				return true;//player pause

			}

			if (classSettings.debug)
				classSettings.debug.logTimestamp('Project. ');

		}
		if (classSettings.mode === undefined) classSettings.mode = 0;//решил оставить режим, в котором сначала добавляются ребра а потом уже создаются вершины для них
		switch(classSettings.mode) {

			//connect vertices by edges
			case 0:

				//default vertices
				if (this.verticesCountMin === undefined) {

					console.error(sHuperSphere + ': Please define verticesCountMin in your child class.');
					break;

				}
				const count = position.count === undefined ? this.verticesCountMin : position.count;
				if (count &lt; 2) {

					console.error(sHuperSphere + ': Invalid classSettings.settings.object.geometry.position.count &lt; 2');
					return;

				}

				if (probabilityDensity) {

					//для 2D вселенной это плотность вероятности распределения вершин по поверхости сферы в зависимости от третьей координаты вершины z = vertice.[2]
					//Плотности разбил на несколько диапазонов в зависимости от третьей координаты вершины z = vertice.[2]
					//Разбил сферу на sc = 5 сегментов от 0 до 4.
					//Границы сегментов вычисляю по фомулам:
					//Высота сегмента hs = d / sc = 2 / 5 = 0.4
					//Нижняя граница hb = hs * i - r
					//Верхняя граница ht = hs * (i + 1) - r
					//где r = 1 - радиус сферыб d = 2 * r = 2 - диаметр сферы, i - индекс сегмента
					//0. From -1 to -0.6
					//1. From -0.6 to -0.2
					//2. From -0.2 to 0.2
					//3. From 0.2 to 0.6
					//4. From 0.6 to 1
					console.log('');
					console.log('Probability density.');
					const table = [];
					probabilityDensity.forEach((segment, segmentId) => {

						segment.density = segment.count / segment[_this.probabilityDensity.sectorValueName];//segment.square;
						segment.height = segment.ht - segment.hb;
						table.push(segment);

					})
					const sectorValueName = _this.probabilityDensity.sectorValueName;
					if (!sectorValueName) console.error(sHuperSphere + ': Invalid sectorValueName = ' + sectorValueName);
					console.table(table, ['count', 'hb', 'ht', 'height',
						sectorValueName,
						'density']);
					console.log('');
					classSettings.debug.logTimestamp('Push positions. ');

				}
				this.#verticeEdgesLength = this.verticeEdgesLengthMax;

				this.pushEdges = () => {

					const geometry = this.classSettings.settings.object.geometry, edges = geometry.indices.edges, position = geometry.position;

					//Localization

					const lang = { progressTitle: "Creating edges.&lt;br>Vertice's edges %s from " + this.verticeEdgesLength, };

					switch (settings.options.getLanguageCode()) {

						case 'ru'://Russian language

							lang.progressTitle = 'Создание ребер.&lt;br>Ребер у вершины %s из ' + this.verticeEdgesLength;

							break;

					}

					if (classSettings.edges.creationMethod === undefined) classSettings.edges.creationMethod = edgesCreationMethod.Random;//.NearestVertice;
					switch (classSettings.edges.creationMethod) {

						case edgesCreationMethod.Random:
							let verticeEdgesCur = 1, verticeId = 0,
								boCompleted = false;//Кажется это не нужно
							const progressBar = new ProgressBar(settings.options.renderer.domElement.parentElement, () => {

								const nextVertice = () => {

									progressBar.value = verticeId;

									//цикл поиска вершины, в которую можно добавить еще одно ребро
									const verticeIdStart = verticeId;
									do {

										verticeId++;
										if (verticeId >= position.length) {

											verticeEdgesCur++;
											progressBar.title(lang.progressTitle.replace('%s', verticeEdgesCur + 1));
											if (verticeEdgesCur >= this.verticeEdgesLength) {

												if (this.projectGeometry) this.projectGeometry();
												if (this.classSettings.debug) this.classSettings.debug.logTimestamp('Push edges. ');
												progressBar.remove();
												if (this.classSettings.projectParams) this.project(this.classSettings.projectParams.scene, this.classSettings.projectParams.params);
												boCompleted = true;
												return;// true;

											}
											verticeId = 0;

										}

									} while ((position[verticeId].edges.length >= this.verticeEdgesLength) &amp;&amp; (verticeIdStart != verticeId));
									progressBar.step();

								}
								if (boCompleted) return;
								let oppositeVerticeId = verticeId + 1;
								if (oppositeVerticeId >= position.length) oppositeVerticeId = 0;
								//Поиск вершины у которой ребер меньше максимального количества ребер и у которой нет нового ребра
								const oppositeVerticeIdFirst = oppositeVerticeId;
								while (true) {

									const oppositeVerticeEdges = position[oppositeVerticeId].edges;
									if (oppositeVerticeEdges.length &lt; this.verticeEdgesLength) {

										//поиск нового ребра в списке ребер этой вершины
										let boContinue = false;
										for (let oppositeVerticeEdgeId = 0; oppositeVerticeEdgeId &lt; oppositeVerticeEdges.length; oppositeVerticeEdgeId++) {

											const oppositeVerticeEdge = edges[oppositeVerticeEdges[oppositeVerticeEdgeId]];
											if (
												(oppositeVerticeEdge[0] === verticeId) &amp;&amp; (oppositeVerticeEdge[1] === oppositeVerticeId) ||
												(oppositeVerticeEdge[1] === verticeId) &amp;&amp; (oppositeVerticeEdge[0] === oppositeVerticeId)
											) {

												boContinue = true;//это ребро уже существует
												break;

											}

										}
										if (boContinue) {

											oppositeVerticeId++;
											if (oppositeVerticeId >= position.length) oppositeVerticeId = 0;
											continue;//Новое ребро уже есть в текущей вершине. Перейти на следующую вершину

										}
										break;//нашел противоположное ребро

									} else {

										oppositeVerticeId++;
										if (oppositeVerticeId >= position.length) oppositeVerticeId = 0;

									}
									if (oppositeVerticeIdFirst === oppositeVerticeId) break;

								}

								//Возможно был пройден полный круг поиска противолположной вершины и ничего найдено не было
								if (verticeId != oppositeVerticeId) edges.push([verticeId, oppositeVerticeId]);

								//else console.log(sHuperSphere + '.pushEdges. Opposite vertice was not found.')

								nextVertice();

							}, {

								sTitle: lang.progressTitle.replace('%s', verticeEdgesCur + 1),
								max: position.length,
								timeoutPeriod: 3,

							});
							break;
						default: console.error(sHuperSphere + ': pushEdges. Invalid classSettings.edges.creationMethod = ' + classSettings.edges.creationMethod);

					}

				}

				if (
					classSettings.edges &amp;&amp;
					(classSettings.settings.object.geometry.indices.edges.length === 0)//ребер нет
				) this.pushEdges();//Для экономии времени не добавляю ребра если на холст вывожу только вершины
				else if (this.classSettings.projectParams) this.project(this.classSettings.projectParams.scene, this.classSettings.projectParams.params);
				
				break;
				
			case 1: indices.edges.pushEdges(); break;//push edges. сначала добавляются ребра а потом уже создаются вершины для них
			default: console.error(sHuperSphere + ': Unknown mode: ' + classSettings.mode); return;
				
		}

		let cEdges;
		if (options.dat &amp;&amp; options.dat.gui &amp;&amp; (classSettings.boGui != false)) {

			const getLanguageCode = options.getLanguageCode;
			
			//Localization
			
			const lang = {

				vertices: 'Vertices',
				verticesCount: 'Count',
				verticesCountTitle: 'Vertices count',
	
				edges: 'Edges',
				edgesTitle: 'Create edges',
	
				edge: 'Edge',
	
				verticeEdgesCountTitle: 'Количество ребер у вершины',

				project: 'Project',
				projectTitle: 'Project edges onto canvas',

			};
	
			const _languageCode = getLanguageCode();
	
			switch (_languageCode) {
	
				case 'ru'://Russian language
	
					lang.vertices = 'Вершины';
					lang.verticesCount = 'Количество';
					lang.verticesCountTitle = 'Количество вершин';

					lang.edges = 'Ребра';
					lang.edgesTitle = 'Создать ребра';
	
					lang.edge = 'Ребро';

					lang.verticeEdgesCountTitle = 'Количество ребер у вершины';
					
					lang.project = 'Отображать';
					lang.projectTitle = 'Отображать ребра на холсте';

					break;
	
			}

			const fHuperSphere = options.dat.gui.addFolder(this.name( getLanguageCode )), dat = three.dat;
			
			//vertices

			const fVertices = fHuperSphere.addFolder(lang.vertices);
			fVertices.add( new PositionController((shift) => { cVerticesCount.setValue(angles.length + shift); },
				{ settings: { offset: 1, }, min: 1, max: 1000, step: 1, getLanguageCode: options.getLanguageCode}));
			
			//Vertices count
			const cVerticesCount = dat.controllerZeroStep(fVertices, angles, 'guiLength');
			dat.controllerNameAndTitle(cVerticesCount, lang.verticesCount, lang.verticesCountTitle);

			//vertice edges

			const fVerticeEdges = fVertices.addFolder(lang.edges);
			fVerticeEdges.add(new PositionController((shift) => { cVerticeEdgesCount.setValue(this.verticeEdgesLength + shift); },
				{ settings: { offset: 1, }, min: 1, max: 10, step: 1, getLanguageCode: options.getLanguageCode }));

			//Vertice edges count
			const cVerticeEdgesCount = dat.controllerZeroStep(fVerticeEdges, this, 'verticeEdgesLength');
			dat.controllerNameAndTitle(cVerticeEdgesCount, lang.verticesCount, lang.verticeEdgesCountTitle);

			//edges
			
			classSettings.edges = cookieOptions === false ? false : cookieOptions.edges || classSettings.edges;
			
			const objectEdges = { boEdges: ((typeof classSettings.edges) === 'object') || (classSettings.edges === true) ? true : false},
				setCockie = () => { options.dat.cookie.setObject(_this.cookieName, { edges: classSettings.edges, edgesOld: edgesOld, }); };
			cEdges = fHuperSphere.add( objectEdges, 'boEdges' ).onChange((boEdges) => {

					if (boEdges) {
						
						classSettings.edges = edgesOld;
						cProject.setValue(classSettings.edges.project);
						
					} else {

						edgesOld = classSettings.edges;
						classSettings.edges = false;
						
					}

					displayEdge();
					_this.projectGeometry();
					setCockie();
				
				} );
			const fEdge = fHuperSphere.addFolder(lang.edge),
				objectEdge = { boProject: ((typeof classSettings.edges) === 'object') ? classSettings.edges.project : false},
				cProject = fEdge.add( objectEdge, 'boProject' ).onChange((boProject) => {

					if (classSettings.edges.project === boProject) return;
					classSettings.edges.project = boProject;
					_this.projectGeometry();
					setCockie();
				
				} ),
				displayEdge = () => { _display(fEdge.domElement, classSettings.edges); };
			displayEdge();
			dat.controllerNameAndTitle( cEdges, lang.edges, lang.edgesTitle );
			dat.controllerNameAndTitle( cProject, lang.project, lang.projectTitle );
			
		}
		
	}

}

const edgesCreationMethod = {
	
	Random: 0,//'Random',
	NearestVertice: 1,//'NearestVertice',
	
}
Object.freeze(edgesCreationMethod);
/**
 * Enums a methods for creating edges:
 * &lt;pre>
 * Random: every vertice of the edge have random position.
 * NearestVertice: Vertices of the edge have nearest position.
 * &lt;/pre>
 * */
HuperSphere.edgesCreationMethod = edgesCreationMethod;

/**
 * &lt;a href="../../../commonNodeJS/master/nD/jsdoc/" target="_blank">ND&lt;/a>
 * */
HuperSphere.ND = ND;

export default HuperSphere;

const _display = (element, boDisplay) => { element.style.display = boDisplay === false ? 'none' : 'block'; }

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Circle.html">Circle</a></li><li><a href="module-HuperSphere.html">HuperSphere</a></li><li><a href="module-Universe3D.html">Universe3D</a></li></ul><h3>Classes</h3><ul><li><a href="module-Circle-Circle.html">Circle</a></li><li><a href="module-HuperSphere-HuperSphere.html">HuperSphere</a></li><li><a href="module-Universe3D-Universe3D.html">Universe3D</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sat Mar 09 2024 12:17:20 GMT+0700 (Красноярск, стандартное время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
