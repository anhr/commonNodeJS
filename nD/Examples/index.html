<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>nD</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">
	<!--
	<script src="../../myThree/build/myThree.js"></script>
	<script src="../../myThree/build/myThree.min.js"></script>
	<script src="../../../../../three.js/dev/build/three.js"></script>
	<script src="../../../../../three.js/dev/build/three.min.js"></script>
	<script src="https://raw.githack.com/anhr/three.js/dev/build/three.js"></script>
	<script src="https://raw.githack.com/anhr/three.js/dev/build/three.min.js"></script>
	<script src="https://threejs.org/build/three.js"></script>
	<script src="https://threejs.org/build/three.min.js"></script>
	-->
</head>
<body>
	<p>
		<a href='https://github.com/anhr' target="_blank">About me</a>
	</p>
	<h1>nD.</h1>
	<h2>4D.</h2>
	Here I am creating an 4D object.
	Unfortunately, it is not possible to render the 4D object in our 3D space. Instead, I intersect the 4d object with a 3D panel and project the result into 3D space.
	Currenty I have created <a href="https://en.wikipedia.org/wiki/5-cell" target="_blank">pentatope</a> as 4D object.
	I get a <a href="https://en.wikipedia.org/wiki/Tetrahedron" target="_blank">tetrahedron</a> as a result of the intersection of a pentatope with the 3D panel.
	You can see the green tetrahedron below in 3D canvas if  pentatope intersects with 3D panel. You can move 3D panel if you click the "►" button below.
	<fieldset>
		<legend>Player2</legend>
		Parameter <b>t</b> is <input id="time" /> <span id="tName"></span>
		<input id="prev" type="button" value="Prev" />
		<input id="play" type="button" value="Play" />
		<input id="next" type="button" value="Next" />
	</fieldset>
	<h2>3D.</h2>
	Click the "►" button in the lower left corner of the canvas to intersect the blue panel with the green tetrahedron.
	<br>
	You can see a white loop line if the blue panel in 3D canvas intersects with the green tetrahedron.
	<div id="3D">
		<img src="../../img/wait.gif">
	</div>
	<h2>2D.</h2>
	You can see a green triangle if the blue panel in 3D canvas intersects with the green tetrahedron.
	<br>
	The intersection panel in 2D space is horozontal line. You can see the panel on the 2D canvas as a blue line.
	<br>
	You can see a white horizontal line if the panel in 2D canvas intersects with the green triangle.
	<br>
	Click the "►" button in the lower left corner of the canvas to intersect the blue line with the green triangle.
	<div id="2D">
		<img src="../../img/wait.gif">
	</div>
	<h2>1D.</h2>
	You can see a green horizontal line if the blue line in 2D canvas intersects with the green triangle.
	<br>
	The intersection panel in 1D space is a point. You can see the panel on the 1D canvas as a blue point.
	<br>
	You can see a white point if the panel intersects with the green line.
	<br>
	Click the "►" button in the lower left corner of the canvas to intersect the blue point with the green line.
	<div id="1D">
		<img src="../../img/wait.gif">
	</div>
	<h2>0D.</h2>You can see a green point in the center of 0D canvas if the blue point in 1D canvas intersects with the green line.
	<div id="0D">
		<img src="../../img/wait.gif">
	</div>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import * as THREE from 'https://raw.githack.com/anhr/three.js/dev/build/three.module.js';

		import MyThree from '../../myThree/myThree.js';
		//import MyThree from '../../myThree/build/myThree.module.js';
		//import MyThree from '../../myThree/build/myThree.module.min.js';
		if ( MyThree.default ) MyThree = MyThree.default;
		MyThree.three.THREE = THREE;

		import ND from '../nD.js';

		const canvas1D = {}, canvas0D = {}, options = {

			camera: {

				position: new THREE.Vector3( 0, 0, 5 ),
				fov: 45,
				near: 1,
				far: 1000,

			},

		};

		const D = [
			true,//0D

			false,//1D
			//true,//1D

			false,//2D
			//true,//2D

			//false,//3D
			true,//3D

			//false,//4D
			true,//4D
		]

		//4D
		var _4D;
		if ( D[4] ) {

			_4D = new ND( 4, {

				geometry: {

					//tetrahedron
					position: [
						[0.8, -0.6, 0.1, -0.85],//0
						[0.9, 0.7, 0.5, -0.55],//1
						[0.8, 0, -0.4, 0],//2
						[-0.6, 0.1, 0.1, 0.55],//3
						[-0.6, 0.1, 0.1, 0.85],//5

					],

				},
				//			scene: scene,
				options: options,
				onIntersection: function ( nDgeometry ) {

					console.log( '_4D: onIntersection positions = ' + nDgeometry.position.length )
					nDgeometry.position.forEach( function ( position, i ) { console.log( position ); } );
					if ( nDgeometry.position.length === 0 )
						return;
					if ( _3D ) _3D.geometry = nDgeometry;

				}

			} );

		}

		//3D
		var _3D;
		new MyThree( function ( scene, options ) {

			if ( D[3] ) {

				_3D = new ND( 3, {

					geometry: {

						//tetrahedron
						position: [
							[0.8, -0.6, 0.1],//0
							[0.9, 0.7, 0.5],//1
							[0.8, 0, -0.4],//2
							[-0.6, 0.1, 0.1]//3

						],

					},
					scene: scene,
					options: options,
					onIntersection: function ( nDgeometry ) { if ( _2D ) _2D.geometry = nDgeometry; }

				} );

				//new time of the player event
				options.onSelectScene = function ( t ) { _3D.vectorPlane[2] = options.scales.z.min + t * ( options.scales.z.max - options.scales.z.min ); }

			}

		}, {

			elContainer: "3D",

			playerOptions: {

				marks: 111,//Number of scenes of 3D objects animation.
				selectSceneIndex: 55,//time is 0.5 sec.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {},

		} );

		if ( _4D ) _4D.intersection();

		//2D
		var _2D;
		new MyThree( function ( scene, options ) {

			if ( D[2] ) {

				_2D = new ND( 2, {

					//geometry: [[-0.7, 0.2], [0.8, 0.6], [0.1, -0.5]],
					geometry: {

						position: [[-0.7, 0.2], [0.8, 0.6], [0.1, -0.5]],
						//indices: [[0, 1], [0, 2], [1, 2, 'r']],

					},
					scene: scene,
					options: options,
					onIntersection: function ( nDgeometry ) { if ( _1D ) _1D.geometry = nDgeometry; }

				} );

				//new time of the player event
				options.onSelectScene = function ( t ) { _2D.vectorPlane[1] = options.scales.y.min + t * ( options.scales.y.max - options.scales.y.min ); }

			}

		}, {

			elContainer: "2D",

			//axesHelper: false,
			playerOptions: {

				marks: 110,//Number of scenes of 3D objects animation.
				selectSceneIndex: 55,//time is 0.5 sec.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {},
			//dat: false,
			camera: options.camera,
			orbitControls: false,
			stereoEffect: false,
			//scales: { x: {} },

		} );

		//1D
		var _1D;
		new MyThree( function ( scene, options ) {

			canvas1D.scene = scene;
			canvas1D.options = options;
			if ( D[1] ) {

				let point0D;
				_1D = new ND( 1, {

					geometry: {

						position: [[-0.5, 1], [0.5]],
						//indices: ['a',[0], [1, 2], 1],

					},
					scene: scene,
					options: options,
					onIntersection: function ( nDgeometry ) {

						if ( !canvas0D.scene ) return;
						if ( nDgeometry.position.length ) {

							if ( !point0D ) {

								canvas0D.options.point.size = ( canvas0D.options.scales.x.max - canvas0D.options.scales.x.min ) * 500;//10
								point0D = new THREE.Points( new THREE.BufferGeometry().setFromPoints( [new THREE.Vector3()], 3 ),
									new THREE.PointsMaterial( {

										color: 0x00ff00,//green
										sizeAttenuation: false,
										size: canvas0D.options.point.size / options.point.sizePointsMaterial,

									} ) );
								point0D.name = 'intersection';
								canvas0D.scene.add( point0D );
								if ( canvas0D.options.guiSelectPoint ) canvas0D.options.guiSelectPoint.addMesh( point0D );

							}

						} else {

							if ( point0D ) {

								//console.log( 'remove point' );
								canvas0D.scene.remove( point0D );
								if ( canvas0D.options.guiSelectPoint )
									canvas0D.options.guiSelectPoint.removeMesh( point0D );
								point0D = undefined;

							}

						}

					}

				} );

				//new time of the player event
				options.onSelectScene = function ( t ) { if ( _1D ) _1D.vectorPlane[0] = options.scales.x.min + t * ( options.scales.x.max - options.scales.x.min ); }

			}

		}, {

			elContainer: "1D",

			//axesHelper: false,
			playerOptions: {

				marks: 110,//Number of scenes of 3D objects animation.
				selectSceneIndex: 55,//time is 0.5 sec.
				interval: 25,//Ticks per seconds.

			},
			//player: false,
			dat: {},
			//dat: false,
			camera: options.camera,
			/*
						camera: {

							position: new THREE.Vector3( 0, 0, 5 ),
							fov: 45,
							near: 1,
							far: 1000,

						},
			*/
			orbitControls: false,
			stereoEffect: false,
			//scales: { x: {} },

		} );

		//0D

		new MyThree( function ( scene, options ) {

			canvas0D.scene = scene;
			canvas0D.options = options;

		}, {

			elContainer: "0D",
			//scales: scales,
			player: false,
			//dat: { folderPoint: false, },
			dat: false,
			axesHelper: false,
			orbitControls: false,
			stereoEffect: false,

		} );

	</script>
</body>
</html >
