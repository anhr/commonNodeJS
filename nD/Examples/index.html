<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>nD</title>

	<!--for mobile devices-->
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<meta name="author" content="Andrej Hristoliubov https://anhr.github.io/AboutMe/">
	<!--
	<script src="../../myThree/build/myThree.js"></script>
	<script src="../../myThree/build/myThree.min.js"></script>
	<script src="../../../../../three.js/dev/build/three.js"></script>
	<script src="../../../../../three.js/dev/build/three.min.js"></script>
	<script src="https://raw.githack.com/anhr/three.js/dev/build/three.js"></script>
	<script src="https://raw.githack.com/anhr/three.js/dev/build/three.min.js"></script>
	<script src="https://threejs.org/build/three.js"></script>
	<script src="https://threejs.org/build/three.min.js"></script>
	-->
	<!-- Tree View https://www.w3schools.com/howto/howto_js_treeview.asp -->
	<link type="text/css" rel="stylesheet" href="../../treeView/treeView.css">
	<script src="../../../../mathjs/mathjs/lib/browser/math.js"></script>
</head>
<body>
	<p>
		<a href='https://github.com/anhr' target="_blank">About me</a>
	</p>
	<h1>nD.</h1>

	<!-- Tree View https://www.w3schools.com/howto/howto_js_treeview.asp -->
	<ul id="myUL">
		<li>
			<span class="caret">Introduction</span>
			<ul class="nested hide">
				<li>
					Here I want to show a series of graphic objects of different space dimensions.
					Each graphic object of the current space dimension is the result of the intersection of a graphic object of a higher space dimension with some panel except a 5D graphic object.
					<br>
					First I create a 5D graphic object on the canvas under the 5D heading.
					Then I intersect this object with a 4D panel.
					Then I transfer the result of the intersection to the canvas under the  4D heading, cross it with a 3D panel.
					I repeat this up to the canvas under the heading 0D.
				</li>
			</ul>
		</li>
		<li>
			<span class="caret">5D.</span>
			<ul class="nested hide" id="article5D">
				<li>
					Here I am creating an 5D object.
					Unfortunately, it is not possible to render the 5D object in our 3D space. Instead, you can see on the canvas below a projection of all the vertices of the 5D objects to 3D space.
					Also I intersected the 5D object with the 4D panel. You can't to see 4D panel because I can't render the 4D panel because it's 4D space.
					The result of the intersection is a 4D object if the 5D object intersects the 4D panel.
					<br>
					Currenty I have created 5D version of <a href="https://en.wikipedia.org/wiki/5-cell" target="_blank">pentatope</a>. You can see it as green lines.
					I get a 4D object as a result of the intersection of a 5D version of pentatope with the 4D panel.
					You can see it as white lines.
					<div class="canvas" id="5D">
						<img src="../../img/wait.gif">
					</div>
				</li>
			</ul>
		</li>
		<li>
			<span class="caret">4D.</span>
			<ul class="nested hide" id="article4D">
				<li>
					Here I am creating an 4D object.
					Unfortunately, it is not possible to render the 4D object in our 3D space. Instead, you can see on the canvas below a projection of all the vertices of the 4D objects to 3D space.
					Also I intersected the 4D object with the 3D panel. You can't to see 3D panel because I can't render the 3D panel because it's 3D space and fills the entire canvas.
					The result of the intersection is a 3D object if the 4D object intersects the 3D panel.
					<br>
					Currenty I have created <a href="https://en.wikipedia.org/wiki/5-cell" target="_blank">pentatope</a> as 4D object. You can see it as green lines.
					I get a 3D object as a result of the intersection of a pentatope with the 3D panel.
					You can see it as white lines.
					<div class="canvas" id="4D">
						<img src="../../img/wait.gif">
					</div>
				</li>
			</ul>
		</li>
		<li>
			<span class="caret">3D.</span>
			<ul class="nested hide" id="article3D">
				<li>
					Click the "►" button in the lower left corner of the canvas to intersect the blue panel with the green graphic object.
					<br>
					You can see a white loop line if the blue panel in 3D canvas intersects with the green graphic object.
					Real panel is surface with infinite length and width. But I have limited it to axes dimentions.
					<div id="3D">
						<img src="../../img/wait.gif">
					</div>
				</li>
			</ul>
		</li>
		<li>
			<span class="caret">2D.</span>
			<ul class="nested hide" id="article2D">
				<li>
					You can see a green loop line if the blue panel in 3D canvas intersects with the green graphic object.
					<br>
					The intersection panel in 2D space is infinity horozontal line. You can see the panel on the 2D canvas as a blue line.
					I have limited it to axis dimention.
					<br>
					You can see a white horizontal line if the panel in 2D canvas intersects with the green graphic object.
					<br>
					Click the "►" button in the lower left corner of the canvas to intersect the blue line with the green graphic object.
					<div id="2D">
						<img src="../../img/wait.gif">
					</div>
				</li>
			</ul>
		</li>
		<li>
			<span class="caret">1D.</span>
			<ul class="nested hide" id="article1D">
				<li>
					You can see a green horizontal line if the blue line in 2D canvas intersects with the green graphic object.
					<br>
					The intersection panel in 1D space is a point. You can see the panel on the 1D canvas as a blue point.
					<br>
					You can see a white point if the panel intersects with the green line.
					<br>
					Click the "►" button in the lower left corner of the canvas to intersect the blue point with the green line.
					<div id="1D">
						<img src="../../img/wait.gif">
					</div>
				</li>
			</ul>
		</li>
		<li>
			<span class="caret">0D.</span>
			<ul class="nested hide" id="article0D">
				<li>
					You can see a green point in the center of 0D canvas if the blue point in 1D canvas intersects with the green line.
					<div id="0D">
						<img src="../../img/wait.gif">
					</div>
				</li>
			</ul>
		</li>
	</ul>
	<script nomodule>alert( 'Fatal error: Your browser do not support modular JavaScript code.' );</script>
	<script type="module">

		import * as THREE from '../../../../three.js/dev/build/three.module.js';
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		//import * as THREE from 'https://raw.githack.com/anhr/three.js/dev/build/three.module.js';

		import MyThree from '../../myThree/myThree.js';
		//import MyThree from '../../myThree/build/myThree.module.js';
		//import MyThree from '../../myThree/build/myThree.module.min.js';
		if ( MyThree.default ) MyThree = MyThree.default;
		MyThree.three.THREE = THREE;

		import ND from '../nD.js';

		const treeView = new MyThree.TreeView( { animate: true, paddingInlineStart: '10px', open: true, cookie: true, } );

		const canvas1D = {}, canvas0D = {}, options = {

			camera: {

				position: new THREE.Vector3( 0, 0, 5 ),
				fov: 45,
				near: 1,
				far: 1000,

			},

		};

		const D = [
			true,//0D

			false,//1D
			//true,//1D

			false,//2D
			//true,//2D

			//false,//3D
			true,//3D

			false,//4D
			//true,//4D

			false,//5D
			//true,//5D
		],
			playerOptions = {

				marks: 111,//Number of scenes of 3D objects animation.
				selectSceneIndex: 55,//time is 0.5 sec.
				interval: 25,//Ticks per seconds.

			};

		//5D
		var _5D;
		if ( D[5] ) {

			const myThree = new MyThree( function ( scene, options ) {

				_5D = new ND( 5, {

					geometry: {

						//5D tetrahedron
						position: [
							[0.8, -0.6, 0.1, -0.85, -0.57],//0
							[0.9, 0.7, 0.5, -0.55, -0.37],//1
							[0.8, 0, -0.4, 0.1, -0.17],//2
							[-0.6, 0.1, -0.3, 0.55, 0.7],//3
							[-0.5, 0.7, 0.3, 0.75, 0.27],//4
							[-0.7, 0.3, 0.4, 0.95, 0.77],//5

						],

					},
					scene: scene,
					options: options,
					onIntersection: function ( geometryIntersection ) { if ( _4D ) _4D.geometry = geometryIntersection; }

				} );

				//new time of the player event
				options.onSelectScene = function ( t ) { _5D.vectorPlane[4] = -1 + t * 2; }

			}, {

				elContainer: "5D",
				playerOptions: Object.assign( {}, playerOptions ),
				//player: false,
				//dat: false,
				title: '5D',

			} );
			//если не выполнить эту команду, то холст будет пустой
			treeView.setCanvas( 'article5D', myThree );

		}

		//4D
		var _4D;
		if ( D[4] ) {

			treeView.setCanvas( 'article4D', new MyThree( function ( scene, options ) {

				_4D = new ND( 4, {

					position: [-0.3],// -0.2, 0.3, 5],
					geometry: {

						//tetrahedron
						position: [
							[0.8, -0.6, 0.1, -0.85],//0
							[0.9, 0.7, 0.5, -0.55],//1
							[0.8, 0, -0.4, 0.1],//2
							[-0.6, 0.1, -0.3, 0.55],//3
							[-0.5, 0.2, 0.3, 0.85],//4

						],

					},
					scene: scene,
					options: options,
					onIntersection: function ( geometryIntersection ) { if ( _3D ) _3D.geometry = geometryIntersection; }

				} );

				//new time of the player event
				options.onSelectScene = function ( t ) { _4D.vectorPlane[3] = options.scales.z.min + t * ( options.scales.z.max - options.scales.z.min ); }

			}, {

				elContainer: "4D",
				playerOptions: Object.assign( {}, playerOptions ),
				//player: false,
				//dat: false,
				title: '4D',

			} ) );

		}

		//3D
		var _3D;
		if ( D[3] ) {

			const position = [-0.3];
			const myThree = new MyThree( function ( scene, options ) {

				_3D = new ND( 3, {

					position: position,
					//rotation: Math.PI / 4,
					rotation: [Math.PI / 4, 1, 2],
					geometry: {

						/*
						//Variant 1 Вершина 1 находится близко к панели если проигрыватель установить на t = 0.6 .
						//Будем считать что она находится на панели. Смотри proxyEdges.intersection
						position: [
							[0.8, -0.0631578947368421, -0.34736842105263155],//0
							[0.15000000000000005, -0.19999999999999996, 0.2],//1
							[-0.04999999999999993, -0.175, -0.14285714285714288],//2
							[0.14999999999999997, 0.4, 0.09999999999999996],//3
							[0.35, 0.5035714285714284, 0.4214285714285714],//4
							[0.8153846153846154, 0.10769230769230766, -0.2615384615384616],//5
						],
						indices: [

							//edges
							[
								[0, 1],//0
								[0, 2],//1
								[2, 1],//2
								[2, 3],//3
								[1, 4],//4
								[3, 4],//5
								[0, 5],//6
								[5, 4],//7
								[5, 3],//8
							],
							//faces
							[
								[0, 1, 2],
								[6, 7, 4, 0],
								//[5, 8, 7],
								[1, 3, 6, 8],
								[2, 3, 5, 4],
							],
						],
						*/

						//tetrahedron
						position: [

							/*
							[0.8, -0.6, 0.1],//0
							[0.9, 0.7, 0.5],//1
							[0.8, 0, -0.4],//2
							[-0.6, 0.1, 0.1]//3
							*/
							//Variant 2 Вершина, ребро, грань находится на панели если координата 2 каждой вершины равна -0.4 и проигрыватель установить на t = 0.3
							[0.8, -0.6, -0.4],//0
							[0.9, 0.7, 0.5],//1
							[0.8, 0, -0.4],//2
							[-0.6, 0.1, -0.4]//3
							/*
							//Линия пересечения - четырехугольник
							[-0.8, 0, -0.5],//0
							[0.9, 0, -0.5],//1
							[0, -0.7, 0.4],//2
							[0, 0.6, 0.4]//3
							*/

						],

					},
					scene: scene,
					options: options,
					onIntersection: function ( geometryIntersection ) { if ( _2D ) _2D.geometry = geometryIntersection; }

				} );

				//new time of the player event
				options.onSelectScene = function ( t ) { _3D.vectorPlane[2] = options.scales.z.min + t * ( options.scales.z.max - options.scales.z.min ); }

			}, {

				elContainer: "3D",
				playerOptions: Object.assign( {}, playerOptions ),
				//player: false,
				//dat: false,
				title: '3D',

			} );
			treeView.setCanvas( 'article3D', myThree );

		}

		if ( _4D ) _4D.intersection();

		//2D
		var _2D;
		if ( D[2] ) {

			const myThree = new MyThree( function ( scene, options ) {

				_2D = new ND( 2, {

					position: [0.1, -0.2],
					//rotation: [0, 0, Math.PI / 4],
					rotation: Math.PI / 4,
					geometry: {

						position: [
							[-0.7, 0.2],
							[0.8, 0.6],
							[0.1, -0.5],
							//[-0.3, -0.5],
						],
						/*
						indices: [[
							[0, 1],
							[1, 2],
							[2, 3],
							[3, 0],
						]],
						*/

					},
					scene: scene,
					options: options,
					onIntersection: function ( geometryIntersection ) { if ( _1D ) _1D.geometry = geometryIntersection; }

				} );

				//new time of the player event
				options.onSelectScene = function ( t ) { _2D.vectorPlane[1] = options.scales.y.min + t * ( options.scales.y.max - options.scales.y.min ); }

			}, {

				elContainer: "2D",
				//axesHelper: false,
				playerOptions: Object.assign( {}, playerOptions ),
				//player: false,
				//dat: false,
				camera: options.camera,
				orbitControls: false,
				stereoEffect: false,
				//scales: { x: {} },
				title: '2D',

			} );
			treeView.setCanvas( 'article2D', myThree );

		}

		//1D
		var _1D;
		if ( D[1] ) {

			const myThree = new MyThree( function ( scene, options ) {

				canvas1D.scene = scene;
				canvas1D.options = options;
				let point0D;
				_1D = new ND( 1, {

					//position: [0.1, 78],//tesing of settings.position = new Proxy
					position: 0.1,
					geometry: {

						//position: [[-0.5, 1], [0.5]],//tesing of settings.position = new Proxy
						position: [[-0.5], [0.5]],

					},
					scene: scene,
					options: options,
					onIntersection: function ( geometryIntersection ) {

						if ( !canvas0D.scene ) return;
						if ( geometryIntersection.position.length ) {

							if ( !point0D ) {

								canvas0D.options.point.size = ( canvas0D.options.scales.x.max - canvas0D.options.scales.x.min ) * 500;//10
								point0D = new THREE.Points( new THREE.BufferGeometry().setFromPoints( [new THREE.Vector3()], 3 ),
									new THREE.PointsMaterial( {

										color: 0x00ff00,//green
										sizeAttenuation: false,
										size: canvas0D.options.point.size / options.point.sizePointsMaterial,

									} ) );
								point0D.name = 'intersection';
								canvas0D.scene.add( point0D );
								if ( canvas0D.options.guiSelectPoint ) canvas0D.options.guiSelectPoint.addMesh( point0D );

							}

						} else {

							if ( point0D ) {

								//console.log( 'remove point' );
								canvas0D.scene.remove( point0D );
								if ( canvas0D.options.guiSelectPoint )
									canvas0D.options.guiSelectPoint.removeMesh( point0D );
								point0D = undefined;

							}

						}

					}

				} );

				//new time of the player event
				options.onSelectScene = function ( t ) { if ( _1D ) _1D.vectorPlane[0] = options.scales.x.min + t * ( options.scales.x.max - options.scales.x.min ); }

			}, {

				elContainer: "1D",
				//axesHelper: false,
				playerOptions: Object.assign( {}, playerOptions ),
				//player: false,
				//dat: false,
				camera: options.camera,
				orbitControls: false,
				stereoEffect: false,
				//scales: { x: {} },
				title: '1D',

			} );
			treeView.setCanvas( 'article1D', myThree );

		}

		//0D

		{

			const myThree = new MyThree( function ( scene, options ) {

				canvas0D.scene = scene;
				canvas0D.options = options;
				/*
							//https://stackoverflow.com/a/68405743/5175935
							const geometry = new THREE.BufferGeometry().setFromPoints( [
								new THREE.Vector3( 1, 0, 0 ),//0
								new THREE.Vector3( 0, 0, 0 ),//1
								new THREE.Vector3( 0, 1, 0 ),//2
								new THREE.Vector3( 1, 0, 0 ),//3
								new THREE.Vector3( 0, 1, 0 ),//4
								new THREE.Vector3( 1, 1, 0 ),//5
							] );
	
							const colors = [
								255, 0, 0,
								255, 0, 0,
								0, 255, 0,
								0, 255, 0,
								0, 0, 255,
								0, 0, 255,
							];
	
							geometry.setAttribute( 'color', new THREE.Uint8BufferAttribute( colors, 3, true ) );
							geometry.setIndex( [0, 1, 3, 2] );
	
							const material = new THREE.LineBasicMaterial( {
								vertexColors: true
							} );
	
							const lines = new THREE.LineSegments( geometry, material );
							scene.add( lines );
				*/

			}, {

				elContainer: "0D",
				//scales: scales,
				player: false,
				//dat: { folderPoint: false, },
				dat: false,
				axesHelper: false,
				orbitControls: false,
				stereoEffect: false,
				title: '0D',

			} );
			treeView.setCanvas( 'article0D', myThree );

		}

	</script>
</body>
</html >
