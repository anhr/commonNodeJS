!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Colorpicker={})}(this,function(t){"use strict";function e(t,e){!0===(e=e||{}).async&&console.warn("Load file asynchronously is deprecated. Please use fetch."),e.onload=e.onload||function(){},e.onerror=e.onerror||function(){};var n,o=new function(t){if(this.loadXMLDoc=function(){var t;if(window.XMLHttpRequest){if(!(t=new XMLHttpRequest))throw"new XMLHttpRequest() failed!"}else{if(!window.ActiveXObject)throw"myRequest.loadXMLDoc(...) failed!";if(!(t=this.NewActiveXObject()))throw"NewActiveXObject() failed!"}return t},this.NewActiveXObject=function(){try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(t){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(t){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(t){}try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(t){}return n('This browser does not support XMLHttpRequest. Probably, your security settings do not allow Web sites to use ActiveX controls installed on your computer. Refresh your Web page to find out the current status of your Web page or enable the "Initialize and script ActiveX controls not marked as safe" and "Run Active X controls and plug-ins" of the Security settings of the Internet zone of your browser.'),null},this.XMLHttpRequestStart=function(t,e){this.XMLHttpRequestStop(),this.req.onreadystatechange=t,"onerror"in this.req&&(this.req.onerror=function(t){n("XMLHttpRequest error. url: "+this.url)}),this.XMLHttpRequestReStart(e)},this.getUrl=function(){return void 0!==this.url&&null!=this.url||n("XMLHttpRequest: Invalid url: "+this.url),this.url+(this.params?this.params:"")},this.XMLHttpRequestReStart=function(t){try{void 0===t&&(t=!0),this.req.open("GET",this.getUrl(),t),t&&("timeout"in this.req&&(this.req.timeout=9e4),"ontimeout"in this.req?this.req.ontimeout=function(){n("XMLHttpRequest timeout")}:(clearTimeout(this.timeout_id_SendReq),this.timeout_id_SendReq=setTimeout(function(){n("XMLHttpRequest timeout 2")},9e4))),this.req.send(null)}catch(t){n(t.message+" url: "+this.url)}},this.XMLHttpRequestStop=function(){null!=this.req&&this.req.abort()},this.ProcessReqChange=function(t){var e=this.req;switch("undefined"==typeof isIE||isIE,e.readyState){case 4:if("unknown"==typeof e.status)return consoleError('typeof XMLHttpRequest status == "unknown"'),!0;if(200==e.status)return clearTimeout(this.timeout_id_SendReq),t(this);n("Invalid XMLHttpRequest status : "+e.status+" url: "+this.url);break;case 1:case 2:case 3:break;case 0:default:throw"processReqChange(); req.readyState = "+e.readyState}return!0},this.processStatus200Error=function(){var t=this.GetElementText("error",!0);return!!t&&(n(t),!0)},this.GetElementText=function(t,e){var o=this.req;if(!o.responseXML)return 1!=e&&n("GetXMLElementText(xmlhttp, "+t+"); xmlhttp.responseXML is null.\nxmlhttp.responseText:\n"+o.responseText),null;var r=o.responseXML.getElementsByTagName(t);if(0==r.length)return 1!=e&&n('GetXMLElementText(xmlhttp, "'+t+'"); element.length == '+r.length),"";for(var i="",s=0;s<r.length;s++)if(void 0===r[s].textContent){if(void 0===r[s].text)return n("GetXMLElementText(xmlhttp, "+t+"); element["+s+"].text) == undefined"),"";""!=i&&(i+=" "),i+=r[s].text}else i+=r[s].textContent;return i},t.data)this.req=t.data.req,this.url=t.data.url,this.params=t.data.params;else try{this.req=this.loadXMLDoc()}catch(t){var e;return e=void 0===t.message?t:t.message,void n("Your browser is too old and is not compatible with our site.\n\n"+window.navigator.appName+" "+window.navigator.appVersion+"\n\n"+e)}function n(e){console.error(e),t.onerror(e)}this.req||consoleError("Invalid myRequest.req: "+this.req)}(e);return o.url=t,o.XMLHttpRequestStart(function(){o.ProcessReqChange(function(o){o.processStatus200Error()||(n=o.req.responseText,e.onload(n,t))})},void 0!==e.async),n}function n(t,e){if(e.tag=e.tag||{},"string"==typeof e.tag)switch(e.tag){case"style":e.tag={name:"style",attribute:{name:"rel",value:"stylesheet"}};break;default:return void console.error("Invalid options.tag: "+e.tag)}e.tag.name=e.tag.name||"script";var n=document.createElement(e.tag.name);e.tag.attribute=e.tag.attribute||{},e.tag.attribute.name=e.tag.attribute.name||"type",e.tag.attribute.value=e.tag.attribute.value||"text/javascript",n.setAttribute(e.tag.attribute.name,e.tag.attribute.value),t(n),e.appendTo.appendChild(n)}function o(t,e,n){for(var o=t.querySelectorAll("script"),r=0;r<o.length;r++){if(o[r].id===e)return!0}return!1}var r,i,s,a,l={sync:function(t,r){if((r=r||{}).onload=r.onload||function(){},r.onerror=r.onerror||function(){},r.appendTo=r.appendTo||document.getElementsByTagName("head")[0],o(r.appendTo,t))r.onload();else if(t instanceof Array){for(var i,s={appendTo:r.appendTo,tag:r.tag,onload:function(t,e){console.log("loadScript.sync.onload: "+e)},onerror:function(t){r.onerror(t),i=t}},a=0;a<t.length;a++){var l=t[a];if(n(function(t){t.setAttribute("id",l),t.innerHTML=e(l,s)},s),void 0!==i)break}void 0===i&&r.onload()}else n(function(n){n.setAttribute("id",t),n.innerHTML=e(t,r)},r)},async:function(t,e){var r;function i(s){function a(){t instanceof Array&&r<t.length-1?i(t[++r]):e.onload()}o(e.appendTo,s,e.onload)?a():n(function(t){t.setAttribute("id",s),t.readyState&&!t.onload?t.onreadystatechange=function(){"complete"==t.readyState&&void 0!==e.onload&&e.onload(),"loaded"==t.readyState&&(setTimeout(e.onload,0),this.onreadystatechange=null)}:(t.onload=function(){console.log("loadScript.async.onload() "+s),void 0!==e.onload&&a()},t.onerror=function(t){var n='loadScript: "'+this.src+'" failed';void 0!==e.onerror&&e.onerror(n,t),console.error(n)}),t.src=s},e)}(e=e||{}).appendTo=e.appendTo||document.getElementsByTagName("head")[0],e.onload=e.onload||function(){},t instanceof Array?i(t[r=0]):i(t)},escapeHtml:function(t){return t.replace(/[&<>"'\/]/g,function(t){return{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"}[t]})}};window.__myThree__=window.__myThree__||{},window.__myThree__.three?a=window.__myThree__.three:((a=new class{constructor(){}set THREE(t){if(r)return void(Object.is(t,r)||console.error("three: duplicate THREE. Please use one instance of the THREE library."));r=t,s=this;const e=t.Float32BufferAttribute,n=t.Line3,o=t.Plane,i=t.Triangle,l=t.Vector3;function c(){const t=0,e=1,r=new l,s=new n,a=new o,c=new l,u=new i;this.ConvexHull=class{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new f,this.unassigned=new f,this.vertices=[]}setFromPoints(t){!0!==Array.isArray(t)&&console.error("THREE.ConvexHull: Points parameter is not an array."),t.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new p(t[e]));return this.compute(),this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(t){const n=t.geometry;if(void 0!==n){if(n.isGeometry)return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");if(n.isBufferGeometry){const o=n.attributes.position;if(void 0!==o)for(let n=0,r=o.count;n<r;n++){const r=new l;r.fromBufferAttribute(o,n).applyMatrix4(t.matrixWorld),e.push(r)}}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let n=0,o=e.length;n<o;n++)if(e[n].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const n=this.faces;let o=-1/0,r=1/0;for(let e=0,i=n.length;e<i;e++){const i=n[e],s=i.distanceToPoint(t.origin),a=i.normal.dot(t.direction);if(s>0&&a>=0)return null;const l=0!==a?-s/a:0;if(!(l<=0)&&(a>0?r=Math.min(l,r):o=Math.max(l,o),o>r))return null}return o!==-1/0?t.at(o,e):t.at(r,e),e}intersectsRay(t){return null!==this.intersectRay(t,r)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let n=t.outside;for(;null!==n.next&&n.next.face===t;)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(void 0!==n)if(void 0===e)this.unassigned.appendChain(n);else{let t=n;do{const n=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=n}while(null!==t)}return this}resolveUnassignedPoints(e){if(!1===this.unassigned.isEmpty()){let n=this.unassigned.first();do{const o=n.next;let r=this.tolerance,i=null;for(let o=0;o<e.length;o++){const s=e[o];if(s.mark===t){const t=s.distanceToPoint(n.point);if(t>r&&(r=t,i=s),r>1e3*this.tolerance)break}}null!==i&&this.addVertexToFace(n,i),n=o}while(null!==n)}return this}computeExtremes(){const t=new l,e=new l,n=[],o=[];for(let t=0;t<3;t++)n[t]=o[t]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let r=0,i=this.vertices.length;r<i;r++){const i=this.vertices[r],s=i.point;for(let e=0;e<3;e++)s.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,s.getComponent(e)),n[e]=i);for(let t=0;t<3;t++)s.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,s.getComponent(t)),o[t]=i)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:n,max:o}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),n=e.min,o=e.max;let r=0,i=0;for(let t=0;t<3;t++){const e=o[t].point.getComponent(t)-n[t].point.getComponent(t);e>r&&(r=e,i=t)}const l=n[i],u=o[i];let d,p;r=0,s.set(l.point,u.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==l&&n!==u){s.closestPointToPoint(n.point,!0,c);const t=c.distanceToSquared(n.point);t>r&&(r=t,d=n)}}r=-1,a.setFromCoplanarPoints(l.point,u.point,d.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==l&&n!==u&&n!==d){const t=Math.abs(a.distanceToPoint(n.point));t>r&&(r=t,p=n)}}const f=[];if(a.distanceToPoint(p.point)<0){f.push(h.create(l,u,d),h.create(p,u,l),h.create(p,d,u),h.create(p,l,d));for(let t=0;t<3;t++){const e=(t+1)%3;f[t+1].getEdge(2).setTwin(f[0].getEdge(e)),f[t+1].getEdge(1).setTwin(f[e+1].getEdge(0))}}else{f.push(h.create(l,d,u),h.create(p,l,u),h.create(p,u,d),h.create(p,d,l));for(let t=0;t<3;t++){const e=(t+1)%3;f[t+1].getEdge(2).setTwin(f[0].getEdge((3-t)%3)),f[t+1].getEdge(0).setTwin(f[e+1].getEdge(1))}}for(let t=0;t<4;t++)this.faces.push(f[t]);for(let e=0,n=t.length;e<n;e++){const n=t[e];if(n!==l&&n!==u&&n!==d&&n!==p){r=this.tolerance;let t=null;for(let e=0;e<4;e++){const o=this.faces[e].distanceToPoint(n.point);o>r&&(r=o,t=this.faces[e])}null!==t&&this.addVertexToFace(n,t)}}return this}reindexFaces(){const e=[];for(let n=0;n<this.faces.length;n++){const o=this.faces[n];o.mark===t&&e.push(o)}return this.faces=e,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const n=this.assigned.first().face;let o=n.outside;do{const r=n.distanceToPoint(o.point);r>e&&(e=r,t=o),o=o.next}while(null!==o&&o.face===n);return t}}computeHorizon(n,o,r,i){let s;this.deleteFaceVertices(r),r.mark=e,s=null===o?o=r.getEdge(0):o.next;do{const e=s.twin,o=e.face;o.mark===t&&(o.distanceToPoint(n)>this.tolerance?this.computeHorizon(n,e,o,i):i.push(s)),s=s.next}while(s!==o);return this}addAdjoiningFace(t,e){const n=h.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,o=null;for(let r=0;r<e.length;r++){const i=e[r],s=this.addAdjoiningFace(t,i);null===n?n=s:s.next.setTwin(o),this.newFaces.push(s.face),o=s}return n.next.setTwin(o),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}};class h{constructor(){this.normal=new l,this.midpoint=new l,this.area=0,this.constant=0,this.outside=null,this.mark=t,this.edge=null}static create(t,e,n){const o=new h,r=new d(t,o),i=new d(e,o),s=new d(n,o);return r.next=s.prev=i,i.next=r.prev=s,s.next=i.prev=r,o.edge=r,o.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return u.set(t.point,e.point,n.point),u.getNormal(this.normal),u.getMidpoint(this.midpoint),this.area=u.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class d{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class p{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class f{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}}this.ConvexHull=(new c).ConvexHull;const u=a.THREE.Vector2,h=a.THREE.Box3,d=a.THREE.BufferAttribute,p=a.THREE.Uint16BufferAttribute,f=a.THREE.Uint32BufferAttribute,m=a.THREE.Sphere,g=a.THREE.Object3D,b=a.THREE.Matrix4,v=a.THREE.Matrix3,y=a.THREE.arrayMax,x=a.THREE.MathUtils;class w{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,o=n.length;e<o;e++)n[e].call(this,t);t.target=null}}}let E=0;const T=new b,A=new g,R=new l,P=new h,M=new h,S=new l;class B extends w{constructor(){super(),Object.defineProperty(this,"id",{value:E++}),this.uuid=x.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(y(t)>65535?f:p)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new v).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(t),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return T.makeRotationFromQuaternion(t),this.applyMatrix4(T),this}rotateX(t){return T.makeRotationX(t),this.applyMatrix4(T),this}rotateY(t){return T.makeRotationY(t),this.applyMatrix4(T),this}rotateZ(t){return T.makeRotationZ(t),this.applyMatrix4(T),this}translate(t,e,n){return T.makeTranslation(t,e,n),this.applyMatrix4(T),this}scale(t,e,n){return T.makeScale(t,e,n),this.applyMatrix4(T),this}lookAt(t){return A.lookAt(t),A.updateMatrix(),this.applyMatrix4(A.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(R).negate(),this.translate(R.x,R.y,R.z),this}setFromPoints(t){const n=[];for(let e=0,o=t.length;e<o;e++){const o=t[e];n.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new e(n,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new h);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new l(-1/0,-1/0,-1/0),new l(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];P.setFromBufferAttribute(n),this.morphTargetsRelative?(S.addVectors(this.boundingBox.min,P.min),this.boundingBox.expandByPoint(S),S.addVectors(this.boundingBox.max,P.max),this.boundingBox.expandByPoint(S)):(this.boundingBox.expandByPoint(P.min),this.boundingBox.expandByPoint(P.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new m);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new l,1/0);if(t){const n=this.boundingSphere.center;if(P.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];M.setFromBufferAttribute(n),this.morphTargetsRelative?(S.addVectors(P.min,M.min),P.expandByPoint(S),S.addVectors(P.max,M.max),P.expandByPoint(S)):(P.expandByPoint(M.min),P.expandByPoint(M.max))}P.getCenter(n);let o=0;for(let e=0,r=t.count;e<r;e++)S.fromBufferAttribute(t,e),o=Math.max(o,n.distanceToSquared(S));if(e)for(let r=0,i=e.length;r<i;r++){const i=e[r],s=this.morphTargetsRelative;for(let e=0,r=i.count;e<r;e++)S.fromBufferAttribute(i,e),s&&(R.fromBufferAttribute(t,e),S.add(R)),o=Math.max(o,n.distanceToSquared(S))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,o=e.position.array,r=e.normal.array,i=e.uv.array,s=o.length/3;void 0===e.tangent&&this.setAttribute("tangent",new d(new Float32Array(4*s),4));const a=e.tangent.array,c=[],h=[];for(let t=0;t<s;t++)c[t]=new l,h[t]=new l;const p=new l,f=new l,m=new l,g=new u,b=new u,v=new u,y=new l,x=new l;function w(t,e,n){p.fromArray(o,3*t),f.fromArray(o,3*e),m.fromArray(o,3*n),g.fromArray(i,2*t),b.fromArray(i,2*e),v.fromArray(i,2*n),f.sub(p),m.sub(p),b.sub(g),v.sub(g);const r=1/(b.x*v.y-v.x*b.y);isFinite(r)&&(y.copy(f).multiplyScalar(v.y).addScaledVector(m,-b.y).multiplyScalar(r),x.copy(m).multiplyScalar(b.x).addScaledVector(f,-v.x).multiplyScalar(r),c[t].add(y),c[e].add(y),c[n].add(y),h[t].add(x),h[e].add(x),h[n].add(x))}let E=this.groups;0===E.length&&(E=[{start:0,count:n.length}]);for(let t=0,e=E.length;t<e;++t){const e=E[t],o=e.start;for(let t=o,r=o+e.count;t<r;t+=3)w(n[t+0],n[t+1],n[t+2])}const T=new l,A=new l,R=new l,P=new l;function M(t){R.fromArray(r,3*t),P.copy(R);const e=c[t];T.copy(e),T.sub(R.multiplyScalar(R.dot(e))).normalize(),A.crossVectors(P,e);const n=A.dot(h[t])<0?-1:1;a[4*t]=T.x,a[4*t+1]=T.y,a[4*t+2]=T.z,a[4*t+3]=n}for(let t=0,e=E.length;t<e;++t){const e=E[t],o=e.start;for(let t=o,r=o+e.count;t<r;t+=3)M(n[t+0]),M(n[t+1]),M(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new d(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const o=new l,r=new l,i=new l,s=new l,a=new l,c=new l,u=new l,h=new l;if(t)for(let l=0,d=t.count;l<d;l+=3){const d=t.getX(l+0),p=t.getX(l+1),f=t.getX(l+2);o.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),i.fromBufferAttribute(e,f),u.subVectors(i,r),h.subVectors(o,r),u.cross(h),s.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),c.fromBufferAttribute(n,f),s.add(u),a.add(u),c.add(u),n.setXYZ(d,s.x,s.y,s.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(f,c.x,c.y,c.z)}else for(let t=0,s=e.count;t<s;t+=3)o.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),i.fromBufferAttribute(e,t+2),u.subVectors(i,r),h.subVectors(o,r),u.cross(h),n.setXYZ(t+0,u.x,u.y,u.z),n.setXYZ(t+1,u.x,u.y,u.z),n.setXYZ(t+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const o in n){if(void 0===t.attributes[o])continue;const r=n[o].array,i=t.attributes[o],s=i.array,a=i.itemSize*e,l=Math.min(s.length,r.length-a);for(let t=0,e=a;t<l;t++,e++)r[e]=s[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)S.fromBufferAttribute(t,e),S.normalize(),t.setXYZ(e,S.x,S.y,S.z)}toNonIndexed(){function t(t,e){const n=t.array,o=t.itemSize,r=t.normalized,i=new n.constructor(e.length*o);let s=0,a=0;for(let r=0,l=e.length;r<l;r++){s=t.isInterleavedBufferAttribute?e[r]*t.data.stride+t.offset:e[r]*o;for(let t=0;t<o;t++)i[a++]=n[s++]}return new d(i,o,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new B,n=this.index.array,o=this.attributes;for(const r in o){const i=t(o[r],n);e.setAttribute(r,i)}const r=this.morphAttributes;for(const o in r){const i=[],s=r[o];for(let e=0,o=s.length;e<o;e++){const o=t(s[e],n);i.push(o)}e.morphAttributes[o]=i}e.morphTargetsRelative=this.morphTargetsRelative;const i=this.groups;for(let t=0,n=i.length;t<n;t++){const n=i[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const o=n[e];t.data.attributes[e]=o.toJSON(t.data)}const o={};let r=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],i=[];for(let e=0,o=n.length;e<o;e++){const o=n[e];i.push(o.toJSON(t.data))}i.length>0&&(o[e]=i,r=!0)}r&&(t.data.morphAttributes=o,t.data.morphTargetsRelative=this.morphTargetsRelative);const i=this.groups;i.length>0&&(t.data.groups=JSON.parse(JSON.stringify(i)));const s=this.boundingSphere;return null!==s&&(t.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const o=t.attributes;for(const t in o){const n=o[t];this.setAttribute(t,n.clone(e))}const r=t.morphAttributes;for(const t in r){const n=[],o=r[t];for(let t=0,r=o.length;t<r;t++)n.push(o[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const i=t.groups;for(let t=0,e=i.length;t<e;t++){const e=i[t];this.addGroup(e.start,e.count,e.materialIndex)}const s=t.boundingBox;null!==s&&(this.boundingBox=s.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}B.prototype.isBufferGeometry=!0,this.ConvexGeometry=class extends B{constructor(t){super();const n=[],o=[];void 0===c&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");const r=(new s.ConvexHull).setFromPoints(t).faces;for(let t=0;t<r.length;t++){const e=r[t];let i=e.edge;do{const t=i.head().point;n.push(t.x,t.y,t.z),o.push(e.normal.x,e.normal.y,e.normal.z),i=i.next}while(i!==e.edge)}this.setAttribute("position",new e(n,3)),this.setAttribute("normal",new e(o,3))}};const O=a.THREE.MOUSE,H=a.THREE.Quaternion,L=a.THREE.Spherical,N=a.THREE.TOUCH,C={type:"change"},k={type:"start"},I={type:"end"};this.OrbitControls=class extends w{constructor(t,e){super(),void 0===e&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new l,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:O.ROTATE,MIDDLE:O.DOLLY,RIGHT:O.PAN},this.touches={ONE:N.ROTATE,TWO:N.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return s.phi},this.getAzimuthalAngle=function(){return s.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",Q),this._domElementKeyEvents=t},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(C),n.update(),r=o.NONE},this.update=function(){const e=new l,u=(new H).setFromUnitVectors(t.up,new l(0,1,0)),p=u.clone().invert(),f=new l,m=new H,g=2*Math.PI;return function(){const t=n.object.position;e.copy(t).sub(n.target),e.applyQuaternion(u),s.setFromVector3(e),n.autoRotate&&r===o.NONE&&R(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(s.theta+=a.theta*n.dampingFactor,s.phi+=a.phi*n.dampingFactor):(s.theta+=a.theta,s.phi+=a.phi);let l=n.minAzimuthAngle,b=n.maxAzimuthAngle;return isFinite(l)&&isFinite(b)&&(l<-Math.PI?l+=g:l>Math.PI&&(l-=g),b<-Math.PI?b+=g:b>Math.PI&&(b-=g),s.theta=l<=b?Math.max(l,Math.min(b,s.theta)):s.theta>(l+b)/2?Math.max(l,s.theta):Math.min(b,s.theta)),s.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,s.phi)),s.makeSafe(),s.radius*=c,s.radius=Math.max(n.minDistance,Math.min(n.maxDistance,s.radius)),!0===n.enableDamping?n.target.addScaledVector(h,n.dampingFactor):n.target.add(h),e.setFromSpherical(s),e.applyQuaternion(p),t.copy(n.target).add(e),n.object.lookAt(n.target),!0===n.enableDamping?(a.theta*=1-n.dampingFactor,a.phi*=1-n.dampingFactor,h.multiplyScalar(1-n.dampingFactor)):(a.set(0,0,0),h.set(0,0,0)),c=1,!!(d||f.distanceToSquared(n.object.position)>i||8*(1-m.dot(n.object.quaternion))>i)&&(n.dispatchEvent(C),f.copy(n.object.position),m.copy(n.object.quaternion),d=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",$),n.domElement.removeEventListener("pointerdown",U),n.domElement.removeEventListener("pointercancel",K),n.domElement.removeEventListener("wheel",J),n.domElement.removeEventListener("pointermove",Z),n.domElement.removeEventListener("pointerup",W),null!==n._domElementKeyEvents&&n._domElementKeyEvents.removeEventListener("keydown",Q)};const n=this,o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let r=o.NONE;const i=1e-6,s=new L,a=new L;let c=1;const h=new l;let d=!1;const p=new u,f=new u,m=new u,g=new u,b=new u,v=new u,y=new u,x=new u,w=new u,E=[],T={};function A(){return Math.pow(.95,n.zoomSpeed)}function R(t){a.theta-=t}function P(t){a.phi-=t}const M=function(){const t=new l;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),h.add(t)}}(),S=function(){const t=new l;return function(e,o){!0===n.screenSpacePanning?t.setFromMatrixColumn(o,1):(t.setFromMatrixColumn(o,0),t.crossVectors(n.object.up,t)),t.multiplyScalar(e),h.add(t)}}(),B=function(){const t=new l;return function(e,o){const r=n.domElement;if(n.object.isPerspectiveCamera){const i=n.object.position;t.copy(i).sub(n.target);let s=t.length();s*=Math.tan(n.object.fov/2*Math.PI/180),M(2*e*s/r.clientHeight,n.object.matrix),S(2*o*s/r.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(M(e*(n.object.right-n.object.left)/n.object.zoom/r.clientWidth,n.object.matrix),S(o*(n.object.top-n.object.bottom)/n.object.zoom/r.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function X(t){n.object.isPerspectiveCamera?c/=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*t)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function j(t){n.object.isPerspectiveCamera?c*=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/t)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function _(t){p.set(t.clientX,t.clientY)}function F(t){g.set(t.clientX,t.clientY)}function q(){if(1===E.length)p.set(E[0].pageX,E[0].pageY);else{const t=.5*(E[0].pageX+E[1].pageX),e=.5*(E[0].pageY+E[1].pageY);p.set(t,e)}}function Y(){if(1===E.length)g.set(E[0].pageX,E[0].pageY);else{const t=.5*(E[0].pageX+E[1].pageX),e=.5*(E[0].pageY+E[1].pageY);g.set(t,e)}}function G(){const t=E[0].pageX-E[1].pageX,e=E[0].pageY-E[1].pageY,n=Math.sqrt(t*t+e*e);y.set(0,n)}function z(t){if(1==E.length)f.set(t.pageX,t.pageY);else{const e=nt(t),n=.5*(t.pageX+e.x),o=.5*(t.pageY+e.y);f.set(n,o)}m.subVectors(f,p).multiplyScalar(n.rotateSpeed);const e=n.domElement;R(2*Math.PI*m.x/e.clientHeight),P(2*Math.PI*m.y/e.clientHeight),p.copy(f)}function V(t){if(1===E.length)b.set(t.pageX,t.pageY);else{const e=nt(t),n=.5*(t.pageX+e.x),o=.5*(t.pageY+e.y);b.set(n,o)}v.subVectors(b,g).multiplyScalar(n.panSpeed),B(v.x,v.y),g.copy(b)}function D(t){const e=nt(t),o=t.pageX-e.x,r=t.pageY-e.y,i=Math.sqrt(o*o+r*r);x.set(0,i),w.set(0,Math.pow(x.y/y.y,n.zoomSpeed)),X(w.y),y.copy(x)}function U(t){!1!==n.enabled&&(0===E.length&&(n.domElement.setPointerCapture(t.pointerId),n.domElement.addEventListener("pointermove",Z),n.domElement.addEventListener("pointerup",W)),function(t){E.push(t)}(t),"touch"===t.pointerType?function(t){switch(et(t),E.length){case 1:switch(n.touches.ONE){case N.ROTATE:if(!1===n.enableRotate)return;q(),r=o.TOUCH_ROTATE;break;case N.PAN:if(!1===n.enablePan)return;Y(),r=o.TOUCH_PAN;break;default:r=o.NONE}break;case 2:switch(n.touches.TWO){case N.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&G(),n.enablePan&&Y(),r=o.TOUCH_DOLLY_PAN;break;case N.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&G(),n.enableRotate&&q(),r=o.TOUCH_DOLLY_ROTATE;break;default:r=o.NONE}break;default:r=o.NONE}r!==o.NONE&&n.dispatchEvent(k)}(t):function(t){let e;switch(t.button){case 0:e=n.mouseButtons.LEFT;break;case 1:e=n.mouseButtons.MIDDLE;break;case 2:e=n.mouseButtons.RIGHT;break;default:e=-1}switch(e){case O.DOLLY:if(!1===n.enableZoom)return;!function(t){y.set(t.clientX,t.clientY)}(t),r=o.DOLLY;break;case O.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enablePan)return;F(t),r=o.PAN}else{if(!1===n.enableRotate)return;_(t),r=o.ROTATE}break;case O.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enableRotate)return;_(t),r=o.ROTATE}else{if(!1===n.enablePan)return;F(t),r=o.PAN}break;default:r=o.NONE}r!==o.NONE&&n.dispatchEvent(k)}(t))}function Z(t){!1!==n.enabled&&("touch"===t.pointerType?function(t){switch(et(t),r){case o.TOUCH_ROTATE:if(!1===n.enableRotate)return;z(t),n.update();break;case o.TOUCH_PAN:if(!1===n.enablePan)return;V(t),n.update();break;case o.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&D(t),n.enablePan&&V(t)}(t),n.update();break;case o.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&D(t),n.enableRotate&&z(t)}(t),n.update();break;default:r=o.NONE}}(t):function(t){if(!1!==n.enabled)switch(r){case o.ROTATE:if(!1===n.enableRotate)return;!function(t){f.set(t.clientX,t.clientY),m.subVectors(f,p).multiplyScalar(n.rotateSpeed);const e=n.domElement;R(2*Math.PI*m.x/e.clientHeight),P(2*Math.PI*m.y/e.clientHeight),p.copy(f),n.update()}(t);break;case o.DOLLY:if(!1===n.enableZoom)return;!function(t){x.set(t.clientX,t.clientY),w.subVectors(x,y),w.y>0?X(A()):w.y<0&&j(A()),y.copy(x),n.update()}(t);break;case o.PAN:if(!1===n.enablePan)return;!function(t){b.set(t.clientX,t.clientY),v.subVectors(b,g).multiplyScalar(n.panSpeed),B(v.x,v.y),g.copy(b),n.update()}(t)}}(t))}function W(t){!1!==n.enabled&&(t.pointerType,n.dispatchEvent(I),r=o.NONE,tt(t),0===E.length&&(n.domElement.releasePointerCapture(t.pointerId),n.domElement.removeEventListener("pointermove",Z),n.domElement.removeEventListener("pointerup",W)))}function K(t){tt(t)}function J(t){!1===n.enabled||!1===n.enableZoom||r!==o.NONE&&r!==o.ROTATE||(t.preventDefault(),n.dispatchEvent(k),function(t){t.deltaY<0?j(A()):t.deltaY>0&&X(A()),n.update()}(t),n.dispatchEvent(I))}function Q(t){!1!==n.enabled&&!1!==n.enablePan&&function(t){let e=!1;switch(t.code){case n.keys.UP:B(0,n.keyPanSpeed),e=!0;break;case n.keys.BOTTOM:B(0,-n.keyPanSpeed),e=!0;break;case n.keys.LEFT:B(n.keyPanSpeed,0),e=!0;break;case n.keys.RIGHT:B(-n.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),n.update())}(t)}function $(t){!1!==n.enabled&&t.preventDefault()}function tt(t){delete T[t.pointerId];for(let e=0;e<E.length;e++)if(E[e].pointerId==t.pointerId)return void E.splice(e,1)}function et(t){let e=T[t.pointerId];void 0===e&&(e=new u,T[t.pointerId]=e),e.set(t.pageX,t.pageY)}function nt(t){const e=t.pointerId===E[0].pointerId?E[1]:E[0];return T[e.pointerId]}n.domElement.addEventListener("contextmenu",$),n.domElement.addEventListener("pointerdown",U),n.domElement.addEventListener("pointercancel",K),n.domElement.addEventListener("wheel",J,{passive:!1}),this.update()}}}get THREE(){return void 0===r&&console.error("three: invalid _THREE = "+r+". Call three.THREE = THREE first."),r}set dat(t){i?Object.is(t,i)||console.error("three: duplicate dat. Please use one instance of the dat library."):i=t}get dat(){return i}}).isThree=function(){return r},window.__myThree__.three=a);var c=a;const u=function(){const t=function(){if(document.currentScript&&""!==document.currentScript.src)return document.currentScript.src;const t=document.getElementsByTagName("script");return""!==t[t.length-1].src?src:(new Error).stack.match(/(https?:[^:]*)/)[0]}();return t.substring(0,t.lastIndexOf("/"))}();l.sync(u+"/colorpicker.css",{tag:"style"});const h=window.SVGAngle||document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")?"SVG":"VML",d="http://www.w3.org/2000/svg";var p=0;class f{constructor(){const t=this;function e(t,e,n){for(var o in t=document.createElementNS(d,t),e)t.setAttribute(o,e[o]);"[object Array]"!=Object.prototype.toString.call(n)&&(n=[n]);for(var r=0,i=n[0]&&n.length||0;r<i;r++)t.appendChild(n[r]);return t}this.paletteIndexes={BGYW:0,monochrome:1,bidirectional:2,rainbow:3},this.create=function(t,n){function o(){return"horizontal"===n.orientation}if((n=n||{}).orientation=n.orientation||"horizontal",void 0===n.direction&&(n.direction=!0),n.style=n.style||{},n.style.width=n.style.width||(o()?200:30),n.style.height=n.style.height||(o()?30:200),n.onError=n.onError||function(){},t instanceof HTMLElement!=!0){if("string"!=typeof t)return void console.error("ColorPicker.create: invalid elSliderWrapper = "+t);if(null===(t=document.getElementById(t)))return void console.error("ColorPicker.create: invalid elSliderWrapper = "+t)}for(var r in t.classList.add("slider-wrapper"),n.style)t.style[r]=n.style[r];const i=n.palette instanceof this.palette?n.palette:new this.palette(n);var s,a,l,c;function u(){return"string"==typeof n.style.height?parseInt(n.style.height):n.style.height}function f(){return s.clientWidth}function m(t,e){if(void 0===a)return void console.error("Set value of this instance of the ColorPicker is impossible because options.sliderIndicator is not defined.");const r=i.hsv2rgb(t);void 0!==r?(t=r.percent,void 0===e&&(e=o()?f()*t/100:u()-u()*(n.direction?t:100-t)/100),function(t){if(void 0===a)return;if(o()){if(t<0||t>f())return void console.error("ColorPicker.positionIndicators: Invalid position = "+t);a.style.top="0px",a.style.left=(n.direction?t:f()-t)-a.offsetWidth/2+"px"}else{if(t<0||t>u())return void console.error("ColorPicker.positionIndicators: Invalid position = "+t);a.style.left="0px",a.style.top=t-a.offsetHeight/2+"px"}}(e),void 0!==n.sliderIndicator.callback&&n.sliderIndicator.callback(r)):console.error("ColorPicker.setValue: invalud c = "+r)}if(void 0!==n.sliderIndicator&&((a=document.createElement("div")).className="slider-indicator",o()?a.style.width="10px":a.style.height="10px",t.appendChild(a),a.style.pointerEvents="none"),"SVG"==h){try{const t="linearGradient";s=e("svg",{xmlns:d,version:"1.1",width:o()?"100%":n.style.width,height:n.style.height},[e("defs",{},e(t,{id:"gradient-hsv-"+p,x1:o()&&n.direction?"100%":"0%",y1:o()||n.direction?"0%":"100%",x2:o()&&!n.direction?"100%":"0%",y2:!o()&&n.direction?"100%":"0%"},i.getPalette())),e("rect",{x:"0",y:"0",width:"100%",height:"100%",fill:"url(#gradient-hsv-"+p+")"})]),void 0!==a&&(s.style.cursor=o()?"e-resize":"s-resize",a.style.cursor=s.style.cursor)}catch(t){console.error("Create SVG element failed! "+t.message)}t.appendChild(s),t.style.height=u()+"px",void 0!==a&&(o()?a.style.height=parseInt(n.style.height)-2+"px":a.style.width=parseInt(n.style.width)-2+"px",n.sliderIndicator.value=n.sliderIndicator.value||0,m(n.sliderIndicator.value)),p++}else console.error("Under constraction");function g(t){var e,r,i;t.x=parseInt(t.x),t.y=parseInt(t.y),o()?(e=t.x,r=f()-1,e>=f()&&(e=r),i=100*e/r,n.direction||(i=100-i,e=r-e)):(e=t.y,r=u()-1,e>=u()&&(e=r),i=100*(1-e/r),n.direction||(i=100-i)),m(i,e)}if(void 0!==a){var b=!1;function v(){return function(t){b||g(function(t){if(window.event&&void 0!==window.event.contentOverflow)return{x:window.event.offsetX,y:window.event.offsetY};if(void 0!==t.offsetX&&void 0!==t.offsetY)return{x:t.offsetX,y:t.offsetY};var e=t.target.parentNode.parentNode;return{x:t.layerX-e.offsetLeft,y:t.layerY-e.offsetTop}}(t=t||window.event))}}function y(t,e,n){null!==t&&(t.attachEvent?t.attachEvent("on"+e,n):t.addEventListener&&t.addEventListener(e,n,!1))}y(s,"click",v()),l=v(),y(c=s,"touchstart",function(t){}),y(c,"touchmove",function(t){t.preventDefault();var e=t.srcElement.getBoundingClientRect(),n=t.touches[0].clientX-e.left,o=t.touches[0].clientY-e.top;n<0&&(n=0),o<0&&(o=0),g({x:n,y:o})}),y(c,"touchend",function(t){}),y(c,"mousedown",function(t){const e="mouseup",n="mousemove";y(window,e,function t(){function o(t,e,n){null!==t&&(t.detachEvent?t.detachEvent("on"+e,n):t.removeEventListener&&t.removeEventListener(e,n,!1))}o(window,e,t),o(window,n,l)}),y(window,n,l)}),y(c,"mouseout",function(t){b=!0}),y(c,"mouseover",function(t){b=!1})}return{setValue:m}},this.palette=function(n){function o(t,e,n,o){return{percent:t,r:e,g:n,b:o}}void 0===(n=n||{}).palette&&(n.palette=t.paletteIndexes.BGYW),this.getPaletteIndex=function(){return n.palette};var r=[new o(0,0,0,255),new o(33,0,255,0),new o(66,255,255,0),new o(100,255,255,255)];switch(typeof n.palette){case"number":switch(n.palette){case t.paletteIndexes.BGYW:break;case t.paletteIndexes.monochrome:r=[new o(0,0,0,0),new o(100,255,255,255)];break;case t.paletteIndexes.bidirectional:r=[new o(0,255,48,48),new o(50,48,48,48),new o(100,48,255,48)];break;case t.paletteIndexes.rainbow:r=[new o(0,255,50,50),new o(16,252,245,40),new o(32,40,252,40),new o(50,40,252,248),new o(66,39,46,249),new o(82,255,40,251),new o(100,255,50,50)];break;default:console.error("ColorPicker.create.Palette: invalid options.palette = "+n.palette)}break;case"object":if(Array.isArray(n.palette)){r=n.palette;break}default:var i="invalid options.palette = "+n.palette;console.error("ColorPicker.create.Palette: "+i),n.onError(i)}this.isPalette=function(){return!0},this.getPalette=function(){const t=[];return r.forEach(function(n){t.unshift(e("stop",{offset:100-n.percent+"%","stop-color":"#"+("0"+Number(n.r).toString(16)).slice(-2).toUpperCase()+("0"+Number(n.g).toString(16)).slice(-2).toUpperCase()+("0"+Number(n.b).toString(16)).slice(-2).toUpperCase(),"stop-opacity":"1"}))}),t},this.hsv2rgb=function(t,e,o){var i=parseFloat(t);isNaN(i)&&(i=o),void 0!==e&&void 0!==o&&(i=100/(o-e)*(i-e));var s,a=r[r.length-1];if(100!==a.percent){const t={};Object.keys(a).forEach(function(e){t[e]=a[e]}),t.percent=100,r.push(t)}for(var l=0;l<r.length;l++){const t=r[l];if(void 0===s&&(s=t),i>=s.percent&&i<=t.percent){function c(t,e,n,o){var r=n-t;return 0===r?e:Math.round(e+(o-e)/r*(i-t))}const e=c(s.percent,s.r,t.percent,t.r),n=c(s.percent,s.g,t.percent,t.g),o=c(s.percent,s.b,t.percent,t.b);return{r:e,g:n,b:o,hex:"#"+(16777216|o|n<<8|e<<16).toString(16).slice(1),percent:i}}s=t}void 0!==n.onError&&n.onError("Invalid color value of the ColorPicker: "+t)},this.toColor=function(t,e,n){const o=c.THREE;if(t instanceof o.Color)return t;var r=this.hsv2rgb(t,e,n);return void 0===r&&(r={r:255,g:255,b:255}),new o.Color("rgb("+r.r+", "+r.g+", "+r.b+")")}}}}var m=f=new f;t.default=m,Object.defineProperty(t,"__esModule",{value:!0})});